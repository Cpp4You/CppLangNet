---
sidebar_position: 1
---

# ObsÅ‚uga pamiÄ™ci

W zarzÄ…dzaniu pamiÄ™ciÄ… moÅ¼na popeÅ‚niÄ‡ wiele bÅ‚Ä™dÃ³w. PoniÅ¼sze porady pomogÄ… Ci popeÅ‚niaÄ‡ ich mniej ğŸ˜„

## PoprawnoÅ›Ä‡ i bezpieczeÅ„stwo

### UÅ¼ywaj referencji

Zasada jest prosta: jeÅ›li dany fragment kodu **wymaga** tego, Å¼eby obiekt istniaÅ‚,
uÅ¼yj referencji a nie wskaÅºnika.

#### PrzykÅ‚ad

Mamy klasÄ™ gracza ğŸ‘¨â€ğŸ’¼:

```cpp
struct Player {
	int maxHealth	= 100;
	int health		= 100;
	int damage		= 15;
	int score		= 0;
};
```

Chcemy stworzyÄ‡ funkcje, ktÃ³ra pozwala wykonaÄ‡ atak na innym graczu:


```cpp title="âŒ Å¹LE"
void attack(Player* player, Player* target)
{
	target->health -= player->damage;

	player->score += 10;
}
```

```cpp title="âœ” DOBRZE"
void attack(Player& player, Player& target)
{
	target.health -= player.damage;

	player.score += 10;
}
```

### Surowe wskaÅºniki

Surowe wskaÅºniki (np. `int* ptr`) budzÄ… wiele kontrowersji. Warto wiedzieÄ‡ kiedy moÅ¼na ich uÅ¼ywaÄ‡.

Na poczÄ…tek:

:::tip
Nie ma nic zÅ‚ego w uÅ¼ywaniu surowych wskaÅºnikÃ³w... w odpowiedni sposÃ³b.
:::

RolÄ… surowego wskaÅºnika jest **wyÅ‚Ä…cznie** uzyskanie dostÄ™pu do okreÅ›lonego miejsca w pamiÄ™ci.

:::danger
Nie uÅ¼ywaj surowych wskaÅºnikÃ³w do **zarzÄ…dzania pamiÄ™ciÄ…** (dopÃ³ki nie masz absolutnej pewnoÅ›ci
Å¼e wiesz co robisz).


```cpp
// âŒâŒâŒ
Player *player = new Player;
// ...
delete player;
// âŒâŒâŒ
```
:::

Surowe wskaÅºniki **nie sÅ‚uÅ¼Ä…** do kontrolowania czasu Å¼ycia obiektu (czyli tego ile dany obiekt 
istnieje w pamiÄ™ci komputerowej).

Zamiast tego uÅ¼yj **inteligentnego wskaÅºnika** (*ang.: smart pointer*):

```cpp
#include <memory>

struct Player {
	std::string	name;
	int			health;
	// ...
};

int main()
{
	// W make_unique parametry konstruktora klasy Player
	auto player = std::make_unique<Player>( /*tutaj*/ );

	// "player" jest wskaÅºnikiem typu std::unique_ptr<Player>


	Player& ref = *player;
	Player* ptr = player.get(); // surowy wskaÅºnik âœ…, nie zarzÄ…dza czasem Å¼ycia

	
} // <-- nastÄ™puje automatyczne usuniÄ™cie obiektu spod wskaÅºnika "player"

```

### Przekazywanie `std::unique_ptr` do funkcji

JeÅ›li w Å›rodku nie zarzÄ…dzasz czasem Å¼ycia obiektu, [przekaÅ¼ referencjÄ™](#uÅ¼ywaj-referencji)!

JeÅ›li chcesz przekazaÄ‡ caÅ‚y obiekt do jakiegoÅ› rejestru/magazynu/*managera* (nie naduÅ¼ywajmy nazw `XyzManager`),
**przekaÅ¼ przez wartoÅ›Ä‡** i uÅ¼yj [*przeniesienia*](TODO-move-semantics):

```cpp
struct Scene
{
	void add(std::unique_ptr<Actor> actor)
	{
		// PrzenieÅ› do vectora
		actors.emplace_back( std::move(actor) );
	}

private:
	std::vector< std::unique_ptr<Actor> > actors;
};

// UÅ¼ycie:
int main() {
	Scene scene;
	// ...
	auto actor = std::make_unique<Actor>( /* ... */ );
	// ...
	scene.add( std::move(actor) ); // PrzenieÅ› do parametru funkcji "add"
}
```

### RozrÃ³Å¼niaj stos od sterty

Tymczasowe zmienne, ktÃ³re tworzymy wewnÄ…trz funkcji sÄ… **alokowane na stosie**,
a pÃ³Åºniej automatycznie usuwane, gdy wykonanie programu wyjdzie poza ich
zakres:

```cpp
struct Player { /* cokolwiek */ };

int main()
{
	// Blok kodu:
	{
		Player p;
		// ...
	} // <-- automatyczne zdjÄ™cie ze stosu "p"
}
```

Na stercie (*ang.: heap*) znajdujÄ… siÄ™ obiekty alokowane **dynamicznie**.

ZastanÃ³w siÄ™: czy poniÅ¼szy zapis oznacza, Å¼e zmienna `health` znajdzie siÄ™ <u>na stosie</u>?

```cpp
struct Player {
	int health;
	// ...
};
```

:::important ODPOWIEDÅ¹
âš  NIE
:::

Wszystko zaleÅ¼y od tego jakiego sposobu alokacji uÅ¼yjemy, by zaalokowaÄ‡ sam obiekt typu `Player`:

```cpp
int main() {
	Player p1;
	p1.health = 30; // "p1.health" jest na stosie razem z caÅ‚ym obiektem "p1"

	auto p2 = std::make_unique<Player>();
	p2->health = 30; // "p2->health" jest na stercie!
}
```

## WydajnoÅ›Ä‡

### Unikaj kopii

JeÅ›li nie potrzebujesz kopiowaÄ‡ obiektu, przekaÅ¼ go przez referencje (do staÅ‚ej, lub nie - w zaleÅ¼noÅ›ci od potrzeby).

JeÅ›li nie jest to zwykÅ‚y typ prosty (`int`, `double` itp.), tylko jest to typ zÅ‚oÅ¼ony, np.:

```cpp
struct Player
{
	std::string name;
	float posX, posY, posZ;
};
```

to:

```cpp title="âŒ Å¹LE"
void print(Player player) // player zostaje skopiowany do parametru funkcji
{
	std::cout << player.posX << ", " << player.posY << ", " << player.posZ;
}
```

```cpp title="âœ” DOBRZE"
void print(Player const& player) // referencja do staÅ‚ej, nie potrzebujemy tutaj kopiowaÄ‡
{
	std::cout << player.posX << ", " << player.posY << ", " << player.posZ;
}
```

### Ogranicz dynamiczne alokacje

Nie chcemy wytworzyÄ‡ w Tobie panicznego strachu przed dynamicznymi
alokacjami, jednak warto wiedzieÄ‡ kiedy siÄ™ przed nimi powstrzymaÄ‡.

Czasami warto skorzystaÄ‡ z [`std::array`](/docs/std/containers/arrays/array/) zamiast
[`std::vector`](/docs/std/containers/arrays/vector/) czy nawet [`std::string`](/docs/std/containers/strings/string/).
JeÅ›li moÅ¼esz oszacowaÄ‡ ile **maksymalnie** elementÃ³w bÄ™dziesz potrzebowaÅ‚ i ta liczba nie bÄ™dzie zbyt duÅ¼a,
moÅ¼esz Å›miaÅ‚o uÅ¼yÄ‡ tablicy o staÅ‚ym rozmiarze zamiast dynamicznie alokowanej.

:::important Optymalizacja string-a
Klasa `std::string` w wyniku optymalizacji (tzw. SSO) moÅ¼e przechowywaÄ‡ maÅ‚e napisy
(na 64-bitowych komputerach poniÅ¼ej 22 znakÃ³w), bez uÅ¼ywania dynamicznej alokacji.
:::

Ile to **za duÅ¼o**? Musisz to sam(a) oszacowaÄ‡. JeÅ›li ta pamiÄ™Ä‡ bÄ™dzie zuÅ¼yta tylko
tymczasowo (np. podrÄ™czny bufor o wielkoÅ›ci kilku KB do czytania z pliku) to
bez problemu moÅ¼esz uÅ¼yÄ‡:

```cpp
constexpr size_t BUFFER_SIZE = 16 * 1024;

std::array<char, BUFFER_SIZE> buf;
```

zamiast:

```cpp
std::string buf;
```

JeÅ›li potrzebujesz wiÄ™kszych pojemnoÅ›ci (wiÄ™kszych niÅ¼ megabajt) to **nie alokuj ich na stosie**:

```cpp title="âŒ Å¹LE"
int main()
{
	constexpr size_t BUFFER_SIZE = 10 * 1024 * 1024; // 10 MB

	std::array<char, BUFFER_SIZE> buf; // âŒ przepeÅ‚nienie stosu âŒ
}
```

W powyÅ¼szej sytuacji juÅ¼ jesteÅ›my skazani na uÅ¼ycie dynamicznej alokacji, przez skorzystanie
np. z `std::string`.


### Rezerwuj pamiÄ™Ä‡ z wyprzedzeniem

JeÅ›li korzystasz z kontenera, ktÃ³ry bÄ™dzie przechowywaÅ‚ wiele obiektÃ³w,
warto na poczÄ…tek luÅºno oszacowaÄ‡ ile w najbliÅ¼szym czasie ich bÄ™dzie potrzebne.

JeÅ›li wiesz, Å¼e zaraz bÄ™dziesz formatowaÅ‚ [tekst](/docs/std/containers/strings/string/), ktÃ³ry bÄ™dzie miaÅ‚ np. 100 - 1000 znakÃ³w,
moÅ¼esz Å›miaÅ‚o [zarezerwowaÄ‡](/docs/std/containers/strings/string/reserve/) trochÄ™ pamiÄ™ci z gÃ³ry (nawet nadmiarowo):

```cpp
std::string str;

// Rezerwacja pamiÄ™ci
str.reserve(128);

// Formatowanie:
str += "Gracz ";
str += player.name;
str += " posiada ";
str += std::to_string(player.health);
str += " HP";
```

:::note
PowyÅ¼szy sposÃ³b formatowania nie jest najlepszym pomysÅ‚em.
Do formatowania tekstu moÅ¼esz uÅ¼yÄ‡ np. biblioteki [**fmtlib**](https://github.com/fmtlib/fmt):

```cpp
std::string str = fmt::format("Gracz {} posiada {} HP", player.name, player.health);
```
:::

JeÅ›li zapomnimy zarezerwowaÄ‡ pamiÄ™Ä‡ wczeÅ›niej, nasz program bÄ™dzie musiaÅ‚ wykonaÄ‡ sporo alokacji
w trakcie dodawania kolejnych znakÃ³w do tekstu, przez co bÄ™dziemy tracili cenny czas.

**Nie bagatelizuj tego.**

Nie tyczy siÄ™ to tylko `string`-a, ale rÃ³wnieÅ¼ innych kontenerÃ³w, ktÃ³re trzymajÄ…
zawartoÅ›Ä‡ w ciÄ…gÅ‚ych fragmentach pamiÄ™ci i dynamicznie zmieniajÄ… swÃ³j rozmiar
(np. [`std::vector`](/docs/std/containers/arrays/vector/))

### Nie naduÅ¼ywaj `std::shared_ptr`

Ten typ wskaÅºnika pozwala na kopiowanie go w dowolnej iloÅ›ci,
przez co moÅ¼na naiwnie uznaÄ‡, Å¼e moÅ¼emy go swobodnie przekazywaÄ‡ w ten sposÃ³b np. do funkcji:


```cpp title="âŒ Å¹LE"
struct Player {
	int maxHealth	= 100;
	int health		= 100;
	int damage		= 15;
	int score		= 0;
};

void attack(std::shared_ptr<Player> player, std::shared_ptr<Player> target)
{
	target->health -= player->damage;

	player->score += 10;
}
```

Nikt Ci nie zabroni w ten sposÃ³b z nich korzystaÄ‡, ale jeÅ›li bÄ™dziesz tego naduÅ¼ywaÄ‡,
to moÅ¼esz kiedyÅ› siÄ™ zdziwiÄ‡, Å¼e Twoja gra lub aplikacja bÄ™dzie tak Å›wietna,
Å¼e aÅ¼ sam procesor siÄ™ na chwile zatrzyma, Å¼eby popatrzeÄ‡ na to cudo ğŸ˜‰

Inteligentne wskaÅºniki **sÅ‚uÅ¼Ä… do zarzÄ…dzania czasem Å¼ycia obiektu**.
JeÅ›li musisz jedynie skorzystaÄ‡ z dynamicznie zaalokowanego obiektu,
moÅ¼esz Å›miaÅ‚o uÅ¼yÄ‡ referencji lub wskaÅºnika zgodnie z [tÄ… zasadÄ…](#uÅ¼ywaj-referencji).

```cpp title="âœ” DOBRZE"
int main() {
	std::shared_ptr<Player> p1, p2;

	// ...

	attack(*p1, *p2);
}

void attack(Player& player, Player& target)
{
	target.health -= player.damage;

	player.score += 10;
}
```

### UÅ¼ywaj `std::string_view`

ZostaÅ‚ on dodany do biblioteki standardowej (nagÅ‚Ã³wek `<string_view>`) w wersji C++17.

[`string_view`](/docs/std/containers/strings/string_view/) to *widok* na ciÄ…g znakÃ³w, bez znaczenia czy pochodzi on
ze `std::string`, czy nie. Pozwala on korzystaÄ‡ wygodnie z funkcji takich jak porÃ³wnywanie,
`.substr()`, `.find()` bez koniecznoÅ›ci kopiowania lub tworzenia obiektu `std::string`.

:::caution
`std::string` jest alokowany dynamicznie, przez co nie jest najwydajniejszÄ… z opcji.
:::

Bardzo dobrym przykÅ‚adem sÄ… argumenty programu:

```cpp
int main(int argc, char *argv[])
{
	if (argc < 2) return 0; // brak wystarczajÄ…cej iloÅ›ci argumentÃ³w

	// âŒ Å¹LE:
	if ( argv[1] == "generate-something" ) 
	{
		// NIE ZADZIAÅA, porÃ³wnywanie wskaÅºnikÃ³w (czyli porÃ³wnywanie adresÃ³w)
	}
	// âŒ Å¹LE:
	if ( std::string(argv[1]) == "generate-something" )
	{
		 // ZADZIAÅA, ale jest to niepotrzebnie wolne
	}
	// âŒ Å¹LE:
	if ( std::strcmp(argv[1], "generate-something") == 0 )
	{
		 // ZADZIAÅA, ale jest to niewygodne rozwiÄ…zanie z C
	}

	// âœ… DOBRZE:
	if ( std::string_view(argv[1]) == "generate-something" )
	{
		// Szybkie i wygodne
	}
}
```
