---
sidebar_label:		"6. PÄ™tle"
title:				"PÄ™tle"
description:		"Lekcja: pÄ™tle w jÄ™zyku C++"
tags:				[pÄ™tla, for, while, range-based-for]
hide_title:			true
completion: false
---

{/* Components */}
import Image			from "@site-comps/Image";
import Columns			from "@site-comps/Columns";
import Tabs				from "@theme/Tabs";
import TabItem			from "@theme/TabItem";

{/* Presets */}
import ImproveSection	from '@site/i18n/pl/presets/ImproveSection.mdx';

# PÄ™tle

W tej lekcji kaÅ¼emy programowi wykonywaÄ‡ wielokrotnie dany kod, czyli skorzystamy z pÄ™tli.

## Motywacja

PÄ™tle majÄ… wiele zastosowaÅ„, oto kilka z nich:

- ğŸ‘¾ dodanie np. 10 nowych przeciwnikÃ³w do planszy w grze
- ğŸ–¥ wyÅ›wietlenie kaÅ¼dego elementu z tablicy
- â— wielokrotne wykonanie obliczeÅ„ (np. liczenie silni, ciÄ…g fibonacciego)

W lekcji o wektorach pokazaliÅ›my juÅ¼ jednÄ… pÄ™tlÄ™, ktÃ³ra wyÅ›wietlaÅ‚a
wszystkie elementy tablicy:

```cpp title="WyÅ›wietl kaÅ¼dÄ… liczbÄ™ z tablicy"
for (int n : numbers)
{
	std::cout << n << ' ';
}
```

Jest to najprostsza wersja pÄ™tli w C++. W nastÄ™pnych sekcjach poznasz
wiÄ™cej ich rodzajÃ³w.

## Rodzaje pÄ™tli

W C++ mamy nastÄ™pujÄ…ce pÄ™tle:

- **`for`**
	- wersja dla zasiÄ™gÃ³w (*range-based for*)
	- wersja podstawowa
- **`while`**
- **`do ... while`**

NajczÄ™Å›ciej uÅ¼ywana jest `for` oraz `while` i o nich powiemy w tej lekcji.
JeÅ›li chcesz poczytaÄ‡ o pÄ™tli `do ... while` to zapoznaj siÄ™ z artykuÅ‚em:
[**PÄ™tla `do ... while`**](articles/do-while).

:::important Iteracja (definicja)
**Iteracja** - pojedynczy obieg pÄ™tli.
:::

## WytÅ‚umaczenie

### PÄ™tla `for` (*range-based*)

Ten rodzaj pÄ™tli jest najczÄ™Å›ciej stosowany do pracy z tablicami, choÄ‡ moÅ¼e
byÄ‡ uÅ¼yty teÅ¼ w inny sposÃ³b.

<Image center border maxheight="300px"
		src="/img/tutorials/course/basic/loops/range-based-for-pl.png"
		alt="Schemat pÄ™tli range-based 'for'"
		desc="Schemat"
	/>
<br/>

W przykÅ‚adzie pokazanym w sekcji [**Motywacja**](#motywacja) znajduje siÄ™ wÅ‚aÅ›nie
pÄ™tla **range-based for**, czyli wersja pÄ™tli `for` dla tzw. zasiÄ™gÃ³w.
Tablica w rozumieniu C++ rÃ³wnieÅ¼ jest takim zasiÄ™giem, wiÄ™c moÅ¼emy Å›miaÅ‚o z niej skorzystaÄ‡.

Najprostszy przykÅ‚ad:

```cpp title="WyÅ›wietl kaÅ¼dÄ… liczbÄ™ z tablicy"
std::vector<int> numbers = { 13, 42, -1, 0, -3, -5 };

for (int n : numbers)
{
	std::cout << n << ' ';
}
```

Ta pÄ™tla kolejno przechodzi przez kaÅ¼dy element tablicy `numbers` i zapisuje go do
zmiennej `n`. NastÄ™pnie wykonywany jest blok kodu zawarty w nawiasie klamrowym.
W tym wypadku jest to wyÅ›wietlenie liczby.

:::caution Dwukropek
ZwrÃ³Ä‡ uwagÄ™, Å¼e po nazwie zmiennej `n` znajduje siÄ™ **dwukropek (`:`), nie Å›rednik (`;`)**!
Nie uÅ¼ywamy w tym zapisie Å¼adnego znaku rÃ³wnoÅ›ci (`=`), bo wartoÅ›Ä‡ kaÅ¼dego elementu po
kolei bÄ™dzie automatycznie przypisywana do `n`.
:::

### PÄ™tla `while`

<Image center border maxheight="300px"
		src="/img/tutorials/course/basic/loops/while-pl.png"
		alt="Schemat pÄ™tli 'while'"
		desc="Schemat"
	/>
<br/>

Celowo przechodzimy teraz do pÄ™tli `while`, zamiast do zwykÅ‚ego `for`, poniewaÅ¼ uÅ‚atwi to wyjaÅ›nienia.
PÄ™tla `while` wykonuje ciaÅ‚o pÄ™tli dopÃ³ki warunek jest speÅ‚niony:

<Columns columns={['2fr', '1fr']}>
<div>

```cpp title="WyÅ›wietl liczby od 0 do 3"
int number = 0;
while (number <= 3)
{
	std::cout << number << ' ';
	number++;
}
```

</div>
<div>

```plaintext title="Wynik"
0 1 2 3
```

</div>
</Columns>

Warunek zostanie sprawdzony **przed** kaÅ¼dym obiegiem pÄ™tli i tak dÅ‚ugo jak jest on speÅ‚niony,
czyli w tym wypadku tak dÅ‚ugo jak `number` jest mniejsza lub rÃ³wna `3`, to bÄ™dzie wykonywane ciaÅ‚o:

- wyÅ›wietlenie `number`
- zwiÄ™kszenie `number` o 1

Po ostatnim obiegu pÄ™tli, wartoÅ›Ä‡ `number` bÄ™dzie rÃ³wna `4`, wiÄ™c warunek nie bÄ™dzie speÅ‚niony,
przez co pÄ™tla siÄ™ zakoÅ„czy i komputer przejdzie do wykonywania nastÄ™pnych instrukcji.

### PÄ™tla `for`

<Image center border maxheight="300px"
		src="/img/tutorials/course/basic/loops/for-pl.png"
		alt="Schemat pÄ™tli 'for'"
		desc="Schemat"
	/>
<br/>

Ta pÄ™tla jest uproszczeniem pewnego **bardzo** czÄ™sto powtarzajÄ…cego siÄ™ schematu i jest ona
zazwyczaj uÅ¼ywana do krokowego przejÅ›cia przez pewien zakres (np. liczbowy).

Zacznijmy od przykÅ‚adu:

```cpp title="WyÅ›wietl liczby od 0 do 9"
for (int i = 0; i < 10; i++)
{
	std::cout << i << ' ';
}
```

PowyÅ¼sza pÄ™tla wyÅ›wietla liczby od 0 do 9. Nawias okrÄ…gÅ‚y przy `for` skÅ‚ada siÄ™ z trzech czÄ™Å›ci,
oddzielonych **Å›rednikami**:

| Fragment | Opis |
| -------- | ---- |
| `int i = 0` | instrukcja poczÄ…tkowa (zazwyczaj utworzenie zmiennej) |
| `i < 10` | warunek |
| `i++` | wyraÅ¼enie iteracji |

Gdy program zaczyna wykonywaÄ‡ pÄ™tlÄ™ `for`, jednorazowo wykonuje instrukcjÄ™ poczÄ…tkowÄ… - w naszym wypadku
tworzy zmiennÄ… i nadaje jej wartoÅ›Ä‡ `0`.
Program nastÄ™pnie:

1. sprawdzi warunek
	- niespeÅ‚niony: wyjdÅº z pÄ™tli
	- speÅ‚niony: idÅº do punktu 2
2. wykona ciaÅ‚o pÄ™tli
3. wykona wyraÅ¼enie iteracji i przejdzie do pkt. 1

PowyÅ¼sza pÄ™tla `for` jest rÃ³wnoznaczna z:

```cpp
int i = 0;
while (i < 10)
{
	std::cout << i << ' ';
	i++;
}
```

#### Iteracja po tablicach

PÄ™tli `for` bardzo czÄ™sto uÅ¼ywamy do iterowania po tablicach, w sytuacji gdy
albo potrzebujemy mieÄ‡ dostÄ™p do numeru iteracji lub gdy nie chcemy iterowaÄ‡
po caÅ‚ym zakresie.

```cpp title="Iteracja po caÅ‚ej tablicy"
std::vector<int> numbers = {10, 13, 15, 18, 60};
for (int i = 0; i < numbers.size(); i++)
{
	std::cout << "numbers[" << i << "]: " << numbers[i] << '\n';
}
```

```cpp title="Iteracja po poÅ‚owie tablicy"
std::vector<int> numbers = {10, 13, 15, 18, 60};
for (int i = 0; i < numbers.size() / 2; i++)
{
	std::cout << "numbers[" << i << "]: " << numbers[i] << '\n';
}
```

#### Pusty nawias

Kod podawany w nawiasie pÄ™tli `for` jest opcjonalny. **Åšredniki sÄ… wymagane**.

```cpp title="Brak instrukcji w nawiasie"
for ( ; ; )
{
	// kod
}
```

PowyÅ¼szy zapis sprawi, Å¼e pÄ™tla `for` bÄ™dzie wykonywaÅ‚a siÄ™ w nieskoÅ„czonoÅ›Ä‡ (ze wzglÄ™du na pusty warunek),
chyba Å¼e przerwiemy jÄ… manualnie...

## Przerwanie pÄ™tli

PÄ™tlÄ™ moÅ¼emy przerwaÄ‡ w dowolnym momencie za pomocÄ… instrukcji `break`:

```cpp
for (int i = 0; i < 10; i++)
{
	if (i == 5)
	// highlight-next-line
		break;
	std::cout << i << ' ';
}
```

Ta pÄ™tla wyÅ›wietli liczby od 0 do 4, poniewaÅ¼ przy `i` rÃ³wnym `5` wykonanie pÄ™tli zostanie przerwane.
W ten sam sposÃ³b moÅ¼emy przerwaÄ‡ pÄ™tlÄ™ `while`.

## Przerwanie obiegu pÄ™tli

Aby pominÄ…Ä‡ wykonywanie aktualnego obiegu pÄ™tli uÅ¼ywamy instrukcji `continue`:

```cpp
for (int i = 0; i < 10; i++)
{
	if (i == 5)
	// highlight-next-line
		continue;
	std::cout << i << ' ';
}
```

PÄ™tla wyÅ›wietli liczby od `0` do `9` z pominiÄ™ciem liczby `5`, bo zanim wykona instrukcjÄ™
wyÅ›wietlania (`std::cout`) to program przeskoczy do nastÄ™pnego obiegu.

:::caution PÄ™tla for i continue
ZauwaÅ¼, Å¼e uÅ¼ycie `continue` w pÄ™tli `for` nie pomija *wyraÅ¼enia iteracji* ([zobacz schemat powyÅ¼ej](#pÄ™tla-for)).
:::

## PrzykÅ‚ady

<ImproveSection />

## Potencjalne bÅ‚Ä™dy

### PrÃ³ba uÅ¼ycia zmiennej zadeklarowanej w `for` poza niÄ…

[`Instrukcja poczÄ…tkowa`](#pÄ™tla-for) w pÄ™tli for najczÄ™Å›ciej sÅ‚uÅ¼y do zadeklarowania zmiennej iteracyjnej.
Czasem siÄ™ zdarza, Å¼e chcemy uÅ¼yÄ‡ tej zmiennej poza ciaÅ‚em instrukcji `for`.
Nie jest to moÅ¼liwe, poniewaÅ¼ zmienna ta jest dostÄ™pna tylko i wyÅ‚Ä…cznie wewnÄ…trz ciaÅ‚a tej zmiennej.

<Tabs>
<TabItem value="good" label="âœ” OK" default>

```cpp
#include <iostream>

int main()
{
	for(int i = 0; i < 5; i++)
		// highlight-next-line
		std::cout << i; // ğŸŸ¢ Ok, zmienna uÅ¼yta wewnÄ…trz pÄ™tli
}
```

</TabItem>
<TabItem value="good2" label="âœ” OK">

```cpp
#include <iostream>

int main()
{
	int sum = 0;
	for(int i = 0; i < 5; i++) 
	{ 
		// highlight-next-line
		sum += i; // ğŸŸ¢ Ok, zmienna uÅ¼yta wewnÄ…trz pÄ™tli
	}
	
	std::cout << sum << '\n';
}
```

</TabItem>
<TabItem value="bad" label="âŒ Å¹le">

```cpp
#include <iostream>

int main()
{
	for(int i = 0; i < 5; i++)
		std::cout << i;

	// highlight-next-line
	std::cout << i; // ğŸ”´ Nie ok, zmienna uÅ¼yta poza pÄ™tlÄ…
}
```

W przypadku niepoprawnego kodu wyÅ¼ej, moÅ¼emy spotkaÄ‡ siÄ™ z nastepujÄ…cymi bÅ‚Ä™dami:

<Tabs groupId="compiler">
<TabItem value="clang" label="CLANG" default>

```plaintext
error: use of underclared identifier 'i'
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Ilustracja bÅ‚Ä™du - uÅ¼ycie zmiennej poza pÄ™tlÄ…"
		src="/img/tutorials/course/basic/loops/error-trying-to-use-variable-out-of-loop-clang.png"
	/>

</TabItem>
<TabItem value="gcc" label="GCC">

```plaintext
error: 'i' was not declared in this scope
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Ilustracja bÅ‚Ä™du - uÅ¼ycie zmiennej poza pÄ™tlÄ…"
		src="/img/tutorials/course/basic/loops/error-trying-to-use-variable-out-of-loop-gcc.png"
	/>

</TabItem>
<TabItem value="msvc" label="MSVC">

```plaintext
error C2065: 'i': undeclared identifier
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Ilustracja bÅ‚Ä™du - uÅ¼ycie zmiennej poza pÄ™tlÄ…"
		src="/img/tutorials/course/basic/loops/error-trying-to-use-variable-out-of-loop-msvc.png"
	/>

</TabItem>
</Tabs>

</TabItem>
</Tabs>

### Niepoprawny warunek w for

Jednym z najczÄ™stszych bÅ‚Ä™dow **logicznych** ktÃ³ry zdarza siÄ™ podczas uÅ¼ywania pÄ™tli `for` to zapisanie zÅ‚ego warunku pÄ™tli.

Warunek pÄ™tli to wyraÅ¼enie, ktÃ³re decyduje o dalszym przebiegu pÄ™tli (lub w ogÃ³le zaczÄ™ciu przebiegu pÄ™tli), wiÄ™c jeÅ›li zapiszemy niepoprawny warunek,
nasza pÄ™tla moÅ¼e lecieÄ‡ w nieskoÅ„czonoÅ›Ä‡, nigdy siÄ™ nie zaczÄ…Ä‡, lub wykonaÄ‡ siÄ™ niepoprawnÄ… liczbÄ™ razy.

NaleÅ¼y wiÄ™c dokÅ‚adnie analizowaÄ‡ warunki w bardziej skomplikowanych pÄ™tlach.

### Iteracja od tyÅ‚u

JeÅ›li uÅ¼ywamy `auto` lub `std::size_t` jako typ zmiennej iteracyjnej i chcemy iterowaÄ‡ od **N** do **0**, moÅ¼emy siÄ™ spotkaÄ‡ z przykrÄ… niespodziankÄ….

RozwaÅ¼my przykÅ‚adowy kod wypisujÄ…cy liczby z tablicy od tyÅ‚u:

```cpp title="Niepoprawna pÄ™tla for"
#include <iostream>
#include <vector>

int main()
{
	std::vector<int> numbers = { 5, 4, 3, 2, 1 };

	std::cout << "Liczby wypisane od tyÅ‚u: ";
	for(auto i = numbers.size() - 1; i >= 0; i--)
	{
		std::cout << numbers[i] << ' ';
	}
}
```

Kiedy uruchomimy ten program, wpadnie on w nieskoÅ„czonÄ… pÄ™tlÄ™.

Jak na razie nie bÄ™dziemy omawiaÄ‡ szczegÃ³Å‚Ã³w tego problemu, jednak zapamiÄ™tajmy, Å¼e zamiast `auto` moÅ¼na w tym przypadku uÅ¼yÄ‡ `int` i to rozwiÄ…Å¼e problem:

```cpp
// ...
// highlight-next-line
for(int i = numbers.size() - 1; i >= 0; i--)
// ...
```

Bardzo moÅ¼liwe, Å¼e kompilator pokaÅ¼e nam w tym przypadku ostrzeÅ¼enie, jednak nie naleÅ¼y siÄ™ tym przejmowaÄ‡.
PÃ³Åºniej w kursie omÃ³wimy szczegÃ³Å‚y tego problemu i inne jego rozwiÄ…zania.

## Dodatkowe informacje

### NieskoÅ„czona pÄ™tla

NieskoÅ„czonÄ… pÄ™tlÄ™ moÅ¼emy utworzyÄ‡ na dwa sposoby:

```cpp title="NieskoÅ„czona pÄ™tla for"
for(;;) 
{
	// ... kod
}
```

```cpp title="NieskoÅ„czona pÄ™tla while"
while(true) 
{
	// ... kod
}
```

Kod wykonywany w Å›rodku bÄ™dzie siÄ™ wykonywaÄ‡ w nieskoÅ„czonoÅ›Ä‡,
dopÃ³ki nie bÄ™dzie przerwany wewnÄ…trz (np. za pomocÄ… instrukcji `break`, `return` (*ktÃ³rÄ… poznamy w [**lekcji o funkcjach**](/learn/course/basics/functions/)*),
czy wywoÅ‚aniem funkcji, ktÃ³ra nie powraca, np. [`std::exit`](#))

Tego typu pÄ™tle sÄ… czÄ™sto wykorzystywane w programach w miejsach, gdzie ma dziaÅ‚aÄ‡ kod obsÅ‚ugujÄ…cy pewnego rodzaju zdarzenia.
Np. nieskoÅ„czona pÄ™tla obsÅ‚ugujÄ…ca okienko graficzne, ktÃ³ra obsÅ‚uguje zdarzenia z systemu operacyjnego, pÄ™tla gÅ‚Ã³wna gry, etc.

### PÄ™tla w pÄ™tli

Kod pÄ™tli jest takim samym kodem, jaki moÅ¼emy napisaÄ‡ praktycznie gdziekolwiek indziej, to znaczy,
Å¼e moÅ¼emy rÃ³wnieÅ¼ zapisaÄ‡ pÄ™tlÄ™ w pÄ™tli. Taki rodzaj pÄ™tli nazywamy pÄ™tlÄ… **zagnieÅ¼dÅ¼onÄ…** (tak samo instrukcjÄ™ `if` w instrukcji `if` nazwiemy **zagnieÅ¼dÅ¼onÄ…** instrukcjÄ… `if`).

MoÅ¼emy to wykorzystaÄ‡, Å¼eby np. usunÄ…Ä‡ z listy zawodnikÃ³w druÅ¼yny e-sportowej kaÅ¼dego gracza, ktÃ³ry przegraÅ‚:

<Columns spacing={40} columns={['1fr', '1fr']}>
<div>

```cpp title="PÄ™tla zagnieÅ¼dÅ¼ona"
#include <iostream>
#include <string>
#include <vector>

int main()
{
	std::vector<std::string> teamMembers = { "Marek", "Karolina", "Arek", "Filip", "Maja" };
	std::vector<std::string> membersThatLost = { "Maja", "Marek", "Arek" };

	for(int i = 0; i < teamMembers.size(); i++)
	{
		for(int j = 0; j < membersThatLost.size(); j++)
		{
			if(teamMembers[i] == membersThatLost[j])
				teamMembers.erase(teamMembers.begin() + i);
		}
	}

	std::cout << "Gracze, ktÃ³rzy jeszcze Å¼yjÄ…: ";
	for(auto member : teamMembers)
	{
		std::cout << member << ' ';
	}
}
```

</div>

<div>

```plaintext title="Wynik (konsola)"
Gracze, ktÃ³rzy jeszcze Å¼yjÄ…: Karolina Filip
```

</div>
</Columns>

### Konwencja `i`, `j`

KonwencjÄ… jest nazywanie zmiennej iteracyjnej w pÄ™tli `i` (skrÃ³t od *iterator*), oraz `j` w pÄ™tli zagnieÅ¼dÅ¼onej.
Jesli czujemy potrzebÄ™ nazwania naszej zmiennej inaczej, bardziej opisowo, to powinniÅ›my to robiÄ‡,
jednak jeÅ›li nasza pÄ™tla bÄ™dzie zawieraÅ‚a stosunkowo maÅ‚o kodu i bÄ™dzie wiadomo czym jest `i`, to bez wahania moÅ¼na tÄ™ nazwÄ™ wykorzystaÄ‡.