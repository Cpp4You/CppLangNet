---
sidebar_position:	8
sidebar_label:		"8. Struktury"
title:				Struktury
description:		"Lekcja: struktury w jÄ™zyku C++"
tags:				[struktura, obiekt, klasa, programowanie-obiektowe, oop]
hide_title:			true
---

{/* Components */}
import Columns			from "@site-comps/Columns";
import CustomCodeBlock	from "@site-comps/CustomCodeBlock";
import Image			from "@site-comps/Image";

{/* Presets */}
import NotFinished		from '@site/i18n/pl/presets/NotFinished.mdx';
import ImproveSection	from '@site/i18n/pl/presets/ImproveSection.mdx';

# Struktury

W tej lekcji nauczysz siÄ™ tworzenia typÃ³w danych, zÅ‚oÅ¼onych z wielu mniejszych
elementÃ³w, czyli tego co w C++ nazywamy strukturami.

## Motywacja

<Image center
		maxheight={200}
		alt="Prezentacja przeciwnika - Goblin"
		src="/img/tutorials/course/basic/structures/GoblinEnemy.gif"
		desc={<>Obrazek goblina wykonany przez <a href="https://luizmelo.itch.io/monsters-creatures-fantasy">LuizMelo</a></>}
	/>
<br/>

JeÅ›li np. tworzÄ…c grÄ™ ğŸ®, chcemy zawrzeÄ‡ w swoim programie przeciwnikÃ³w,
zwykle bÄ™dziemy musieli o kaÅ¼dym z nich zapisac kilka informacji.

ZastanÃ³w siÄ™: jakie dane o wrogach w grze mogÄ… siÄ™ przydaÄ‡?
MoÅ¼e to byÄ‡ np.:

- nazwa ğŸ‘¾
- Å¼ycie ğŸ’š
- siÅ‚a ğŸ’ª

itd...

KorzystajÄ…c z dotychczas nabytej wiedzy, gdybyÅ›my chcieli napisaÄ‡ program,
ktÃ³ry przechowuje te informacje, moglibyÅ›my zrobiÄ‡ to np. tak:

```cpp
#include <string>

int main() {
	std::string	enemyName = "Goblin";
	float		enemyHealth = 50;
	float		enemyStrength = 12;
	// ...
}
```

Gdy bÄ™dziemy chcieli mieÄ‡ w grze wiÄ™cej przeciwnikÃ³w, napotkamy na pewnien problem,
a wÅ‚aÅ›ciwie uniedogodnienie:

JeÅ›li skorzystamy w tym celu z wielu tablic:

```cpp
std::vector< std::string >	enemyNames;
std::vector< float >		enemyHealth;
std::vector< float >		enemyStrength;
```

to kaÅ¼dy przeciwnik bÄ™dzie opisany pod jednakowym indeksem w tych tablicach:

- `enemyNames[ index ]` opisuje nazwÄ™
- `enemyHealth[ index ]` opisuje punkty Å¼ycia
- `enemyStrength[ index ]` opisuje punkty siÅ‚y


:::important Uwaga
Ten sposÃ³b wiÄ…Å¼e siÄ™ z "rozrzuceniem" informacji o pojedynczym
przeciwniku, po wielu tablicach.
:::

Dodanie jednego wroga do zbioru, w takim programie wyglÄ…daÅ‚oby tak:

```cpp
enemyNames.push_back("Goblin");
enemyHealth.push_back(50);
enemyStrength.push_back(10);
```

Im wiÄ™cej rÃ³Å¼nych informacji chcemy o przeciwnikach przechowaÄ‡, tym bÄ™dzie to
bardziej uciÄ…Å¼liwe. Na szczÄ™Å›cie tutaj z pomocÄ… przychodzÄ… nam
**struktury**.

## Tworzenie struktury

Przypomnijmy sobie, jakie dane potrzebujemy przechowaÄ‡:

- nazwa ğŸ‘¾
- Å¼ycie ğŸ’š
- siÅ‚a ğŸ’ª

Zaraz dodamy strukturÄ™, dziÄ™ki ktÃ³rej, bÄ™dziemy mogli utworzyÄ‡ **obiekt**,
ktÃ³ry zawiera w sobie te 3 rzeczy.

```cpp
#include <string>

struct Enemy
{
	std::string	name;
	float		health;
	float		strength;
};

int main()
{
	// Na razie pusto
}
```

PowyÅ¼szy kod wprowadza nowÄ… **strukturÄ™** - `Enemy`.

:::important ZapamiÄ™taj
**Struktura** to opis, wzorzec, receptura na to, jak utworzyÄ‡ **obiekt** (w tym wypadku wroga).
:::

Å»eby utworzyÄ‡ strukturÄ™, piszemy po sÅ‚owie kluczowym `struct` jej nazwÄ™, nastÄ™pnie
miÄ™dzy nawiasami klamrowymi `{` `}` umieszczamy jej *zawartoÅ›Ä‡*.

ZawartoÅ›ciÄ… mogÄ… byÄ‡ np. zmienne skÅ‚adowe.

<div id="srednik-po-definicji" />

:::danger Åšrednik!
ZwrÃ³Ä‡ uwagÄ™, na **obowiÄ…zkowy** Å›rednik po nawiasie klamrowym, zamykajÄ…cym definicjÄ™
struktury:
```cpp
struct Enemy
{
	std::string	name;
	float		health;
	float		strength;
	// highlight-next-line
};
```
:::

## Obiekty

Popatrz jak stworzyÄ‡ obiekt, ktÃ³ry korzysta ze wzoru `Enemy`:

```cpp
int main()
{
	Enemy boss;
}
```

W ten sposÃ³b, zawarliÅ›my te wszystkie 3 pola (`name`, `health` i `strength`)
wewnÄ…trz jednej zmiennej `boss`.

:::note Nazewnictwo
Od teraz bÄ™dziemy mÃ³wili, Å¼e `boss` jest **obiektem** typu **`Enemy`**.
To oznacza, Å¼e zostaÅ‚ stworzony wedÅ‚ug wzoru `Enemy`.
:::

### DostÄ™p do pÃ³l

Tak jak wyÅ¼ej wspomniaÅ‚em, `boss` zawiera w sobie 3 rzeczy (pola) tj. skÅ‚ada siÄ™ z trzech zmiennych.
Å»eby dostaÄ‡ siÄ™ do konkretnej skÅ‚adowej tego obiektu, musimy uÅ¼yÄ‡ nastÄ™pujÄ…cego zapisu:

```cpp title="Ustaw nazwÄ™ bossa na 'Ogr'"
boss.name = "Ogr";
```

UÅ¼ywamy kropki `.`, do odniesienia siÄ™ do pola obiektu. W ten sam sposÃ³b,
moÅ¼emy np. *zmodyfikowaÄ‡ siÅ‚Ä™ wroga*:

```cpp title="Modyfikowanie pÃ³l obiektu"
boss.strength	= 50; // Ustawiam siÅ‚Ä™ na 50

// Boss wÅ‚Ä…cza tryb "furia" - siÅ‚a zwiÄ™kszona
// Å»ycie zmniejszone o poÅ‚owÄ™
boss.strength	+= 25;
boss.health		*= 0.5f;
```

... lub wyÅ›wietliÄ‡ informacje o nim:

```cpp title="Korzystanie z pÃ³l obiektu"
#include <iostream>
#include <string>

struct Enemy
{
	std::string	name;
	float		health;
	float		strength;
};

int main()
{
	// TworzÄ™ obiekt bossa
	Enemy boss;
	// PrzypisujÄ™ temu obiektowi konkretne wartoÅ›ci
	boss.name		= "Ogr";
	boss.health		= 250;
	boss.strength	= 50;

	std::cout	<< boss.name		<< " posiada "
				<< boss.health		<< " hp i "
				<< boss.strength	<< " siÅ‚y."
				<< std::endl;
}
```

### Przekazywanie do funkcji

Nic nie stoi na przeszkodzie, Å¼eby stworzyÄ‡ funkcjÄ™,
ktÃ³ra przyjmuje obiekt pewnej struktury jako parametr.
Dobrym przykÅ‚adem bedzie wÅ‚aÅ›nie wyÅ›wietlanie informacji o wrogu:

```cpp title="Funkcja wyÅ›wietlajÄ…ca informacje o przeciwniku"
void printEnemyInfo(Enemy enemy)
{
	std::cout	<< enemy.name		<< " posiada "
				<< enemy.health		<< " hp i "
				<< enemy.strength	<< " siÅ‚y."
				<< std::endl;
}
```

:::danger KolejnoÅ›Ä‡
`printEnemyInfo` wymaga istnienia typu `Enemy` **przed** zdefiniowaniem
samej funkcji. Oznacza to, Å¼e musimy umieÅ›ciÄ‡ funkcjÄ™ **pod**
utworzeniem struktury (zobacz przykÅ‚ad niÅ¼ej).
:::


KorzystajÄ…c w powyÅ¼szych informacji, utworzymy sobie "grÄ™",
ktÃ³ra bÄ™dzie posiadaÅ‚a dwÃ³ch przeciwnikÃ³w:

- zwykÅ‚y przeciwnik ğŸ‘¹:  
**Goblin wojownik**, `60` Å¼ycia, `14` siÅ‚y

- boss ğŸ’€:  
**Ogr**, `250` Å¼ycia, `50` siÅ‚y


<CustomCodeBlock maxLines={25}>

```cpp title="Fragment gry z Ogrem i Goblinem" showLineNumbers
#include <iostream>
#include <string>

/// Utworzenie struktury
struct Enemy
{
	std::string	name;
	float		health;
	float		strength;
};

/// Funkcja wyÅ›wietlajÄ…ca informacje o przeciwniku
void printEnemyInfo(Enemy enemy)
{
	std::cout	<< enemy.name		<< " posiada "
				<< enemy.health		<< " hp i "
				<< enemy.strength	<< " siÅ‚y."
				<< std::endl;
}

/// Funkcja gÅ‚Ã³wna programu
int main()
{
	// TworzÄ™ obiekt goblina i bossa
	Enemy boss;
	Enemy goblin;

	// Ustawiam goblinowi odpowiednie wartoÅ›ci
	goblin.name		= "Goblin wojownik";
	goblin.health	= 60;
	goblin.strength	= 14;

	// Ustawiam bossowi odpowiednie wartoÅ›ci
	boss.name		= "Ogr";
	boss.health		= 250;
	boss.strength	= 50;

	// WyÅ›wietlam informacje o kaÅ¼dym z nich:
	printEnemyInfo(goblin);
	printEnemyInfo(boss);
}
```

</CustomCodeBlock>

### Umieszczanie wewnÄ…trz tablicy

Obiekty moÅ¼emy umieszczaÄ‡ wewnÄ…trz tablic tak samo jak normalne zmienne:

```cpp title="Tablica przeciwnikÃ³w"
std::vector< Enemy > enemies;
```

PoniÅ¼ej przykÅ‚ad jak dodawaÄ‡ do takiej tablicy:

```cpp title="Wykorzystanie tablicy"
// ...

int main()
{
	std::vector< Enemy > enemies;

	// (opcjonalnie)
	// Blok kodu, by ograniczyÄ‡ widocznoÅ›Ä‡
	// zmiennych utworzonych wewnÄ…trz
	{
		// TworzÄ™ goblina ğŸ‘‰ lokalnie ğŸ‘ˆ
		Enemy goblin;
		// Ustawiam goblinowi odpowiednie wartoÅ›ci
		goblin.name		= "Goblin wojownik";
		goblin.health	= 60;
		goblin.strength	= 14;

		// DodajÄ™ goblina do tablicy
		// highlight-next-line
		enemies.push_back( goblin );
	}
	// ğŸ‘ˆ od tego momentu goblin istnieje tylko w tablicy enemies

	// WyÅ›wietl wszystkich przeciwnikÃ³w:
	for (Enemy enemy : enemies)
		printEnemyInfo(enemy);
}
```

:::tip PrzykÅ‚ad
Po zapoznaniu siÄ™ z tÄ… lekcjÄ…, przejrzyj ten przykÅ‚adowy program:
[**ğŸ‘¾ Arena walki**](../example-programs/combat-arena) wraz z jego omÃ³wieniem.
Zobaczysz tam zastosowanie tablic i struktur w praktyce.
:::

### DomyÅ›lne wartoÅ›ci pÃ³l

Elementom struktury moÅ¼emy nadaÄ‡ domyÅ›lne wartoÅ›ci, przez co
nie bÄ™dziemy musieli ich za kaÅ¼dym razem wypeÅ‚niaÄ‡.

Dobrym przykÅ‚adem uÅ¼ycia domyÅ›lnej wartoÅ›ci jest zmienna,
ktÃ³ra przechowuje caÅ‚kowitÄ… iloÅ›Ä‡ obraÅ¼eÅ„, ktÃ³re zadaÅ‚
przeciwnik. Na poczÄ…tek dla kaÅ¼dego wroga, ta wartoÅ›Ä‡
bÄ™dzie musiaÅ‚a byÄ‡ rÃ³wna `0`.

:::caution WartoÅ›Ä‡ zmiennych
JeÅ›li pozostawisz pole struktury **bez domyÅ›lnej wartoÅ›ci**, np.:
```cpp
struct Car
{
	int numberOfWheels; // iloÅ›c kÃ³Å‚ samochodu
};
```

to nie oznacza to, Å¼e `numberOfWheels` na poczÄ…tku otrzyma wartoÅ›Ä‡ `0`, musisz to zrobiÄ‡ **rÄ™cznie**!
:::

Å»eby przypisaÄ‡ domyÅ›lnÄ… wartoÅ›Ä‡ do pola struktury
uÅ¼ywamy zwykÅ‚ej inicjalizacji, znanÄ… z tworzenia zmiennych:


```cpp title="DomyÅ›lna wartoÅ›Ä‡ dla 'totalDamage' âš”"
/// Utworzenie struktury
struct Enemy
{
	std::string	name;
	float		health;
	float		strength;

	// highlight-next-line
	float		totalDamage = 0; // iloÅ›Ä‡ obraÅ¼eÅ„
};
```

Teraz gdy stworzymy jakiegoÅ› wroga:

```cpp
Enemy snake; // np. wÄ…Å¼
```

to wartoÅ›Ä‡

```cpp
snake.totalDamage
```

bÄ™dzie rÃ³wna `0`.

MoÅ¼esz siÄ™ o tym przekonaÄ‡, np. wyÅ›wietlajÄ…c jÄ…:

<Columns columns={['2fr', '1fr']}>
<div>

```cpp
int main() {
	Enemy snake;
	snake.name = "WÄ…Å¼";
	// ğŸŸ¡ Uwaga, nie ustawiam rÄ™cznie wartoÅ›ci totalDamage

	std::cout	<< snake.name
				<< " zadaÅ‚ Å‚Ä…cznie "
				<< snake.totalDamage
				<< " obraÅ¼eÅ„";
}
```

</div>
<div>

```plaintext title="Wynik"
WÄ…Å¼ zadaÅ‚ Å‚Ä…cznie 0 obraÅ¼eÅ„
```

</div>
</Columns>

## Potencjalne bÅ‚Ä™dy

<ImproveSection />

Oto lista popularnych bÅ‚Ä™dÃ³w zwiÄ…zanych z tÄ… lekcjÄ…:

### Brak Å›rednika po definicji

[Tylko dla przypomnienia.](#srednik-po-definicji)

### NieprawidÅ‚owa kolejnoÅ›Ä‡

Upewnij siÄ™, Å¼e struktura jest zdefiniowana **przed**
jej pierwszym uÅ¼yciem.

PrzykÅ‚ad **bÅ‚Ä™dnego** kodu:

```cpp title="ğŸ”´ Niepoprawna kolejnoÅ›Ä‡"
// âŒ BÅ‚Ä…d: uÅ¼ycie "Enemy" przed zdefiniowaniem
// error-next-line
void printEnemyInfo(Enemy enemy)
{
	std::cout	<< enemy.name		<< " posiada "
				<< enemy.health		<< " hp i "
				<< enemy.strength	<< " siÅ‚y."
				<< std::endl;
}

/// Utworzenie struktury
struct Enemy
{
	std::string	name;
	float		health;
	float		strength;
};
```

:::tip Ciekawostka
Ten problem jest moÅ¼liwy do rozwiÄ…zania w inny, wygodniejszy
sposÃ³b niÅ¼ przenoszenie funkcji `printEnemyInfo` pod definicjÄ™
struktury, jednak o tzw. *forward declaration* wspomnimy
w dalszej czÄ™Å›ci kursu.
:::

### Modyfikacja wewnÄ…trz definicji struktury

Zmiennych **nie moÅ¼emy** modyfikowaÄ‡ wewnÄ…trz definicji struktury.
MoÅ¼liwe jest jedynie przypisanie poczÄ…tkowej wartoÅ›ci:

```cpp title="ğŸ”´ PrÃ³ba modyfikacji w zÅ‚ym miejscu"
struct Enemy
{
	std::string	name;
	float		health;
	float		strength;

	int			totalDamage = 0; // OK âœ…

	// âŒ BÅ‚Ä…d: prÃ³ba modyfikacji w zÅ‚ym miejscu
	// error-next-line
	health = 250;
};
```