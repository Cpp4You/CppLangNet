---
sidebar_label: "8. Struktury"
title: "Struktury"
description: "Lekcja: podstawy struktur w C++"
tags: [struktura, obiekt, klasa, programowanie-obiektowe, obiektowe, oop]
hide_title: true
---

{/* Components */}
import Columns from "@site-comps/Columns";
import CustomCodeBlock from "@site-comps/CustomCodeBlock";
import Image from "@site-comps/Image";

{/* Codes */}
import FullCode_UsingObjectFields from './_codes/structures/full-code-using-object-fields.mdx';

# Struktury

W tej lekcji dowiesz siÄ™, jak tworzyÄ‡ typy danych skÅ‚adajÄ…ce siÄ™ z wielu
mniejszych elementÃ³w - to, co w C++ nazywamy strukturami.

## Motywacja

<Image center
		maxheight={200}
		alt="Prezentacja przeciwnika - Goblin"
		src="/img/tutorials/course/basic/structures/GoblinEnemy.gif"
		desc={<>Obrazek goblina autorstwa <a href="https://luizmelo.itch.io/monsters-creatures-fantasy">LuizMelo</a></>}
	/>
<br/>

JeÅ›li na przykÅ‚ad, tworzÄ…c grÄ™ ğŸ®, chcemy umieÅ›ciÄ‡ w naszym programie przeciwnikÃ³w,
zazwyczaj bÄ™dziemy musieli zapisaÄ‡ pewne informacje o kaÅ¼dym z nich.

ZastanÃ³w siÄ™, jakie dane o wrogach w grze mogÄ… byÄ‡ przydatne? MogÄ… to byÄ‡ na przykÅ‚ad:

- nazwa ğŸ‘¾
- punkty Å¼ycia ğŸ’š
- siÅ‚a ğŸ’ª

itp.

WykorzystujÄ…c dotychczas zdobytÄ… wiedzÄ™, gdybyÅ›my chcieli napisaÄ‡ program, ktÃ³ry przechowuje te
informacje, moglibyÅ›my to zrobiÄ‡ tak:

```cpp
#include <string>

int main() {
	std::string enemy_name = "Goblin";
	float enemy_health = 50;
	float enemy_strength = 12;
	// ...
}
```

Kiedy bÄ™dziemy chcieli mieÄ‡ wiÄ™cej przeciwnikÃ³w w grze, napotkamy problem,
a raczej niedogodnoÅ›Ä‡:

JeÅ›li uÅ¼yjemy do tego celu wielu tablic:

```cpp
std::vector< std::string > enemy_names;
std::vector< float > enemy_health;
std::vector< float > enemy_strength;
```

wtedy kaÅ¼dy przeciwnik bÄ™dzie opisany pod tym samym indeksem w tych tablicach:

- `enemy_names[ index ]` opisuje imiÄ™
- `enemy_health[ index ]` opisuje punkty Å¼ycia
- `enemy_strength[ index ]` opisuje punkty siÅ‚y

KonsekwencjÄ… skorzystania z tego sposobu jest "rozproszenie" informacji o jednym przeciwniku po wielu tablicach.
Wtedy dodanie jednego wroga do zbioru w takim programie wyglÄ…daÅ‚oby tak:

```cpp
enemy_names.push_back("Goblin");
enemy_health.push_back(50);
enemy_strength.push_back(10);
```

Im wiÄ™cej informacji o naszych przeciwnikach chcemy przechowywaÄ‡, tym bardziej uciÄ…Å¼liwe
to bÄ™dzie. Na szczÄ™Å›cie, z pomocÄ… przychodzÄ… nam **struktury**.

## Terminologia

- **Struktura** to przepis na to, jak stworzyÄ‡ obiekt (w tym przypadku przeciwnika).
  Grupuje ze sobÄ… wiele zmiennych w jednÄ… caÅ‚oÅ›Ä‡.
- **Obiekt** to konkretna *instancja* struktury, np. konkretny wrÃ³g.
  <details>
    <summary>Bardziej szczegÃ³Å‚owa definicja</summary>
    <div>
      W C++ obiekt to poÅ›redni sposÃ³b dostÄ™pu do pamiÄ™ci komputera. Reprezentuje obszar pamiÄ™ci
      ktÃ³ry przechowuje dane okreÅ›lonego typu. ZwykÅ‚a zmienna fundamentalnego typu (np. `int`, `float` itp.)
      jest rÃ³wnieÅ¼ obiektem, jednak w kontekÅ›cie tej lekcji bÄ™dziemy uÅ¼ywaÄ‡ tego terminu w odniesieniu do struktur.
      Zmienna jest obiektem z nazwÄ… (identyfikatorem), ktÃ³rej moÅ¼na uÅ¼yÄ‡ do uzyskania dostÄ™pu do jej wartoÅ›ci.
      <a href="/docs/lang/object" target="_blank">PeÅ‚na definicja</a>.
    </div>
  </details>


## Tworzenie struktur

Przypomnijmy sobie, jakie dane musimy przechowywaÄ‡:

- nazwa
- punkty Å¼ycia
- siÅ‚a

Zamierzamy dodaÄ‡ strukturÄ™, ktÃ³ra pozwoli nam stworzyÄ‡ obiekt zawierajÄ…cy te 3 rzeczy.

```cpp
#include <string>

struct Enemy
{
	std::string name;
	float health;
	float strength;
};

int main()
{
	// Na razie zostawiamy puste
}
```

PowyÅ¼szy kod wprowadza nowÄ… **strukturÄ™** - `Enemy`.

### SkÅ‚adnia

Aby utworzyÄ‡ strukturÄ™, piszemy jej nazwÄ™ po sÅ‚owie kluczowym `struct`, nastÄ™pnie umieszczamy jej zawartoÅ›Ä‡
miÄ™dzy nawiasami klamrowymi `{` i `}`.

W C++ struktura moÅ¼e zawieraÄ‡:

- dane skÅ‚adowe (zmienne)
- funkcje skÅ‚adowe (metody)

i inne, bardziej zaawansowane elementy, ktÃ³re omÃ³wimy pÃ³Åºniej w kursie.

<div id="semicolon-at-structure-end" />

:::danger Åšrednik
ZwrÃ³Ä‡ uwagÄ™ na **obowiÄ…zkowy** Å›rednik `;` po nawiasach klamrowych zamykajÄ…cych definicjÄ™ struktury.

<details>
  <summary>PrzykÅ‚ad</summary>
  <div>
    ```cpp
    struct Enemy
    {
      std::string name;
      float health;
      float strength;
      // highlight-next-line
    };
    ```
  </div>
</details>

:::

## Obiekty

Aby tworzyÄ‡ zmienne okreÅ›lonego typu, uÅ¼ywaliÅ›my nastÄ™pujÄ…cej skÅ‚adni:

```cpp
// prism-push-types:Typ
Typ nazwa_zmiennej;
```

UÅ¼ywamy tej samej skÅ‚adni, aby utworzyÄ‡ obiekt typu struktury:

```cpp
int main()
{
	Enemy boss;
}
```

W ten sposÃ³b zawarliÅ›my wszystkie te 3 skÅ‚adowe (`name`, `health` i `strength`) wewnÄ…trz jednej zmiennej `boss`.

Przypomnijmy terminologiÄ™. BiorÄ…c pod uwagÄ™ powyÅ¼szy kod, mÃ³wimy, Å¼e `boss` jest obiektem (instancjÄ…) typu `Enemy`.
Oznacza to, Å¼e struktura `Enemy` zostaÅ‚a uÅ¼yta jako przepis do stworzenia obiektu `boss`.

### DostÄ™p do skÅ‚adowych

Jak wspomniano powyÅ¼ej, `boss` zawiera 3 pola skÅ‚adowe.
Aby uzyskaÄ‡ dostÄ™p do konkretnego elementu tego obiektu, uÅ¼ywamy operatora kropki `.`:

```cpp title="Ustaw imiÄ™ bossa na 'Ogr'"
boss.name = "Ogr";

std::cout << boss.name; // Wypisuje Ogr
```

W ten sam sposÃ³b moÅ¼emy modyfikowaÄ‡ *siÅ‚Ä™* wroga:

```cpp title="Modyfikowanie danych obiektu"
boss.strength	= 50; // Ustawiam siÅ‚Ä™ bossa na 50

// Boss wÅ‚Ä…cza umiejÄ™tnoÅ›Ä‡ "furia" - siÅ‚a wzrasta
// Zdrowie zmniejsza siÄ™ o poÅ‚owÄ™
boss.strength += 25;
boss.health *= 0.5f;
```

... lub wyÅ›wietlaÄ‡ o nim informacje:

<CustomCodeBlock fullCode={<FullCode_UsingObjectFields/>}>

```cpp title="UÅ¼ywanie danych skÅ‚adowych obiektu"
// prism-push-types:Enemy
// Tworze obiekt bossa
Enemy boss;
// i przypisuje wartoÅ›ci jego skÅ‚adowym
boss.name = "Ogr";
boss.health = 250;
boss.strength = 50;

std::cout << boss.name << " ma "
  << boss.health << " hp i "
  << boss.strength << " sily."
  << std::endl;
```

</CustomCodeBlock>

### Przekazywanie obiektÃ³w do funkcji

Nic nie stoi na przeszkodzie, aby stworzyÄ‡ funkcjÄ™, ktÃ³ra przyjmuje jako parametr obiekt okreÅ›lonej struktury.
Dobrym przykÅ‚adem bÄ™dzie wÅ‚aÅ›nie wyÅ›wietlanie informacji o wrogu:

```cpp title="Funkcja, ktÃ³ra wyÅ›wietla informacje o przeciwniku"
void print_enemy_info(Enemy enemy)
{
	std::cout << enemy.name << " ma "
		<< enemy.health << " hp i "
		<< enemy.strength << " sily."
		<< std::endl;
}
```

:::danger KolejnoÅ›Ä‡
`print_enemy_info` wymaga, aby typ `Enemy` istniaÅ‚ **zanim** funkcja sama zostanie zdefiniowana.
Oznacza to, Å¼e musimy umieÅ›ciÄ‡ funkcjÄ™ pod definicjÄ… struktury (patrz przykÅ‚ad poniÅ¼ej).
:::

WykorzystujÄ…c powyÅ¼sze informacje, stworzymy "grÄ™", ktÃ³ra bÄ™dzie miaÅ‚a dwÃ³ch przeciwnikÃ³w:

- zwykÅ‚y wrÃ³g ğŸ‘¹:  
**Wojownik Goblin**, `60` zdrowia, `14` siÅ‚y

- boss ğŸ’€:  
**Ogr**, `250` zdrowia, `50` siÅ‚y

<CustomCodeBlock maxLines={25}>

```cpp title="Fragment kodu gry z Ogrem i Goblinem" showLineNumbers
#include <iostream>
#include <string>

// Tworzenie struktury
struct Enemy
{
	std::string name;
	float health;
	float strength;
};

// Funkcja, ktÃ³ra wyÅ›wietla informacje o wrogu
void print_enemy_info(Enemy enemy)
{
	std::cout << enemy.name << " ma "
		<< enemy.health << " hp i "
		<< enemy.strength << " sily."
		<< std::endl;
}

// Funkcja gÅ‚Ã³wna
int main()
{
	// TworzÄ™ obiekty bossa i goblina
	Enemy boss;
	Enemy goblin;

	// KonfigurujÄ™ pola obiektu goblina
	goblin.name = "Wojownik Goblin";
	goblin.health = 60;
	goblin.strength = 14;

	// KonfigurujÄ™ pola obiektu bossa
	boss.name = "Ogr";
	boss.health = 250;
	boss.strength = 50;

	// i wyÅ›wietlam informacje o nich
	print_enemy_info(goblin);
	print_enemy_info(boss);
}
```

</CustomCodeBlock>

### Obiekty wewnÄ…trz tablic

MoÅ¼emy umieszczaÄ‡ obiekty wewnÄ…trz tablic tak samo, jak zwykÅ‚e zmienne:

```cpp title="Wektor wrogÃ³w"
std::vector< Enemy > enemies;
```

PoniÅ¼ej znajduje siÄ™ przykÅ‚ad, jak dodaÄ‡ do takiej tablicy:

```cpp title="Dodawanie obiektÃ³w do wektora"
// ...

int main()
{
	std::vector< Enemy > enemies;

	// (opcjonalnie)
	// Blok kodu, aby ograniczyÄ‡ zakres
	// zmiennych lokalnych wewnÄ…trz
	{
		// TworzÄ™ zmiennÄ… goblin ğŸ‘‰ lokalnie ğŸ‘ˆ
		Enemy goblin;
		// KonfigurujÄ™ pola
		goblin.name = "Wojownik Goblin";
		goblin.health = 60;
		goblin.strength = 14;

		// DodajÄ™ obiekt do wektora
		// highlight-next-line
		enemies.push_back( goblin );
	}
	// ğŸ‘ˆ od tego momentu goblin istnieje TYLKO wewnÄ…trz wektora

	// WyÅ›wietl kaÅ¼dego wroga w wektorze
	for (Enemy enemy : enemies)
		print_enemy_info(enemy);
}
```

:::tip PrzykÅ‚ad
Po przeczytaniu tej lekcji, przejrzyj ten przykÅ‚adowy program: [**ğŸ‘¾ Arena Walk**](../example-programs/combat-arena)
i jego omÃ³wienie. Tam zobaczysz, jak tablice i struktury sÄ… wykorzystywane w praktyce.
:::

### DomyÅ›lne wartoÅ›ci pÃ³l

MoÅ¼emy przypisaÄ‡ elementom struktury domyÅ›lne wartoÅ›ci, dziÄ™ki czemu nie bÄ™dziemy musieli ich wypeÅ‚niaÄ‡ za kaÅ¼dym razem.

Dobrym przykÅ‚adem uÅ¼ycia wartoÅ›ci domyÅ›lnej jest zmienna, ktÃ³ra przechowuje caÅ‚kowitÄ… iloÅ›Ä‡ obraÅ¼eÅ„,
ktÃ³re zadaÅ‚ przeciwnik. Na poczÄ…tek, dla kaÅ¼dego wroga, ta wartoÅ›Ä‡ bÄ™dzie musiaÅ‚a byÄ‡ rÃ³wna `0`.

:::caution WartoÅ›ci pÃ³l
JeÅ›li pozostawisz pole struktury bez wartoÅ›ci domyÅ›lnej, np.:
```cpp
struct Car
{
	int number_of_wheels;
};
```

to nie oznacza, Å¼e `number_of_wheels` zostanie ustawione na `0` w momencie tworzenia obiektu,
musisz to zrobiÄ‡ **rÄ™cznie**!
:::

Aby przypisaÄ‡ wartoÅ›Ä‡ domyÅ›lnÄ… do pola struktury, uÅ¼ywamy zwykÅ‚ej inicjalizacji,
znanej z tworzenia zmiennych:

```cpp title="DomyÅ›lna wartoÅ›Ä‡ dla 'total_damage' âš”"
// Tworzenie struktury
struct Enemy
{
	std::string name;
	float health;
	float strength;

	// highlight-next-line
	float total_damage = 0;
};
```

Teraz, gdy stworzymy jakiegoÅ› wroga:

```cpp
Enemy snake; // wÄ…Å¼ jako przykÅ‚ad
```

to wartoÅ›Ä‡ jego pola `total_damage`

```cpp
snake.total_damage
```

zostanie ustawiona automatycznie na `0`.

MoÅ¼esz siÄ™ o tym przekonaÄ‡, np. wypisujÄ…c jÄ…:

<Columns columns={['2fr', '1fr']}>
<div>

```cpp
int main() {
	Enemy snake;
	snake.name = "Snake";
	// ğŸŸ¡ ZwrÃ³Ä‡ uwagÄ™, Å¼e nie ustawiam "total_damage" rÄ™cznie

	std::cout << snake.name
		<< " zadal lacznie "
		<< snake.total_damage
		<< " obrazen\n";
}
```

</div>
<div>

```plaintext title="Wynik"
Snake zadal lacznie 0 obrazen
```

</div>
</Columns>

## Funkcje w strukturze

Struktury mogÄ… zawieraÄ‡ rÃ³wnieÅ¼ funkcje, ktÃ³re nazywamy **metodami**. SÄ… one powiÄ…zane z obiektem, na ktÃ³rym sÄ… wywoÅ‚ywane.

<Image center
		maxheight={250}
		alt="Prezentacja przeciwnika i jego akcji - Goblin"
		src="/img/tutorials/course/basic/structures/goblin-struct-data-and-methods.gif"
		desc={<>Obrazek goblina autorstwa <a href="https://luizmelo.itch.io/monsters-creatures-fantasy">LuizMelo</a></>}
	/>
<br/>

RozwaÅ¼my nasz przykÅ‚ad z goblinem. MoÅ¼emy dodaÄ‡ do struktury `Enemy` metody, ktÃ³re reprezentujÄ… czynnoÅ›Ä‡,
jakÄ… ten wrÃ³g moÅ¼e wykonaÄ‡, np. atakowanie, bronienie siÄ™, czy ucieczka.

```cpp title="Dodanie metod do struktury"
struct Enemy
{
	std::string name;
	float health;
	float strength;

  // highlight-start
	void attack()
	{
		// Logika ataku
		std::cout << name << " atakuje z " << strength << " sily.\n";
	}

	void defend()
	{
		// Logika obrony
		std::cout << name << " broni sie majac " << health << " hp.\n";
	}

  void run_away()
	{
		// Logika ucieczki
		std::cout << name << " dokonuje odwrotu przy " << health << " pkt zycia.\n";
	}
  // highlight-end
};
```

W powyÅ¼szym przykÅ‚adzie dodaliÅ›my trzy metody do struktury `Enemy`: `attack`, `defend` i `run_away`.
KaÅ¼da z nich wypisuje komunikat do konsoli, symulujÄ…c wykonanie danej akcji. Funkcje skÅ‚adowe otrzymujÄ… kontekst obiektu,
na ktÃ³rym sÄ… wywoÅ‚ywane, dziÄ™ki czemu mogÄ… operowaÄ‡ na jego danych (np. `name`, `health`, `strength`).

<details>
  <summary>Kontekst obiektu</summary>
  <div>
    W przyszÅ‚oÅ›ci dowiesz siÄ™, Å¼e metody otrzymujÄ… "ukryty" argument, nazywajÄ…cy siÄ™ `this` (jest to rÃ³wnieÅ¼ sÅ‚owo kluczowe),
    ktÃ³ry jest wÅ‚aÅ›nie "kontekstem" obiektu, na ktÃ³rym metoda jest wywoÅ‚ywana.
    Zawsze gdy odnosisz siÄ™ do pola skÅ‚adowego wewnÄ…trz metody, np. `name`, jest to ekwiwalentem zapisu:

    ```cpp
    this->name
    ```

    O wskaÅºnikach (w tym `this`) dowiesz siÄ™ wiÄ™cej w przyszÅ‚ych lekcjach.
  </div>
</details>

WywoÅ‚anie metod na obiekcie odbywa siÄ™ za pomocÄ… operatora kropki `.`, podobnie jak w przypadku dostÄ™pu do danych skÅ‚adowych:

```cpp
int main()
{
	Enemy boss;
	boss.name = "Ogr";
	boss.health = 250;
	boss.strength = 50;

  // highlight-next-line
	boss.attack();

  // highlight-next-line
	boss.run_away();
}
```

Mamy moÅ¼liwoÅ›Ä‡ rÃ³wnieÅ¼ wywoÅ‚aÄ‡ inne metody wewnÄ…trz tej samej struktury:

```cpp title="WywoÅ‚anie metody w metodzie"
void run_away()
{
  // najpierw obrona, potem ucieczka
  // highlight-next-line
  defend();
  std::cout << name << " ucieka!\n";
}
```

WiÄ™cej o metodach powiemy w dalszej czÄ™Å›ci kursu.

## CzÄ™ste problemy

ZebraliÅ›my nastÄ™pujÄ…cÄ… listÄ™ czÄ™sto wystÄ™pujÄ…cych problemÃ³w, ktÃ³re dotyczÄ… uÅ¼ywania struktur w podstawowym zakresie.

### Brak Å›rednika po definicji

[Tylko dla przypomnienia.](#semicolon-at-structure-end)

### NieprawidÅ‚owa kolejnoÅ›Ä‡

Upewnij siÄ™, Å¼e struktura jest zdefiniowana **przed** pierwszym uÅ¼yciem.

PrzykÅ‚ad **nieprawidÅ‚owego** kodu:

```cpp title="NieprawidÅ‚owa kolejnoÅ›Ä‡"
// âŒ BÅ‚Ä…d: uÅ¼ycie typu "Enemy" przed jego definicjÄ…
// error-next-line
void print_enemy_info(Enemy enemy)
{
	std::cout << enemy.name << " ma "
		<< enemy.health		<< " hp i "
		<< enemy.strength	<< " sily."
		<< std::endl;
}

// Tworzenie struktury
struct Enemy
{
	std::string name;
	float health;
	float strength;
};
```

PrÃ³ba skompilowania tego programu zakoÅ„czy siÄ™ bÅ‚Ä™dem kompilacji.

:::tip
Problem ten moÅ¼na rozwiÄ…zaÄ‡ w inny, wygodniejszy sposÃ³b niÅ¼ przenoszenie funkcji
`print_enemy_info` pod definicjÄ™ struktury, za pomocÄ… wczeÅ›niejszej *deklaracji* (ang. forward declaration).
O tym wspomnimy pÃ³Åºniej w kursie.
:::

### Modyfikowanie wewnÄ…trz definicji struktury

Zmiennych **nie moÅ¼na** modyfikowaÄ‡ wewnÄ…trz definicji struktury.
MoÅ¼liwe jest tylko przypisanie wartoÅ›ci poczÄ…tkowej:

```cpp title="ğŸ”´ PrÃ³ba modyfikacji pola w niewÅ‚aÅ›ciwym miejscu"
struct Enemy
{
	std::string name;
	float health;
	float strength;

	int total_damage = 0; // OK âœ…

	// âŒ BÅ‚Ä…d: PrÃ³ba modyfikacji pola w niewÅ‚aÅ›ciwym miejscu
	// error-next-line
	health = 250;
};
```

### Niezainicjalizowane skÅ‚adowe

Upewnij siÄ™, Å¼e wszystkie dane obiektu sÄ… zainicjalizowane przed uÅ¼yciem.
Podobnie jak w przypadku zwykÅ‚ych zmiennych, niezainicjalizowane pola posiadajÄ… wartoÅ›Ä‡, ktÃ³rej
nie moÅ¼emy przewidzieÄ‡, co moÅ¼e prowadziÄ‡ do nieoczekiwanych zachowaÅ„ programu.
PamiÄ™taj, Å¼e taki program mimo naruszenia zasad jÄ™zyka C++ **przejdzie** etap kompilacji.
Kompilatory i inne narzÄ™dzia czÄ™sto ostrzegajÄ… przed takimi sytuacjami.

```cpp title="Niezainicjalizowane pola"
struct Enemy
{
  // ...
  // highlight-next-line
  float health; // âš ï¸ Brak wartoÅ›ci poczÄ…tkowej
};

int main()
{
  Enemy boss;
  // âŒ UÅ¼ycie niezainicjalizowanego pola
  // error-next-line
  std::cout << "Boss ma " << boss.health << " pkt zycia.\n";
}
```
