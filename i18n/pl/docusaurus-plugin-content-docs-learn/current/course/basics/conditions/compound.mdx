---
sidebar_position:	4
sidebar_label:		"2. Compound conditions"
title:				"Compound Conditions"
description:		"Lesson: compound conditions in C++"
tags:				[condition, if, else, else-if, compound, bool, boolean]
hide_title:			true
---

<!-- Components -->
import Tabs			from "@theme/Tabs";
import TabItem		from "@theme/TabItem";

<!-- Presets -->
import NotFinished	from "@site/i18n/en/presets/NotFinished.mdx";


# Å»Å‚oÅ¼one warunki

Do tej pory wiedzieliÅ›my, jak reprezentowaÄ‡ seriÄ™ potencjalnych przypadkÃ³w w naszym kodzie C++ za pomocÄ… bloku `if`.
DowiedzieliÅ›my siÄ™ rÃ³wnieÅ¼, jak moÅ¼emy napisaÄ‡ dwa wzajemnie wykluczajÄ…ce siÄ™ przypadki, wykorzystujÄ…c konstrukcjÄ™ `if/else`.
NastÄ™pnie zobaczyliÅ›my, jak Å‚Ä…czyÄ‡ ze sobÄ… wyraÅ¼enia boolean za pomocÄ… operatorÃ³w logicznych.

Dalej, bardzo czÄ™sto programiÅ›ci majÄ… do czynienia z trzema lub wiÄ™cej wzajemnie wykluczajÄ…cymi siÄ™ przypadkami.
MoÅ¼emy skutecznie radziÄ‡ sobie z takÄ… sytuacjÄ… dziÄ™ki nowej koncepcji: instrukcji `if/else`.

## ZÅ‚oÅ¼ona instrukcja warunkowa

```cpp title="ğŸ”¹ Anatomia instrukcji if/else if/else"
if (/* warunek logiczny */)
{
	// Kod w Å›rodku wykonuje siÄ™ tylko wtedy, gdy warunek jest prawdziwy
}
else if (/* boolean condition */)
{
	// Kod w Å›rodku wykonuje siÄ™ tylko wtedy, kiedy poprzedni warunkek byÅ‚ faÅ‚szywy
	// i obecny warunek jest faÅ‚szywy
}
else
{
	// Kod w Å›rodku wykonuje siÄ™ tylko wtedy, kiedy wszystkie poprzednie warunki byÅ‚y
	// faÅ‚szywe
}
```

Instrukcja `if/else if/else` moÅ¼e reprezentowaÄ‡ wiele wykluczajÄ…cych siÄ™Â warunkÃ³w.
Warunki sÄ… wykonywane od gÃ³ry do doÅ‚u i jeÅ›li ktÃ³rykolwiek z nich ewaluuje siÄ™ do prawdy,
kod w Å›rodku zostanie wykonany, a egzekucja programu bÄ™dzie kontynuowana poza caÅ‚Ä… instrukcjÄ….
JeÅ›li Å¼aden z warunkÃ³w nie bÄ™dzie prawdziwy, wejdziemy do bloku `else`.
Dlatego wiÄ™c, wszystkie przypadki sÄ… **wzajemnie wykluczajÄ…ce siÄ™**.

Blok `else` jest opcjonalny, a blokÃ³w `else if` moÅ¼e byÄ‡ dowolna iloÅ›Ä‡.
MoÅ¼esz nawet zauwaÅ¼yÄ‡, Å¼e `if/else` omÃ³wiony wczeÅ›niej to przypadek, kiedy
nie mamy Å¼adnych blokÃ³w `else if`.

MoÅ¼emy wiÄ™c teraz zauwaÅ¼yÄ‡ jak `if`, `if/else` oraz `if/else if/else` to jeden wielki
system, ktÃ³ry nazywamy **instrukcjÄ… warunkowÄ…**.


Instrukcja warunkowa zawsze zaczyna siÄ™ blokiem `if`, po ktÃ³rym opcjonalnie jest
dowolna iloÅ›Ä‡ blokÃ³w `else if`, po ktÃ³rym opcjonalnie moÅ¼e byÄ‡ jeden blok `else`.


PowinieneÅ› dodawaÄ‡ osobne przypadki do dodatkowych blokÃ³w `else if/else`, tylko,
jeÅ›li sÄ… one wzajemnie wykluczajÄ…ce siÄ™. JeÅ›li masz kilka warunkÃ³w, ktÃ³re sÄ… od
siebie niezaleÅ¼ne, powinieneÅ› zapisaÄ‡ je w osobnych instrukcjach `if`.

UÅ¼yjmy tego czego nauczyliÅ›my siÄ™ do tej pory, aby ulepszyÄ‡ nasz poprzedni program.

### Ulepszenie sprawdzaczki

ZostaÅ‚ wprowadzony nowy system wydawania prawa jazdy. Kierowcy dostanÄ… inna klasÄ™
prawa jazdy zaleÅ¼nie od ich wieku, wedÅ‚ug nastÄ™pujÄ…cych zasad:

- Kierowcy w wieku od `18` od `21` dostanÄ… prawo jazdy klasy C
- Kierowcy w wieku od `22` od `30` dostanÄ… prawo jazdy klasy B
- Kierowcy w wieku od `31` od `50` dostanÄ… prawo jazdy klasy A
- Kierowcy w wieku od `51` od `64` dostanÄ… prawo jazdy klasy C
- Kierowcy poza tymi zakresami nie mogÄ… dostaÄ‡ prawa jazdy

```cpp title="ğŸ”¹ Sprawdzacz Prawo Jazdy 4000"
#include <iostream>

int main() {
	std::cout << "Welcome to the Driver's License Oracle 4000\n";

	int yearOfBirth;
	std::cout << "Please enter your year of birth: ";
	std::cin >> yearOfBirth;

	// W momencie pisania tej lekcji mamy 2022 rok
	int age = 2022 - yearOfBirth;

	// highlight-start
	if ((age >= 18 and age <= 21) or (age >= 51 and age <= 64)) {
		std::cout << "You can legally get a Class C driver's license\n";
	} else if (age >= 22 and age <= 30) {
		std::cout << "You can legally get a Class B driver's license\n";
	} else if (age >= 31 and age <= 50) {
		std::cout << "You can legally get a Class A driver's license\n";
	} else {
		std::cout << "You cannot legally get a driver's license because you are not between 18 and 64 years old\n";
	}
	// highlight-end
}
```

Analiza nowego kodu powinna byÄ‡, mam nadziejÄ™, w miarÄ™ prosta. Dla pierwszego przypadku, dla klasy C,
musimy obsÅ‚uÅ¼yÄ‡ dwa warunki: uÅ¼ytkownik ma byÄ‡ pomiÄ™dzy 18 a 21 **LUB** 51 a 64 lat.
UÅ¼ywamy wiÄ™c [zÅ‚oÅ¼onego warunku](#zlozone-warunki) by zaprezentowaÄ‡ tÄ™ logikÄ™ poprze poÅ‚Ä…czenie dwÃ³ch operatorÃ³w
`and` oraz jednego `or`. W ten sposÃ³b sprawdzamy oba zakresy w jednym czasie.

MÃ³glibyÅ›my teÅ¼ obsÅ‚uÅ¼yÄ‡ przypadek dla klasy C bez uÅ¼ycia operatora `or`, dodajÄ…c kolejne wyraÅ¼enie z `and`
w dodatkowym `else if`. Jednak z uwagi na to, Å¼e oba bloki wykonywaÅ‚yby ten sam, lepiej poÅ‚Ä…czyÄ‡ je w jedno wyraÅ¼enie,
aby ograniczyÄ‡ powtarzanie pisania tego samego kodu.

Ta generalna praktyka, ktÃ³ra mÃ³wi o tym, aby nie powtarzaÄ‡ pisania tego samego kodu nazywaÂ siÄ™ **DRY**
(**D**on't **R**epeat **Y**ourself - ang.: *Nie Potwarzaj SiÄ™*), jest to bardzo przydatna zasada, ktÃ³rej
warto przestrzegaÄ‡, nie tylko przy pisaniu kodu.

WracajÄ…c do poprzedniego tematu, pozostaÅ‚e przypadki sÄ… obsÅ‚uÅ¼one za pomocÄ… `else if`.
KaÅ¼dy przypadek jest obsÅ‚uÅ¼ony dwoma wyraÅ¼eniami logicznymi poÅ‚Ä…czonymi operatorem logicznym `and`, definiujemy w ten sposÃ³b
*dolnÄ…* i *gÃ³rnÄ…* granicÄ™ dla kaÅ¼dego przypadku.
Na koniec uÅ¼ywamy bloku `else`, Å¼eby zÅ‚apaÄ‡ kaÅ¼dy pozostaÅ‚y przypadek.

### UÅ¼ywanie zmiennych, aby ograniczyÄ‡ powtarzanie kodu

MoÅ¼e siÄ™ wydawaÄ‡ dziwne, Å¼e po caÅ‚ej tej gadce o nie powtarzaniu siÄ™, mamy prawie tÄ™ samÄ… liniÄ™ kodu powtÃ³rzonÄ… trzy razy.
ZauwaÅ¼, Å¼e `std::cout << "..."` jest niemal identyczny dla wszystkich prawo jazdy klasy A, B i C - tylko jedna litera jest inna.
w kaÅ¼dym z tych przypadkÃ³w. MoÅ¼emy to wykorzystaÄ‡ na naszÄ… korzyÅ›Ä‡ tworzÄ…c *zmiennÄ…*, ktÃ³ra przechowuje pojedynczy znak.
NastÄ™pnie zmieniamy nasze instrukcje if, aby przypisaÄ‡ tej zmiennej odpowiedniÄ… klasÄ™ prawa jazdy. Na koniec wypisujemy
ostatecznÄ… wiadomoÅ›Ä‡ poÅ‚Ä…czonÄ… z utworzonÄ… przez nas zmiennÄ….

```cpp title="âš ï¸ Sprawdzacz Prawo Jazdy 4500"
#include <iostream>

int main() {
	std::cout << "Welcome to the Driver's License Oracle 4500\n";

	int yearOfBirth;
	std::cout << "Please enter your year of birth: ";
	std::cin >> yearOfBirth;


	// W momencie pisania tej lekcji mamy 2022 rok
	int age = 2022 - yearOfBirth;

	// highlight-next-line
	char licenseClass = 'X'; // X jest wybranÄ… wartoÅ›ciÄ… reprezentujÄ…cÄ…, Å¼e uÅ¼ytkownik nie dostaÅ‚ prawa jazdy

	if ((age >= 18 and age <= 21) or (age >= 51 and age <= 64)) {
		licenseClass = 'C';
	} else if (age >= 22 and age <= 30) {
		licenseClass = 'B';
	} else if (age >= 31 and age <= 50) {
		licenseClass = 'A';
	} else {
		std::cout << "You cannot legally get a driver's license because you are not between 18 and 64 years old\n";
	}

	// warning-next-line
	std::cout << "You can legally get a Class " << licenseClass << " driver's license\n";
}
```

Kod powyÅ¼ej robi dokÅ‚adnie to co opisaliÅ›my. StworzyliÅ›my zmiennÄ… typu `char`, ktÃ³ra przechowuje klasÄ™ prawa jazdy,
a wewnÄ…trz Å›cieÅ¼ek if-a przypisaliÅ›my do niej odpowiedniÄ… klasÄ™.
Jednak kod ten nie zadziaÅ‚a tak jak chcemy!
SpÃ³jrzmy z powrotem na [anatomiÄ™ instrukcji if](/learn/course/basics/conditions/intro/#instrukcja-warunkowa),
pod instrukcjÄ… zapisany jest komentarz
"Kod poza wykonywany jest niezaleÅ¼nie od tego, czy warunek jest prawdziwy czy faÅ‚szywy".

WiÄ™c kod ten zadziaÅ‚a poprawnie, jeÅ›li uÅ¼ytkownik bÄ™dzie mÃ³gÅ‚ legalnie dostaÄ‡ prawo jazdy.
WprowadzajÄ…c np. `2000` program wypisze `You can legally get a Class C driver's license`, tak, jak chcieliÅ›my.
Jednak, wprowadzajÄ…c np. `2015`, dostaniemy:

```
You cannot legally get a driver's license because you are not between 18 and 64 years old
You can legally get a Class X driver's license
```

... co jest bÅ‚Ä™dne! Program wypisuje oba pr zypadki *poniewaÅ¼* przneieÅ›liÅ›my poprawne wyjÅ›cie poza instrukcjÄ™Â if.
To co musimy zrobiÄ‡, to stworzyÄ‡ kolejnÄ… instrukcjÄ™ if, ktÃ³ra sprawdzi czy daliÅ›my uÅ¼ytkownikowi waÅ¼ne prawo jazdy czy nie.
MoÅ¼emy to Å‚atwo zrobiÄ‡, dziÄ™ki temu, Å¼e ustawiliÅ›my `'X'` jako domyÅ›lnÄ… wartoÅ›Ä‡ `licenseClass`. Oznacza to, Å¼e kaÅ¼dy kto
nie otrzymaÅ‚ prawa jazdy, nadal bÄ™dzie miaÅ‚ `'X'` jako wartoÅ›Ä‡ `licenseClass`, a my moÅ¼emy to sprawdziÄ‡ za pomocÄ… warunku.

```cpp title="ğŸ”¹ Sprawdzacz Prawo Jazdy 4500"
#include <iostream>

int main() {
	std::cout << "Welcome to the Driver's License Oracle 4500\n";

	int yearOfBirth;
	std::cout << "Please enter your year of birth: ";
	std::cin >> yearOfBirth;

	// W momencie pisania tej lekcji mamy 2022 rok
	int age = 2022 - yearOfBirth;

	char licenseClass = 'X'; // X jest wybranÄ… wartoÅ›ciÄ… reprezentujÄ…cÄ…, Å¼e uÅ¼ytkownik nie dostaÅ‚ prawa jazdy

	if ((age >= 18 and age <= 21) or (age >= 51 and age <= 64)) {
		licenseClass = 'C';
	} else if (age >= 22 and age <= 30) {
		licenseClass = 'B';
	} else if (age >= 31 and age <= 50) {
		licenseClass = 'A';
	// highlight-next-line
	} // UsunÄ™liÅ›my blok else, aby obsÅ‚uÅ¼yÄ‡ ten przypadek dalej w ifie

	// highlight-start
	if (licenseClass != 'X') {
		std::cout << "You can legally get a Class " << licenseClass << " driver's license\n";
	} else {
		std::cout << "You cannot legally get a driver's license because you are not between 18 and 64 years old\n";
	}
	// highlight-end
}
```

StworzyliÅ›my tutaj nowÄ… instrukcjÄ™Â if, ktÃ³ra sprawdza czy `licenseClass != 'X'`.
Sprawdzamy w niej, czy wydaliÅ›my uÅ¼ytkownik prawo jazdy, czy nie;
w zaleÅ¼noÅ›ci od wyniku wypisujemy odpowiedniÄ… wiadomoÅ›Ä‡.
W ten sposÃ³b na nowo sprawiliÅ›my, Å¼e te dwa warunki siÄ™ wzajemnei wykluczajÄ…

ZauwaÅ¼, Å¼e uÅ¼ywajÄ…Ä‡ zmiennych i aplikujÄ…Ä‡ zasadÄ™ DRY,
zmniejszyliÅ›my iloÅ›Ä‡ powtÃ³rzeÅ„ w naszym kodzie.
SprawiÅ‚o to, Å¼e kod ten jest bardziej czytelne, prostszy w utrzymaniu i prostszy w debugowaniu.

### ZagnieÅ¼dÅ¼anie instrukcji warunkowych

WnÄ™trze blokÃ³w `if/else if/else` nie jest w Å¼aden sposÃ³b specjalne. MoÅ¼na do niego wpisaÄ‡ jakikolwiek poprawny kod,
tak samo jak do bloku `main`. Oznacza to, Å¼e moÅ¼emy "zagnieÅ¼dÅ¼aÄ‡" w sobie instrukcje warunkowe, poprzez wpisanie
jednej w drugÄ….

```cpp title="ğŸ”¹ PrzykÅ‚ad zagnieÅ¼dÅ¼onej instrukcji if"
if (/* Warunek 1 */) {
	// Kod tutaj wykona siÄ™, jeÅ›li Warunek 1 jest prawdziwy

	// Z uwagi na to, Å¼e ta instrukcja if znajduje siÄ™Â w innej instrukcji if
	// zostaje wykonana tylko, jeÅ›li wejdziemy do ciaÅ‚a zewnÄ™trznego ifa,
	// czyli tylko, jeÅ›li Warunek 1 jest prawdziwy
	// highlight-start
	if (/* Warunek 2 */) {
		// Kod tutaj wykona siÄ™Â tylko, jeÅ›li Warunek 2 jest prawdziwy
	} else if (/* Warunek 3 */) {
		// Kod tutaj zostaje wykonany tylko jeÅ›li Warunek 2 jest faÅ‚szywy, a Warunek 3 prawdziwy
	}
	// highlight-end

	// Kod tutaj wykona siÄ™ niezaleÅ¼nie od wyniku Warunku 1 i Warunku 2,
	// jednak pamiÄ™taj, Å¼e dalej jesteÅ›my wewnÄ…trz ifa z Warunek 1
} else {
	// Kod tutaj wykona siÄ™ tylko, jeÅ›li Warunek 1 prawdziwy
}

// Kod tutaj zostanie wykonany niezaleznie od Å¼adnego ifa wyÅ¼ej
```

MoÅ¼emy tutaj zobaczyÄ‡ przykÅ‚ad zagnieÅ¼dÅ¼onej instrukcji if.
Mamy tutaj jednÄ… instrukcjÄ™ if/else z instrukcjÄ… if/else if wewnÄ…trz.

Kiedy program ten siÄ™ wykona, pierwszym krokiem jest sprawdzenie wyniku Warunku 1.
JeÅ›li wynik jest prawdziwy, wejdziemy do ciaÅ‚a tego ifa i wykonamy kod w Å›rodku.
W przeciwnym wypadku, kiedy Warunek 1 jest faÅ‚szywy, wskoczymy do bloku else i wykonamy kod z niego.
Kiedy caÅ‚y ten proces siÄ™ zakoÅ„czy, wyjdziemy caÅ‚kowicie z instrukcji if i bÄ™dziemy kontynuowaÄ‡
wykonanie dalej.

ZauwaÅ¼my tutaj, Å¼e w przypadku, gdy Warunek 1 jest prawdziwy, czÄ™Å›Ä‡ jego ciaÅ‚a zawiera *kolejnÄ… instrukcjÄ™ if*.
Oznacza to wiÄ™c, Å¼e ponownie podejmie logicznÄ… decyzjÄ™. Tak wiÄ™c, jeÅ›li Warunek 1 jest prawdziwy, wykonanie
programu bÄ™dzie kontynuowane w bloku tego ifa, aÅ¼ dojdziemy do zagnieÅ¼dÅ¼onej instrukcji if.
NastÄ™pnie program sprawdzi Warunek 2. Dla prawdy, wykona kod wewnÄ…trz zagnieÅ¼dÅ¼onego ifa,
dla nieprawdy sprawdzamy Warunek 3 - i ponownie, jeÅ›li bÄ™dzie on prawdziwy, wykonamy kod wewnÄ…trz.

Take note of how similar these processes are overall. Nothing really changed when analyzing the behavior
of the outer if statement versus the inner if statement. If statements are extremely *modular* in this way â€”
their behavior is the same in any context... at the beginning of `main`, at the end of `main`, inside
another if statement, inside two if statements, inside an else body, etc.

ZwrÃ³Ä‡ uwagÄ™ na to, jak podobne sÄ… te procesy. Nic tak naprawdÄ™ nie zmieniÅ‚o siÄ™ podczas analizy zachowania
zewnÄ™trznej instrukcji if w porÃ³wnaniu z wewnÄ™trznÄ… instrukcjÄ… if. Instrukcje if sÄ… niezwykle *modularne* -
w ten sposÃ³b ich zachowanie jest takie samo w kaÅ¼dym kontekÅ›cie... na poczÄ…tku `main`, na koÅ„cu `main`, wewnÄ…trz
innej instrukcji if, wewnÄ…trz dwÃ³ch instrukcji if, wewnÄ…trz ciaÅ‚a else, itd.

Wykorzystajmy tÄ™ wiedzÄ™, aby jeszcze bardziej ulepszyÄ‡ nasz program:

Rada Nadzorcza BezpieczeÅ„stwa Transportu wydaÅ‚a nowy wymÃ³g:
osoby z dwoma lub wiÄ™cej wypadkami nie kwalifikujÄ… siÄ™ na prawo jazdy Å¼adnej klasy bez wzglÄ™du na wiek.

```cpp title="ğŸ”¹ Sprawdzacz Prawo Jazdy 5000"
#include <iostream>

int main() {
	std::cout << "Welcome to the Driver's License Oracle 5000\n";

	int yearOfBirth;
	std::cout << "Please enter your year of birth: ";
	std::cin >> yearOfBirth;

	int numCrashes;
	std::cout << "Please enter the number of crashes you have had: \n";
	std::cin >> numCrashes;

	// highlight-next-line
	if (numCrashes < 2) {
		// W momencie pisania tej lekcji mamy 2022 rok
		int age = 2022 - yearOfBirth;

		char licenseClass = 'X'; // X jest wybranÄ… wartoÅ›ciÄ… reprezentujÄ…cÄ…, Å¼e uÅ¼ytkownik nie dostaÅ‚ prawa jazdy

		if ((age >= 18 and age <= 21) or (age >= 51 and age <= 64)) {
			licenseClass = 'C';
		} else if (age >= 22 and age <= 30) {
			licenseClass = 'B';
		} else if (age >= 31 and age <= 50) {
			licenseClass = 'A';
		}

		if (licenseClass != 'X') {
			std::cout << "You can legally get a Class " << licenseClass << " driver's license\n";
		} else {
			std::cout << "You cannot legally get a driver's license because you are not between 18 and 64 years old\n";
		}
	// highlight-start
	} else {
		std::cout << "You cannot legally get a driver's license because you have " << numCrashes << " accidents\n";
	}
	// highlight-end
}
```

WidaÄ‡ tutaj jak przenieÅ›liÅ›my duÅ¼y kawaÅ‚ek poprzedniego kodu do ciaÅ‚a instrukcji if z warunkiem `numsCrashes`.
Oznacza to, Å¼e wykonamy ten kod tylko wtedy i tylko wtedy, gdy uÅ¼ytkownik braÅ‚ udziaÅ‚ w mniej mniej niÅ¼ dwÃ³ch wypadkach.
W przeciwnym razie, jeÅ›li uÅ¼ytkownik braÅ‚ udziaÅ‚ w dwÃ³ch lub wiÄ™cej wypadkach, system wypisuje powiadomienie,
Å¼e nie uÅ¼ytkownik moÅ¼e otrzymaÄ‡ prawa jazdy.

Teraz zauwaÅ¼ ponownie, Å¼e powtarzamy ten sam komunikat dwa razy w naszym kodzie. Oznacza to, Å¼e istnieje kolejna okazja
aby zastosowaÄ‡ zasadÄ™ DRY i uproÅ›ciÄ‡ nasz kod na potrzeby przyszÅ‚ej konserwacji. Przyjrzyjmy siÄ™ temu:

#### Ponownie zastosowanie zasady DRY

```cpp title="ğŸ”¹ Sprawdzacz Prawo Jazdy 5500"
#include <iostream>

int main() {
	std::cout << "Welcome to the Driver's License Oracle 5500\n";

	int yearOfBirth;
	std::cout << "Please enter your year of birth: ";
	std::cin >> yearOfBirth;

	int numCrashes;
	std::cout << "Please enter the number of crashes you have had: \n";
	std::cin >> numCrashes;

	char licenseClass = 'X'; // X jest wybranÄ… wartoÅ›ciÄ… reprezentujÄ…cÄ…, Å¼e uÅ¼ytkownik nie dostaÅ‚ prawa jazdy
	// highlight-next-line
	std::string illegalReason;

	if (numCrashes < 2) {
		// W momencie pisania tej lekcji mamy 2022 rok
		int age = 2022 - yearOfBirth;

		if ((age >= 18 and age <= 21) or (age >= 51 and age <= 64)) {
			licenseClass = 'C';
		} else if (age >= 22 and age <= 30) {
			licenseClass = 'B';
		} else if (age >= 31 and age <= 50) {
			licenseClass = 'A';
		} else {
			// highlight-next-line
			illegalReason = "you are not between 18 and 64 years old";
		}
	} else {
		// highlight-next-line
		illegalReason = "you have " + std::to_string(numCrashes) + " accidents";
	}

	if (licenseClass != 'X') {
		std::cout << "You can legally get a Class " << licenseClass << " driver's license\n";
	} else {
		// highlight-next-line
		std::cout << "You cannot legally get a driver's license because " << illegalReason << "\n";
	}
}
```

MoÅ¼emy zauwaÅ¼yÄ‡, Å¼e kod zostaÅ‚ ulepszony na kilka sposobÃ³w. Po pierwsze, nie powtarzamy siÄ™
juÅ¼, co oznacza, Å¼e przyszÅ‚e utrzymanie jest znacznie Å‚atwiejsze w przypadku, gdy Rada Nadzorcza zdecyduje siÄ™
dodaÄ‡ wiÄ™cej regulacji.

Po drugie, rozseparowaliÅ›my kod odpowiedzialny za logikÄ™ oraz za wyÅ›wietlanie.
JeÅ›li przeplatasz wyÅ›wietlanie z logikÄ… programu (obliczenia, etc.),
moÅ¼e to sprawiÄ‡, Å¼e kod stanie siÄ™ bardzo szybko zagmatwany.
W naszym programie caÅ‚a logika do okreÅ›lania `licenseClass` oraz `illegalReason` znajduje siÄ™Â w jednym ifie,
a kdo odpowiedzialny za wyÅ›wietlanie wyniku do uÅ¼ytkownika w innym.
