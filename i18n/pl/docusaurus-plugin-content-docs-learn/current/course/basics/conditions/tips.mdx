---
title:				"Warunki Â» WskazÃ³wki i styl"
description:		"Lekcja: wskazÃ³wki i styl dotyczÄ…ce warunkÃ³w w C++"
tags:				[condition, if, else, else-if, compound, bool, boolean, tips, style]
hide_title:			true
---

import Columns			from '@site-comps/Columns';

import Tabs				from '@theme/Tabs';
import TabItem			from '@theme/TabItem';


# Warunki Â» WskazÃ³wki i styl

Ten artykuÅ‚ jest zbiorem porad i wskazÃ³wek, ktÃ³re pomogÄ… Ci poprawiÄ‡
sposÃ³b w jak piszesz swÃ³j kod warunkowy. JeÅ›li Å›ledziÅ‚eÅ› nasz kurs w kolejnoÅ›ci,
wiele z uÅ¼ywanych tu koncepcji nie zostaÅ‚o jeszcze omÃ³wionych. Nie przejmuj siÄ™, jeÅ›li
nie rozumiesz niektÃ³rych rzeczy w tym artykule, pojawiÄ… siÄ™ one w pÃ³Åºniejszych lekcjach.

## Zawsze dodawaj nawiasy klamrowe

Wiele konstrukcji C++, na ktÃ³re moÅ¼esz siÄ™ natknÄ…Ä‡, ma **opcjonalne nawiasy klamrowe**.
JeÅ›li pominiesz nawiasy klamrowe, to zakÅ‚ada siÄ™, Å¼e nastÄ™pna linia kodu znajduje siÄ™ w
ciele instrukcji if, a wszystko inne po niej jest poza instrukcjÄ… if.

Czasem pozwala to pisaÄ‡ prostszy i troszkÄ™Â czytelniejszy kod. Dla przykÅ‚adu:

```cpp title="Omijanie nawiasÃ³w klamrowych"
if (A and B)
    std::cout << "They're both true!\n";

std::cout << "Goodbye!";
```

Jest to jednak bardzo czÄ™sta puÅ‚apka dla poczÄ…tkujÄ…cych, poniewaÅ¼ pisanie kodu w taki sposÃ³b
moÅ¼e szybko doprowadziÄ‡ do niewÅ‚aÅ›ciwego zachowania.
SzczegÃ³lnie podczas edycji kodu, czÄ™sto zdarza siÄ™, Å¼e przypadkowo zapomnimy dodaÄ‡ nawiasÃ³w klamrowych
podczas rozszerzania kodu w ciele instrukcji if
PamiÄ™taj, Å¼e C++a nie interesujÄ…Â znaki biaÅ‚e i wciÄ™cia,
wiÄ™c jeÅ›li sprÃ³bujesz zrobiÄ‡:

```cpp title="âš ï¸ WprowadzajÄ…ce w bÅ‚Ä…d wciÄ™cia"
if (A and B)
    std::cout << "They're both true!\n";
    // warning-next-line
    std::cout << "That's cool that they are both true.\n";

std::cout << "Goodbye!";
```

PodÅ›wietlona linia bÄ™dzie **zawsze wykonywana**, poniewaÅ¼ nie jest czÄ™Å›ciÄ… instrukcji if.
Jest to rÃ³wnowaÅ¼ne umieszczeniu nawiasÃ³w klamrowych tylko za liniÄ…, ktÃ³ra bezpoÅ›rednio nastÄ™puje po
instrukcjÄ… if. Ze wzglÄ™du na czÄ™stotliwoÅ›Ä‡, z jakÄ… poczÄ…tkujÄ…cy programiÅ›ci zostajÄ… ugryzieni przez ten bÅ‚Ä…d,
zaleca siÄ™, aby zawsze umieszczaÄ‡ nawiasy klamrowe na instrukcjach if.
BÅ‚Ä™dy takie jak ten spowodowaÅ‚y nawet [powaÅ¼ne luki bezpieczeÅ„stwa w
duÅ¼ych progamach](https://nakedsecurity.sophos.com/2014/02/24/anatomy-of-a-goto-fail-apples-ssl-bug-explained-plus-an-unofficial-patch/).

## Zachowaj spÃ³jnoÅ›Ä‡ stylu nawiasÃ³w

SpÄ™dzanie jakÄ…kolwiek iloÅ›Ä‡ czasu w spoÅ‚ecznoÅ›ciach programistÃ³w
prawdopodobnie wystawi CiÄ™ na dÅ‚ugotrwaÅ‚Ä… walkÄ™ pomiÄ™dzy nawiasami klamrowymi "inline" (ang.: *w jednej linii*),
rÃ³wnieÅ¼ okreÅ›lanymi jako nawiasami w stylu **K&R**, a "new-line" (ang.: *w nowej linii*),
rÃ³wnieÅ¼ okreÅ›lanymi jako nawiasami w stylu **Allman**.

Jest to debata, ktÃ³ra skupia siÄ™ na bardzo kosmetycznej decyzji, czy powinieneÅ› umieÅ›ciÄ‡ otwierajÄ…ce
nawiasy klamrowe `{` w tej samej linii co instrukcje if, funkcje, pÄ™tle, itp. lub czy powinny byÄ‡
w nowej linii. Oba style i ich plusy/minusy sÄ… zilustrowane poniÅ¼ej:

<Tabs>
<TabItem value="inline" label="ğŸ”· Nawiasy w tej samej linii (K&R)" default>

```cpp
int main() {

    int x = 10;

    if (x == 10) {
        std::cout << "X is 10!";
    } else {
        std::cout << "X is not 10!";
    }




    for (int i = 0; i < 5; i++) {
        std::cout << "i: " << i << "\n";
    }
}

```

<Columns columns={["1fr", "1fr"]}>
<div>

#### Plusy
- Kod jest bardziej kompaktowy
- Organizacja poprzez dodawanie pustych linii jest prostsza

</div>
<div>

#### Minusy
- Nawiasy otwierajÄ…cy i zamykajÄ…cy nie sÄ… w tej samej kolumnie
- Dla niektÃ³rych ludzi styl ten jest zbyt "gÅ‚oÅ›ny", "spakowany"
- MoÅ¼e szybko staÄ‡ siÄ™ mniej czytelny przez niektÃ³re style formatowania

</div>
</Columns>

ZauwaÅ¼, Å¼e w tym przykÅ‚adzie umieszczono dodatkowe puste linie, aby byÅ‚ on zgodny z nastÄ™pnym przykÅ‚adem.
Te dodatkowe linie nie sÄ… istotne dla porÃ³wnania stylÃ³w nawiasÃ³w.

</TabItem>
<TabItem value="newline" label="ğŸ”¶ Nawiasy w nowych liniach (Allman)" default>

```cpp
int main()
{
    int x = 10;

    if (x == 10)
    {
        std::cout << "X is 10!";
    }
    else
    {
        std::cout << "X is not 10!";
    }

    for (int i = 0; i < 5; i++)
    {
        std::cout << "i: " << i << "\n";
    }
}
```

<Columns columns={["1fr", "1fr"]}>
<div>

#### Plusy
- Nawiasy otwierajÄ…cy i zamykajÄ…cy sÄ… w tej samej kolumnie
- Czytelniejsze dla niektÃ³rych
- Bardziej konsekwentne formatowanie przez niektÃ³re style

</div>
<div>

#### Minusy
- ZnaczÄ…co oddala od siebie kod
- Marnuje przestrzeÅ„ pionowÄ…

</div>
</Columns>
</TabItem>
</Tabs>

Ostatecznie to od Ciebie zaleÅ¼y, jakiego stylu bÄ™dziesz siÄ™Â trzymaÄ‡.
PopularnoÅ›Ä‡ obu stylÃ³w jest mniej wiÄ™cej rÃ³wna.
PowinieneÅ› tylko pamiÄ™taÄ‡, Å¼eby trzymaÄ‡ siÄ™ jednego stylu na projekt.
**Nie naleÅ¼y mieszaÄ‡ stylÃ³w w obrÄ™bie tego samego kodu.**

Nie przywiÄ…zuj siÄ™ jednak zbytnio do jednego stylu. Gdy znajdziesz profesjonalnÄ…
pracÄ™ zwiÄ…zanÄ… z programowaniem, oczekuje siÄ™, Å¼e bÄ™dziesz trzymaÅ‚ siÄ™ stylu, ktÃ³ry juÅ¼
istnieje w danej firmie.
SpÃ³jny kod jest waÅ¼niejszy niÅ¼ Twoje osobiste preferencje!

## Zachowaj spÃ³jnoÅ›Ä‡ wciÄ™Ä‡

JednÄ… z najczÄ™stszych bolÄ…czek zaawansowanych programistÃ³w pomagajÄ…cych poczÄ…tkujÄ…cym jest to, Å¼e
ich kod jest super niechlujny! To sprawia, Å¼e trudno go czytaÄ‡, a jeszcze trudniej, jeÅ›li
prÃ³buje siÄ™ im w znalezieniu bÅ‚Ä™dÃ³w. Jednym z najlepszych sposobÃ³w, aby uczyniÄ‡ swÃ³j kod czystszym
i Å‚atwiejszy do zrozumienia jest utrzymanie spÃ³jnych wciÄ™Ä‡. Na szczÄ™Å›cie jest to bardzo proste.

Za kaÅ¼dym razem, gdy wchodzisz w *scope* (ang.: *zakres*),
powinieneÅ› dodaÄ‡ wciÄ™cie w kodzie o jeden poziom wiÄ™cej za pomocÄ… klawisza tabulacji.
Za kaÅ¼dym razem, gdy opuszczasz zakres, powinieneÅ› usunÄ…Ä‡ wciÄ™cie o jeden poziom.
Zakres jest w zasadzie jednym "blokiem" jÄ™zyka C++.
WewnÄ…trz funkcji jest pojedynczy zakres, wewnÄ…trz instrukcji if jest pojedynczy zakres,
wewnÄ…trz pÄ™tli for jest pojedynczy zakres pÄ™tli for jest pojedynczym zakresem, itd.
PoniÅ¼ej znajdujÄ… siÄ™ przykÅ‚ady jak wyglÄ…dajÄ… dobre i zÅ‚e wciÄ™cia.

:::note Indentacje
Zapewne bardzo czÄ™sto bÄ™dziesz spotykaÄ‡ siÄ™ ze sÅ‚owem "indentacje", zamiast wciÄ™cia.
Oba sÅ‚owa znaczÄ… to samo; "indentacja" to spolszczenie angielskiego sÅ‚owa *indentation*.
:::

<Tabs>
<TabItem value="good" label="âœ”ï¸ Dobre wciÄ™cia" default>

```cpp
// CzÄ™sci funkcji sÄ… zawsze bez wciÄ™Ä‡,
// jednak to co znajduje siÄ™Â w Å›rodku ma wciÄ™cia
bool checkValue(int x) {
    // CzÄ™sci instrukcji if sÄ… wciÄ™te,
    // poniewaÅ¼ sÄ… wewnÄ…trz funkcji
    if (x < 50) {
        // WewnÄ…trz instrukcji if; dodatkowe wciÄ™cie
        return true;
    } else {
        return false;
    } // Nawiasy sÄ… w tej samej kolumnie co start instrukcji if
}

int main() {
    // Wszystko wewnÄ…trz funkcji jest wciÄ™te o jeden "poziom"
    int value;
    std::cin >> value;

    // CzÄ™Å›ci pÄ™tli while sÄ… wciÄ™te o jeden pozom
    while (true) {
        // WewnÄ…trz pÄ™tli while; dodatkowe wciÄ™cie
        if (checkValue(value)) {
            // WewnÄ…trz dodatkowego zakresu; dodatkowe wciÄ™cie
            std::cout << "You have entered a good value.\n";
            break;
        }

        // Opuszczamy jeden poziom wciÄ™cia po wyjÅ›ciu z instrukcji if 
        std::cout << "You have entered a bad value.\n";
        std::cout << "Try again.\n";
    } // Nawias sÄ… w tej samej kolumnie co start pÄ™tli while

    // Wracamy do jednego poziomu wciÄ™cia, bo wyszliÅ›my juÅ¼ pÄ™tli while
    std::cout << "Goodbye!";
} // Nawias jest w tej samej kolumnie co start funkcji main
```
</TabItem>
<TabItem value="bad" label="âŒ NieprawidÅ‚owe wciÄ™cia" default>

```cpp


bool checkValue(int x) {

// Ta instrukcja if powinna zostÄ…Ä‡ wciÄ™ta o jedne poziom
if (x < 50) {
return true; // Tej linii brakuje dwÃ³ch poziomÃ³w wciÄ™cia
        } else {
                return false; // WciÄ™cie tutaj jest widocznie niespÃ³jne z resztÄ…
}} // The nawiasy powinny byÄ‡ w osobnych liniach i mieÄ‡ odpowiednie wciÄ™cia


    // Ta funkcja ma za duÅ¼y poziom wciÄ™cia
    int main() {

    int value; 
        std::cin >> value; // WciÄ™cie tutaj jest niespÃ³jne z poziomem wciÄ™Ä‡ w tym zakresie


    while (true) {
    // Tej instrukcji if brakuje poziomu wciÄ™cia
    if (checkValue(value)) {
        std::cout << "You have entered a good value.\n"; break; // Nie powinniÅ›my dawaÄ‡ dwÃ³ch instrukcji w tej samej linii
        } // Ten nawias nie jest w tej samej kolumnie co instrukcja if do ktÃ³rej naleÅ¼y



// Tym liniom brakuje wciÄ™Ä‡
std::cout << "You have entered a bad value.\n";
std::cout << "Try again.\n";
} // Ten nawias nie znajduje siÄ™ w tej samej kolumnie co pÄ™tla while do ktÃ³rej naleÅ¼y

            // WciÄ™cie tej linii jest niespÃ³jne z resztÄ… wciÄ™Ä‡ tego zakresu
            std::cout << "Goodbye!";
}
```
</TabItem>
</Tabs>

MoÅ¼emy zobaczyÄ‡, Å¼e caÅ‚y kod w pierwszym przykÅ‚adzie jest starannie wyrÃ³wnany.
PodÄ…Å¼a za spÃ³jnymi zasadami kiedy dodaÄ‡ wciÄ™cia w zaleÅ¼noÅ›ci od tego, w jak gÅ‚Ä™bokim zakresie siÄ™ znajdujemy.
KaÅ¼dy poziom zagnieÅ¼dÅ¼enia zakresu gwarantuje dodatkowy poziom wciÄ™cia.
Dodatkowo, wszystkie nasze nawiasy klamrowe sÄ… ustawione w linii z rodzicem,
ktÃ³ry "rozpoczÄ…Å‚" zakres, co sprawia, Å¼e Å‚atwo jest znaleÅºÄ‡
do jakiej konstrukcji naleÅ¼y dany nawias.

Z drugiej strony, kod w drugim przykÅ‚adzie jest znacznie bardziej zagmatwany i frustrujÄ…cy do czytania.
Bardzo trudno jest znaleÅºÄ‡, ktÃ³ry kod naleÅ¼y do jakiego zakresu, gdzie koÅ„czy siÄ™ jaki zakres i co powinno byÄ‡ wykonane kiedy.
Dodatkowo, jest to po prostu ogÃ³lnie bardzo niechlujnie napisy kod, bolÄ…cy do czytani.

Utrzymanie czystych i spÃ³jnych poziomÃ³w wciÄ™cia moÅ¼e wydawaÄ‡ siÄ™ dodatkowÄ… pracÄ…,
zwÅ‚aszcza jeÅ›li wprowadza siÄ™ zmiany do istniejÄ…cego kodu.
Ale zastosuj siÄ™ do tych wskazÃ³wek, a obiecujÄ™, Å¼e podziÄ™kujesz sobie pÃ³Åºniej.
Bardzo czÄ™sto zdarza siÄ™, Å¼e poczÄ…tkujÄ…cy mylÄ… siÄ™ przez to, Å¼e majÄ… sÅ‚abe wciÄ™cia w kodzie,
naprawa tego w samym kodzie jest najlepszym sposobem.

JeÅ›li uwaÅ¼asz, Å¼e radzenie sobie z wciÄ™ciem jest trudne, rozwaÅ¼ uÅ¼ycie skrÃ³tÃ³w klawiszowych.
W wiÄ™kszoÅ›ci edytorÃ³w kodu, moÅ¼esz dodaÄ‡ wciÄ™cia w wielu liniach jednoczeÅ›nie, zaznaczajÄ…c to co chcesz wciskaÄ‡ i naciskajÄ…c klawisz `Tab`.
I odwrotnie, moÅ¼esz usunÄ…Ä‡ wciÄ™cie z wielu linii na raz za pomocÄ… `Shift+Tab`.

Dodatkowo wiÄ™kszoÅ›Ä‡ edytor automatycznie dodaje wciÄ™cia podczas pisania kodu.

## Unikaj skomplikowancych wyraÅ¼eÅ„ logicznych

JeÅ›li prÃ³bujesz stworzyÄ‡ warunek, ktÃ³ry wymaga sprawdzenia poprawnoÅ›ci wielu wyraÅ¼eÅ„ logicznych,
moÅ¼e byÄ‡ bardzo Å‚atwo stworzyÄ‡ mylÄ…cy kod poprzez uÅ¼ycie zbyt wielu `and`, `or` i `not`.
Najlepszym sposobem, aby temu zapobiec jest stworzenie funkcji zwracajÄ…cej `bool`, ktÃ³ra obliczy to
skomplikowane wyraÅ¼enie dla ciebie. W ten sposÃ³b kod staje siÄ™ bardziej czytelny i Å‚atwiejszy do utrzymania.
Pomocne mogÄ… okazaÄ‡ siÄ™ rÃ³wnieÅ¼ metody z nastÄ™pnej sekcji.

## Unikaj zbyt duÅ¼ego zagnieÅ¼dÅ¼ania instrukcji

Bardzo Å‚atwo jest stworzyÄ‡ skomplikowanÄ… logikÄ™ za pomocÄ… instrukcji if, zwÅ‚aszcza jeÅ›li
nadmiernie zagnieÅ¼dÅ¼asz je wewnÄ…trz siebie. Dla przykÅ‚adu, sprÃ³buj dowiedzieÄ‡ siÄ™
co wÅ‚aÅ›ciwie robi poniÅ¼szy fragment:

```cpp title="âš ï¸ Zagmatwane instrukcje if"
if (A or B) {
    if (not B and C) {
        if (A or D) {
            if (A and not B) {
                std::cout << "Hello!";
            } else {
                std::cout << "Will this line ever be run?";
            }
        } else if (not D) {
            std::cout << "What about this one?";
        }
    } else {
        std::cout << "It's starting to get pretty weird now...";
    }
} else if (B) {
    std::cout << "I don't think this one will ever run.";
} else if (not A and not b) {
    std::cout << "Surely, this one will be called eventually.";
} else {
    std::cout << "Goodbye!";
}
```

Kilka minut moÅ¼e Ci zajÄ…Ä‡ zorientowanie siÄ™, w jakich przypadkach kaÅ¼de z tych coutÃ³w
wykona siÄ™, szczegÃ³lnie jeÅ›li pracujesz w duÅ¼ych i potencjalnie bardzo skomplikowanych bazach kodu.

SÄ… dwa dobre sposoby, aby to poprawiÄ‡. Po pierwsze, moÅ¼esz wydzieliÄ‡
wewnÄ™trzne warunki zagnieÅ¼dÅ¼one do osobnych [funkcji](/learn/course/basics/functions/).
W ten sposÃ³b zÅ‚oÅ¼onoÅ›Ä‡ zostaje ukryta za warstwÄ… *abstrakcji*, a ty jesteÅ›
zmuszony do stworzenia opisowej nazwy dla kaÅ¼dej tworzonej funkcji.

Druga metoda ma zastosowanie, jeÅ›li masz wyraÅºnÄ… "szczÄ™Å›liwÄ… Å›cieÅ¼kÄ™" i "smutnÄ… Å›cieÅ¼kÄ™".
MoÅ¼esz przeorganizowaÄ‡ instrukcje if tak,
aby szczÄ™Å›liwa Å›cieÅ¼ka byÅ‚a najmniej wciÄ™ta i nie podlegaÅ‚a Å¼adnej instrukcji if, a
smutna Å›cieÅ¼ka wychodziÅ‚Ä… z funkcji wczeÅ›niej. Zobacz przykÅ‚ad, aby zobaczyÄ‡, jak to moÅ¼e wyglÄ…daÄ‡:

<Tabs>
<TabItem value="good" label="âœ”ï¸ Dobrze zorganizowane instrukcje if" default>

```cpp
using std::string;

string loginAsAdmin(string user, string pass) {
    if (not doesUserExist(user)) {
        return "User does not exist";
    }

    if (not isPasswordCorrect(user, pass)) {
        return "Password is incorrect";
    }

    if (not tryLogin(user, pass)) {
        return "Failed to login";
    }

    if (not isAdmin(user)) {
        return "User is not admin";
    }

    return "Success";
}
```
</TabItem>
<TabItem value="bad" label="âš ï¸ Zagmatwane instrukcje if" default>

```cpp
using std::string;

string loginAsAdmin(string user, string pass) {
    if (doesUserExist(user)) {
        if (isPasswordCorrect(user, pass)) {
            if (tryLogin(user, pass)) {
                if (isAdmin(user)) {
                    return "Success";
                } else {
                    return "User is not admin";
                }
            } else {
                return "Failed to login";
            }
        } else {
            return "Password is incorrect";
        }
    } else {
        return "User does not exist";
    }
}
```
</TabItem>
</Tabs>

MoÅ¼esz zobaczyÄ‡, jak mylÄ…cy przykÅ‚ad ma charakterystyczny trÃ³jkÄ…tny ksztaÅ‚t.
Jest to bardzo powszechny wskaÅºnik, Å¼e zagnieÅ¼dÅ¼asz swojÄ… logikÄ™ zbyt gÅ‚Ä™boko
i powinieneÅ› zastosowaÄ‡ jednÄ… z dwÃ³ch podanych wyÅ¼ej metod, aby to naprawiÄ‡.
Tutaj odwrÃ³ciliÅ›my warunki, aby najpierw sprawdziÄ‡ "smutnÄ… Å›cieÅ¼kÄ™". SzczÄ™Å›liwa Å›cieÅ¼ka
jest kontynuowana na dole, gdy sprawdzimy wszystkie warunki.
