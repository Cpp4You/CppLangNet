---
sidebar_position:	4
sidebar_label:		"1. Wprowadzenie"
title:				"Wprowadzenie do warunkÃ³w"
description:		"Lekcja: podstawy warunkÃ³w w C++"
tags:				[condition, if, else, else-if, compound, boolean, bool]
hide_title:			true
---

<!-- Components -->
import Tabs			from "@theme/Tabs";
import TabItem		from "@theme/TabItem";

<!-- Presets -->
import NotFinished	from "@site/i18n/en/presets/NotFinished.mdx";

# Wprowadzenie do WarunkÃ³w

Dotychczas tworzyliÅ›my programy, ktÃ³re za kaÅ¼dym razem dziaÅ‚aÅ‚y tak samo.
Nasze kreacje nie potrafiÅ‚y podejmowaÄ‡ decyzji. NadszedÅ‚ czas, aby to zmieniÄ‡.
W tej lekcji nauczymy siÄ™ jak sprawiÄ‡, by programy szÅ‚y innymi Å›cieÅ¼kami, zaleÅ¼nie od tego,
co wpisze uÅ¼ytkownik.

Stworzymy aplikacjÄ™, ktÃ³ra sprawdzi, czy uÅ¼ytkownik moÅ¼e legalnie uzyskaÄ‡ prawo jazdy. ğŸ˜

## Przygotowanie kodu

Najpierw zapytajmy uÅ¼ytkownika o jego rok urodzenia.

```cpp
#include <iostream>

int main()
{
	std::cout << "Welcome to the Driver's License Oracle 2000\n";
	std::cout << "Please enter your year of birth: ";

	int yearOfBirth;
	std::cin >> yearOfBirth;

	// W momencie pisania tej lekcji mamy 2022 rok
	int age = 2022 - yearOfBirth;

	// highlight-start
	// Przypadek A:
	std::cout << "You can legally get a driver's license\n";
	// highlight-end

	// highlight-start
	// Przypadek B:
	std::cout << "You cannot legally get a driver's license\n";
	// highlight-end
}
```

ZaznaczyÅ‚em tutaj dwa kawaÅ‚ki kodu - jeden, ktÃ³ry powinien siÄ™ wykonywaÄ‡, jeÅ›li uÅ¼ytkownik moÅ¼e legalnie dostaÄ‡
prawo jazdy, oraz drug, kiedy nie moÅ¼e. Chcem, aby tylko jeden przypadek siÄ™ wykonaÅ‚, nie oba. Jak moÅ¼emy to zrealizowaÄ‡?
Najpierw powinniÅ›my zastanowiÄ‡ siÄ™ jakie mamy "przypadki" i pod jakim warunkiem powinny siÄ™ wykonaÄ‡.

- Przypadek A â€” Legalny â€” Powinien siÄ™ wykonywaÄ‡ tylko, jeÅ›li `age` jest wiÄ™kszy lub rÃ³wny `18`
- Przypadek B â€” Nielegalny â€” Powinien siÄ™ wykonywaÄ‡ tylko, jeÅ›li `age` jest mniejszy od `18`

Teraz zobaczmy jak moÅ¼emy przeÅ‚oÅ¼yÄ‡ te przypadki na kod.

## Instrukcja warunkowa

NajprostszÄ… formÄ… warunku w C++ jest instrukcja `if`, ktÃ³rej podstawowa forma wyglÄ…da nastÄ™pujÄ…co:

```cpp title="ğŸ”¹ Anatomia instrukcji if"
if (/* warunek logiczny */)
{
	// Kod w Å›rodku wykonuje siÄ™ tylko wtedy, gdy warunek jest prawdziwy
}

// Kod poza wykonywany jest niezaleÅ¼nie od tego, czy warunek jest prawdziwy czy faÅ‚szywy
```

After an `if` keyword, we put a boolean condition inside of parentheses.
Then, the braces that surround #2 create what's known as a **block of code**. <u>Everything inside this code block will be
executed if and only if the condition is true</u>. Variables that are created in a code block live and die with that 
code block â€” they are destroyed when the block ends (with the closing brace `}` ) and are completely inaccessible
from outside it.

Let's apply this to our Driver's License example by combining the if statement with the cases we previously determined:

Aby uÅ¼yÄ‡ instrukcji `if`, potrzebujemy dwÃ³ch rzeczy:
1. Warunek, ktÃ³ry po obliczeniu daje wartoÅ›Ä‡ logicznÄ… typu `bool` - `true`/`false`
2. Kod, ktÃ³ry wykona siÄ™, jeÅ›li warunek bÄ™dzie prawdziwy (wartoÅ›Ä‡ `true`)

Po sÅ‚owie kluczowym `if`, umieszczamy warunek logiczny wewnÄ…trz nawiasÃ³w.
NastÄ™pnie, nawiasy, ktÃ³re otaczajÄ… #2 tworzÄ… tak zwany **blok kodu**. *Wszystko wewnÄ…trz tego bloku kodu zostanie
wykonane wtedy i tylko wtedy, gdy warunek jest prawdziwy*. Zmienne, ktÃ³re sÄ… tworzone w bloku kodu, Å¼yjÄ… i umierajÄ… razem z tym blokiem - sÄ… niszczone, gdy blok siÄ™ koÅ„czy (blok koÅ„czy siÄ™ na nawiasie zamykajÄ…cym `}`) i sÄ… niedostÄ™pne
spoza niego.

Zastosujmy to do naszego przykÅ‚adu z prawem jazdy, Å‚Ä…czÄ…c instrukcjÄ™ if z przypadkami, ktÃ³re wczeÅ›niej ustaliliÅ›my:

```cpp title="ğŸ”¹ Pierwsza prÃ³ba uÅ¼ycia instrukcji if"
#include <iostream>

int main()
{
	std::cout << "Welcome to the Driver's License Oracle 2000\n";
	std::cout << "Please enter your year of birth: ";

	int yearOfBirth;
	std::cin >> yearOfBirth;

	// W momencie pisania tej lekcji mamy 2022 rok
	int age = 2022 - yearOfBirth;

	// highlight-start
	// Przypadek A:
	if (/* zmienna age jest wiÄ™ksza lub rÃ³wna 18 */)
	{
		std::cout << "You can legally get a driver's license\n";
	}
	// highlight-end

	// highlight-start
	// Przypadek B B:
	if (/* zmienna age jest mniejsza od 18 */)
	{
		std::cout << "You cannot legally get a driver's license\n";
	}
	// highlight-end
}
```

Notice here how we have two `if` statements, one for each case.
The first one handles our Case A, where they can legally obtain a driver's license.
The second one handles our Case B, where they cannot legally obtain a driver's license.

Upon closer inspection, one fact should quickly become obvious â€” these cases are **mutually exclusive**.
This means that it is not possible for both cases to be true; only one or the other can execute.
C++ provides the `else` keyword to delineate mutually exclusive conditions. While the above code
will work as expected, we can improve it like so:

ZauwaÅ¼, Å¼e mamy tu dwie instrukcje `if`, po jednym dla kaÅ¼dego przypadku.
Pierwsza z nich obsÅ‚uguje przypadek A, w ktÃ³rym uÅ¼ytkownik moÅ¼e legalnie uzyskaÄ‡ prawo jazdy.
Druga obsÅ‚uguje nasz przypadek B, w ktÃ³rym nie moÅ¼e tego zrobiÄ‡.

Po bliÅ¼szej analizie, jedna rzecz powinnna szybko staÄ‡ siÄ™ oczywista - te przypadki sÄ… **wzajemnie wykluczajÄ…ce siÄ™**.
Oznacza to, Å¼e nie jest moÅ¼liwe, aby oba przypadki byÅ‚y prawdziwe na raz; tylko jeden lub drugi moÅ¼e siÄ™ wykonaÄ‡.
W C++ mamy sÅ‚owo kluczowe `else`, ktÃ³re sÅ‚uÅ¼y do definiowania wzajemnie wykluczajÄ…cych siÄ™ warunkÃ³w.
Podczas gdy powyÅ¼szy kod bÄ™dzie dziaÅ‚aÅ‚ zgodnie z oczekiwaniami, moÅ¼emy go ulepszyÄ‡ w nastÄ™pujÄ…cy sposÃ³b:

```cpp title="ğŸ”¹ Anatomia instrukcji if-else"
if (/* warunek logiczny */)
{
	// Kod w Å›rodku wykonuje siÄ™ tylko wtedy, gdy warunek jest prawdziwy
}
else
{
	// Kod w Å›rodku wykonuje siÄ™ tylko wtedy, gdy warunek jest faÅ‚szywy
}

// Kod poza wykonywany jest niezaleÅ¼nie od tego, czy warunek jest prawdziwy czy faÅ‚szywy
```

Blok `else` jest opcjonalny i powinieneÅ› go uÅ¼ywaÄ‡ tylko wtedy, kiedy chcesz obsÅ‚uÅ¼yÄ‡
wzajemnie wykluczÄ…cy siÄ™ warunki.

Teraz moÅ¼emy wrÃ³ciÄ‡ do naszego przykÅ‚adu i zobaczyÄ‡, Å¼e tylko jeden warunek jest konieczny,
poniewaÅ¼ jeÅ›li jeden jest prawdziwy, to drugi musi byÄ‡ faÅ‚szywy.

```cpp title="ğŸ”¹ Pierwsza prÃ³ba uÅ¼ycia instrukcji if-else"
#include <iostream>

int main()
{
	std::cout << "Welcome to the Driver's License Oracle 2000\n";
	std::cout << "Please enter your year of birth: ";

	int yearOfBirth;
	std::cin >> yearOfBirth;

	// W momencie pisania tej lekcji mamy 2022 rok
	int age = 2022 - yearOfBirth;

	// highlight-start
	if (/* zmienna age jest wiÄ™ksza lub rÃ³wna 18 */)
	{
		std::cout << "You can legally get a driver's license\n";
	}
	else
	{
		std::cout << "You cannot legally get a driver's license\n";
	}
	// highlight-end
}
```

:::danger Brak Å›rednika `;`

Nigdy nie dawaj Å›rednika (';') po nawiasach instrukcji `if.`
Nie spowoduje to bÅ‚Ä™du kompilacji, ale **sprawi to**, Å¼e TwÃ³j kod
bÄ™dzie dziaÅ‚aÄ‡ niepoprawnie.
Blok z kodem, ktÃ³ry powinienm siÄ™ wykonywaÄ‡ tylko zaleÅ¼nie od warunku bÄ™dzie siÄ™ wykonywaÄ‡ zawsze!.

<Tabs>
<TabItem value="right" label="âœ” Poprawnie" default>

```cpp
if (age >= 18) 
// ...
else
// ...
```

</TabItem>
<TabItem value="wrong" label="âŒ Niepoprawnie">

```cpp
if (age >= 18);
// ...
else;
// ...
```

</TabItem>
</Tabs>

:::

PodsumowujÄ…c, nauczyliÅ›my siÄ™ jak rozdzieliÄ‡ warunkowo wykonywane przypadki w naszym kodzie na
dedykowane instrukcje if. DziÄ™ki temu moÅ¼emy wybraÄ‡, jaki kod zostanie uruchomiony w zaleÅ¼noÅ›ci od rÃ³Å¼nych
wartoÅ›ci w naszym programie. Teraz, gdy mamy juÅ¼ podstawowÄ… strukturÄ™ naszej instrukcji if-else,
moÅ¼emy zobaczyÄ‡ jak zakoÅ„czyÄ‡ nasz program poprzez stworzenie warunku logicznego.

## WyraÅ¼enia logiczne

Inside the parenthesis of an `if` statement is the **boolean expression**, i.e. an expression
that evaluates to either `true` or `false`. C++ provides several new operators that allow
us to form such an expression.

WewnÄ…trz nawiasu instrukcji `if` znajduje siÄ™ wyraÅ¼enie **logiczne**, czyli wyraÅ¼enie
ktÃ³re ocenia siÄ™ na `true` lub `false`.
C++ posiada kilka operatorÃ³w, ktÃ³re pozwalajÄ… nam stworzyÄ‡ takie wyraÅ¼enia.

### Operatory logiczne


Below is a table that shows some of the **boolean operators** available in C++. A boolean operator
is one that returns a boolean `true`/`false` based on its input(s). 
They are like the other mathematical operators you've seen in previous lessons, but instead
of evaluating to a number like `int`, they evaluate to a `bool` (`true`/`false`).

| Operator | Odpowiednik matematyczny| Opis |
| -------- | -------------- | ----------- |
| `a == b` | a **=** b | Czy `a` rÃ³wna siÄ™Â `b`? |
| `a != b` | a â‰  b | Czy `a` nie rÃ³wna siÄ™Â `b`? |
| `a > b` | a **&gt;** b | Czy `a` jest wiÄ™ksze od `b`? |
| `a >= b` | a â‰¥ b | Czy `a` jest wiÄ™ksze lub rÃ³wne `b`?  |
| `a < b` | a **&lt;** b | Czy `a` jest mniejsze od `b?` |
| `a <= b` | a â‰¤ b | Czy `a` jest mniejsze lub rÃ³wne `b?`  |

#### Operatory rÃ³wnoÅ›ci

Pierwsze dwa wiersze naszej tabelkie `==` i `!=` to **operatory rÃ³wnoÅ›ci**.
Te dwa operatory pozwalajÄ… nam sprawdziÄ‡, czy dwie wartoÅ›ci sÄ… takie same.
Operatory rÃ³wnoÅ›ci dziaÅ‚ajÄ… na wiÄ™kszoÅ›ci typÃ³w C++, w tym na liczbach, napisach, boolach (typ `bool`) i innych.

:::danger
Pojedynczy znak `=` rÃ³Å¼ni siÄ™ od podwÃ³jnego `=`. Pojedynczy `=` jest **operatorem przypisania**, np. gdy tworzysz zmiennÄ… lub zmieniasz jej wartoÅ›c.
PodwÃ³jny `=` jest **operatorem rÃ³wnoÅ›ci**, uÅ¼ywanym gdy chcesz sprawdziÄ‡ czy dwie zmienne majÄ… tÄ™ samÄ… wartoÅ›Ä‡.

W instrukcjach `if`, jeÅ›li chcemy sprawdziÄ‡ czy dwie zmienne sÄ… takie same zawsze naleÅ¼y uÅ¼yÄ‡ `==`:
- âœ” `if (a == b)`
- âŒ `if (a = b)`
:::

#### Operatory relacyjne

Operatory relacyjne dziaÅ‚ajÄ… na niektÃ³rych typach C++, takich jak liczby i ciÄ…gi znakÃ³w; jednakÅ¼e,
wiele innych typÃ³w, ktÃ³rych jeszcze nie omÃ³wiliÅ›my, nie moÅ¼e byÄ‡ porÃ³wnywanych w ten sposÃ³b.

Wiemy teraz wystarczajÄ…co duÅ¼o, aby pierwsza wersja naszego programu zaczÄ™Å‚a dziaÅ‚aÄ‡. Dla przypomnienia,
musimy stworzyÄ‡ warunek, ktÃ³ry sprawdzi, czy wiek uÅ¼ytkownika jest wiÄ™kszy niÅ¼
lub rÃ³wny 18. KorzystajÄ…c z powyÅ¼szej tabeli, najbliÅ¼szym dopasowaniem jest `age >= 18`.
Zapiszmy wiÄ™c ten warunek:

```cpp title="ğŸ”¹ Sprawdzacz Prawo Jazdy 2000"
#include <iostream>

int main()
{
	std::cout << "Welcome to the Driver's License Oracle 2000\n";
	std::cout << "Please enter your year of birth: ";

	int yearOfBirth;
	std::cin >> yearOfBirth;

	// W momencie pisania tej lekcji mamy 2022 rok
	int age = 2022 - yearOfBirth;

	// highlight-next-line
	if (age >= 18)
	{
		std::cout << "You can legally get a driver's license\n";
	}
	else
	{
		std::cout << "You cannot legally get a driver's license\n";
	}
}
```

Jako wyzwanie bonusowe, sprÃ³buj utworzyÄ‡ trzy inne warunki, rÃ³wnowaÅ¼ne do `age >= 18`, uÅ¼ywajÄ…c kaÅ¼dego pozostaÅ‚ego operatora relacyjnego.

### ZÅ‚oÅ¼one wyraÅ¼enia logiczne

MoÅ¼esz przeksztaÅ‚caÄ‡ i Å‚Ä…czyÄ‡ wyraÅ¼enia logiczne za pomocÄ… tak zwanych **operatorÃ³w logicznych**.
SÄ… one podzbiorem operatorÃ³w logicznych wprowadzonych powyÅ¼ej, ale sÄ… przeznaczone do przyjmowania
wartoÅ›ci logicznych jako dane wejÅ›ciowe

C++ supports two equivalent forms of these operators, a textual version
and a symbolic version. While the symbolic representation is more common in the wild, you may find
the textual representation to be easier to understand and remember. You can use whichever you like
best, but try to be consistent!

C++ obsÅ‚uguje dwie rÃ³wnowaÅ¼ne formy tych operatorÃ³w, wersjÄ™ tekstowÄ…
oraz wersjÄ™ symbolicznÄ…. ChociaÅ¼ symboliczna reprezentacja jest bardziej powszechna,
reprezentacja tekstowa moÅ¼e byÄ‡ dla Ciebie Å‚atwiejsza do zrozumienia i zapamiÄ™tania.
MoÅ¼esz uÅ¼ywaÄ‡ dowolnej reprezentacji, ale staraj siÄ™ byÄ‡ konsekwentny!

| Operator | Alternatywna reprezentacja | Opis |
| -------- | -------------- | ----------- |
| `a and b` | `a && b` | Czy `a` i `b` sÄ… oba prawdziwe? |
| `a or b` | <code>a &#x7C;&#x7C;  b</code>  | Czy ktÃ³rykolwiek z `a` lub `b` jest prawdziwe?  |
| `not c` | `!c` | Czy `c` jest faÅ‚szywe? |

#### Logiczny operator I (and)

Logiczny operator I `and`/`&&` bierze dwie wartoÅ›Ä‡i logiczne i zwraca prawdÄ™ wtedy i tylko wtedy, jeÅ›li
oba sÄ… prawdziwe. Najlepiej uÅ¼ywaÄ‡ go, kiedy chcesz sprawdziÄ‡,
czy kilka warunkÃ³w na jest na raz prawdziwych lub faÅ‚szywych (uÅ¼ywajÄ…c operatora negacji, `not`/`!`).

Dla przykÅ‚adu, `false && true` to `false`, ale `true and true` to `true`.

#### Logiczny operator LUB (or)

Podobnie jak I, logiczny operator LUB `or`/`||`` przyjmuje dwa wejÅ›cia logiczne i zwraca `true` jeÅ›li
jedno lub oba jego wejÅ›cia sÄ… `true`. Najlepiej uÅ¼ywaÄ‡ go, gdy chcemy sprawdziÄ‡, czy ktÃ³ryÅ› z wielu
warunkÃ³w jest prawdziwy, lub gdy jedna zmienna jest jednÄ… z wielu moÅ¼liwoÅ›ci

Dla przykÅ‚adu, `false or false` to `false`, ale `false || true` to `true`

#### Logiczny operator NEGACJI (not)

ZwrÃ³Ä‡ szczegÃ³lnÄ… uwagÄ™ na ostatni wiersz tabeli wyÅ¼ej; `not`/`!` jest znany jako **logiczny operator negacji**
Ten operator zmienia wartoÅ›Ä‡ pojedynczego wejÅ›cia na przeciwnÄ…, wiÄ™c w wyraÅ¼enii `!c`, `c` jest wartoÅ›ciÄ… logicznÄ…
( `true`/ `false` ), a `!` zamieni `true` na `false`, a `false` na `true`.
Jest to rÃ³wnowaÅ¼ne z pytaniem "czy `c` jest `false`". Ten operator przydaje siÄ™, gdy chcesz
sprawdziÄ‡, czy jakiÅ› warunek nie zostaÅ‚ speÅ‚niony.

Dla przykÅ‚adu, `!(a == b)` to to samo co `a != b`.
Oraz, `not (a <= b)` to to samo co `a > b`.


ZwrÃ³c uwagÄ™, Å¼e uÅ¼ywamy nawiasÃ³w, aby najpierw wykonywaÄ‡ wyraÅ¼enie logiczne wewnÄ…trz,
a dopiero potem je zanegowaÄ‡.

#### Ulepszanie naszego programu

The state has passed new regulations and now we must upgrade our Oracle program to comply.
The new law stipulates a maximum age for driver's licenses â€” <u>those 65 years and older are
no longer allowed to operate a motor vehicle</u>.

We need to expand on our boolean condition to abide by this new requirement. Currently,
`age >= 18` sets the *lower bound* for the range of acceptable values.
We are missing something that sets the *upper bound*, which should be 65. 
A boolean expression that checks if the age is less than 65 could look like `age < 65`.
Note that we use `<` instead of `<=` because 65 year olds are banned from driving.

Now we have `age >= 18` and `age < 65`, which must be combined in some way.
We need to somehow specify that BOTH must be true â€” the person must be 
18 or older AND younger than 65 to get a driver's license. 

Looking back at the table in [Compound boolean expressions](#compound-boolean-expressions), 
we can see that the `and`/`&&` operator fits this situation best.
We can write this compound condition like `age >= 18 and age < 65`. Note
that the left/right order here does not matter, meaning that
`age < 65 and age >= 18` is an equivalent condition.

ZostaÅ‚y uchwalone nowe przepisy i teraz musimy modernizowaÄ‡ nasz program, aby je obsÅ‚uÅ¼yÄ‡.
Nowe prawo okreÅ›la maksymalny wiek dla kogoÅ›, kto chce mieÄ‡ prawo jazdy - _osoby w wieku 65 lat i starsze nie mogÄ… juÅ¼ prowadziÄ‡ pojazdÃ³w mechanicznych_.

Musimy rozszerzyÄ‡ nasz warunek, aby speÅ‚niÄ‡ ten nowy wymÃ³g.
Obecnie, `age >= 18` okreÅ›la *dolnÄ… granicÄ™* dla zakresu dopuszczalnych wartoÅ›ci.
Brakuje nam czegoÅ›, co ustawi *gÃ³rnÄ… granicÄ™*, ktÃ³rÄ… powinno byÄ‡ `65`.


WyraÅ¼enie logiczne, ktÃ³re sprawdza czy wiek jest mniejszy niÅ¼ `65` moÅ¼e wyglÄ…daÄ‡ tak: `age < 65`.
ZauwaÅ¼, Å¼e uÅ¼ywamy `<` zamiast `<=`, poniewaÅ¼ 65-latkowie majÄ… zakaz prowadzenia pojazdÃ³w.

Teraz mamy `age >= 18` i `age < 65`, ktÃ³re muszÄ… byÄ‡ w jakiÅ› sposÃ³b poÅ‚Ä…czone.
Musimy jakoÅ› okreÅ›liÄ‡, Å¼e OBA muszÄ… byÄ‡ prawdziwe - osoba musi byÄ‡
18 lub starsza ORAZ mÅ‚odsza niÅ¼ 65, aby otrzymaÄ‡ prawo jazdy.

PatrzÄ…c na tabelÄ™ w [ZÅ‚oÅ¼one wyraÅ¼enia logiczne](#zlozone-wyrazenia-logiczne),
widzimy, Å¼e operator `and`/`&&` najlepiej pasuje do tej sytuacji.
MoÅ¼emy zapisaÄ‡ ten warunek jako `age >= 18 and age < 65`.
ZauwaÅ¼ Å¼e kolejnoÅ›Ä‡ lewo/prawo nie ma tutaj znaczenia, co oznacza, Å¼e
`age < 65 and age >= 18` jest warunkiem rÃ³wnowaÅ¼nym.


```cpp title="ğŸ”¹ Sprawdzacz Prawo Jazdy 3000"
#include <iostream>

int main()
{
	std::cout << "Welcome to the Driver's License Oracle 3000\n";
	std::cout << "Please enter your year of birth: ";

	int yearOfBirth;
	std::cin >> yearOfBirth;

	// W momencie pisania tej lekcji mamy 2022 rok
	int age = 2022 - yearOfBirth;

	// highlight-next-line
	if (age >= 18 and age < 65)
	{
		std::cout << "You can legally get a driver's license\n";
	}
	else
	{
		std::cout << "You cannot legally get a driver's license\n";
	}
}
```

:::danger ÅÄ…czenie operatorÃ³w rÃ³wnoÅ›ci lub operatorÃ³w relacyjnych
MoÅ¼e CiÄ™ kusiÄ‡, aby warunek uÅ¼yty powyÅ¼ej zapisaÄ‡ jako `18 <= age < 65`.
To **nie zadziaÅ‚a**. Skompiluje siÄ™, aczkolwiek bÄ™dzie dawaÄ‡ niepoprawny wynik - zawsze `true`.

Taki sam problem moÅ¼emy zaobserwowaÄ‡ w przypadku operatorÃ³w rÃ³wnoÅ›ci.
Dla przykÅ‚adu, `age1 == age2 == 18` lub `age1 != age2 != 35`, oba bÄ™dÄ… zachowywaÄ‡ siÄ™ podobnie,
zawsze zwracajaÄ‡ `true` lub `false`.

Nigdy nie prÃ³buj Å‚Ä…czyÄ‡ w taki sposÃ³b operatorÃ³w rÃ³wnoÅ›ci lub operatorÃ³w relacyjnych, zamiast tego
zawsze uÅ¼ywaj operatorÃ³w `and`/`&&` lub `or`/`||`, aby Å‚Ä…czyÄ‡ caÅ‚e warunki.


WyjaÅ›nienie dlaczego dziaÅ‚a to w taki sposÃ³b znajdziej tu [Typ `bool` Â» konwersja z `int` na `bool`](/learn/course/basics/conditions/booleans/#konwersja-z-int-na-bool).
:::

### KolejnoÅ›Ä‡ operacji

Podobnie jak operatory matematyczne, operatory logiczne rÃ³wnieÅ¼ majÄ… swÃ³j priorytet,
ktÃ³rego Å›ciÅ›le przestrzegajÄ….
Podobnie jak w przypadku "PEMDAS", nawiasy sÄ… zawsze liczone peirwsze,
a pozostaÅ‚e operatory wg priorytetÃ³w wymienionych niÅ¼ej.
**NajwyÅ¼szy priorytet jest na gÃ³rze.**

:::note PEMDAS
PEMDAS z angielskiego to skrÃ³towiec od _**P**arentheses, **E**xponents, **M**ultiplication and **D**ivision, **A**ddition and **S**ubtraction_, co tÅ‚umaczy siÄ™ na **N**awiasy, **P**otÄ™gi, **M**noÅ¼enie i **D**zielenie, **D**odawanie i **O**dejmowanie.


SÅ‚uÅ¼y on do zapamiÄ™tania poprawnej kolejnoÅ›ci podstawowych operacji matematycznych.
:::

| Operator | Nazwa | ÅÄ…cznoÅ›Ä‡ |
| -------- | -------------- | ----------- |
| `!` `not` | Logiczna NEGACJA | Prawo-do-lewo ğŸ¡  |
| `*` `/` `%` | MnoÅ¼enie/Dzielenie  | Lewo-do-prawo ğŸ¡¢ |
| `+` `-` | Dodawanie/Odejmowanie | Lewo-do-prawo ğŸ¡¢ |
| `<` `<=` `>` `>=` | Operatory relacyjne | Lewo-do-prawo ğŸ¡¢ |
| `==` `!=` | Operatory rÃ³wnoÅ›ci | Lewo-do-prawo ğŸ¡¢ |
| `&&` `and` | Logiczne I | Lewo-do-prawo ğŸ¡¢ |
| <code>&#x7C;&#x7C;</code> `or` | Logiczne LUB | Lewo-do-prawo ğŸ¡¢ |

UÅ¼yjmy tej tabelki do przeanalizowania nastÄ™pujÄ…cych przykÅ‚adÃ³w:

```cpp title="ğŸ”¹ Priorytet Operacji"
a > 10 and a < 100 or a == 150
// rÃ³wnowaÅ¼ne z
(a > 10 and a < 100) or a == 150

a * 4 == b + 5
// rÃ³wnowaÅ¼ne z
(a * 4) == (b + 5)

not a or b < 3701
// rÃ³wnowaÅ¼ne z
(not a) or (b < 3701)

not a != false
// rÃ³wnowaÅ¼ne z
(not a) != false
```
:::tip UÅ¼ywaj nawiasÃ³w do forsowania kolejnoÅ›ci operacji
DobrÄ… praktykÄ… jest nie polegaÄ‡ zbytnio na reguÅ‚ach pierwszeÅ„stwa operatorÃ³w.
Programistom moÅ¼e byÄ‡ trudno pamiÄ™taÄ‡ wszystkie priorytety operatorÃ³,
wiÄ™c pisanie duÅ¼ej iloÅ›ci kodu zaleÅ¼nego od tych reguÅ‚ moÅ¼e sprawiÄ‡, Å¼e bÄ™dzie on
mnij czytelne i trudniejszy do zrozumienia.
JeÅ›li chcesz, aby jakieÅ› podwyraÅ¼enie byÅ‚o obliczane jako pierwsze, zastanÃ³w siÄ™,
czy uÅ¼ycie nawiasÃ³w nie bÄ™dzie dobrym pomysÅ‚em.

WiÄ™c, zamiast pisaÄ‡ `a and b and c or a and not b`, zastanÃ³w siÄ™Â czy lepiej nie bÄ™dzie napisaÄ‡ `(a and b and c) or (a and not b)`.
:::
