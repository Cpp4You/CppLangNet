---
sidebar_label:		"3. Typ boolowski"
title:				"Typ boolowski"
description:		"Lekcja: Typ boolowski w C++"
tags:				[condition, if, else, else-if, compound, bool, boolean]
hide_title:			true
---

import Columns			from '@site-comps/Columns';

# Typ boolowski

## Typ `bool`

Jeli pamitasz z [lekcji o zmiennych](/learn/course/basics/variables/#typ-zmiennej),
jednym z podstawowych typ贸w jest `bool`. Typ ten reprezentuje **warto logiczn**
(warto boolowsk), kt贸ra ma tylko jedn warto `true` lub `false`.

[Wyra偶enia boolowskie](/learn/course/basics/conditions/intro/#wyra偶enia-logiczne),
o kt贸rych dowiedzielimy si na pocztku tej lekcji o warunkach, ewaluuj si do wartoci logicznej (boolowskiej).
Mo偶emy wic stworzy zmienne, kt贸re s wynikami takich wyra偶e logicznych, a nastpnie
dalej u偶ywa tych zmiennych `bool` w warunkach instrukcji if.

W C++ istniejdwie wbudowane wartoci logiczne - `true` i `false`. Mo偶na ich u偶y wszdzie tam,
gdzie oczekiwany jest typ `bool` lub wyra偶enie boolowskie. Dla przykadu:

```cpp title=" Literay boolowskie"
bool var1 = true;
bool var2 = false;
```

S te偶 ciekawsze rzeczy, kt贸re mo偶emy zrobi ze zmiennymi `bool`.
Ka偶de wyra偶enie boolean mo偶na przypisa do zmiennej. Poczenie tego z
instrukcjami if mo偶e w niekt贸rych przypadkach skr贸ci kod i uczyni go bardziej czytelnym.

```cpp title=" U偶ywanie zmiennych boolowskich do okrelania pogody"
std::string name;

std::cout << "Enter your first name: ";
std::cin >> name;

// U偶ytkownik jest szczliwy, jeli jego imi ma wicej ni偶 5 znak贸w
// highlight-next-line
bool isLucky = name.size() > 5;

// Spr贸buj pozmienia te wartoci i zobacz co si stanie!
// highlight-start
bool isTuesday = true;
bool isCloudy = false;
// highlight-end

std::string weather = "sunny";

if (not isTuesday and isCloudy) {
	weather = "raining";
} else if (isTuesday) {
	if (isCloudy) {
		weather = "overcast";
	} else if (not isLucky) {
		weather = "downpouring";
	}
}

std::cout << "It is currently " << weather << " in your location!";
```

Wczeniej wprowadzone [operatory logiczne](/learn/course/basics/conditions/intro/#zo偶one-wyra偶enia-logiczne)
mog zosta u偶yte do stworzenia nowych zmiennych boolowskich:

```cpp title=" U偶ywanie operator贸w logicznych na boolach"
bool isPrecipitating = weather == "raining" or weather == "downpouring";
bool isRainbowMade   = isPrecipitating and not isCloudy;
bool isBoringDay     = not isRainbowMade;
```

## Wczytywanie/Wypisywanie typ贸w boolowskich

Jeli pr贸bowae sam eksperymentowa z typem `bool`, moge zauwa偶y, 偶e wypisanie zmiennej lub wyra偶enia
tego typu nie wywietla `true` czy `false`, a `1` lub `0`.
Jest to domylne zachowanie w C++, kt贸re jest zwizane z [nastpn sekcj](#konwersja-z-int-na-bool).

Mo偶esz zmieni to zachowanie w prosty spos贸b zmieniajc jedno z domylnych ustawie `std::cout`.
Po prostu "wypisz" flag `std::boolalpha` za pomoc `std::cout`. Spowoduje to, 偶e ka偶de przysze wyra偶enie logiczne lub
zmienna typu `bool` zostanie wypisana w postaci `true`/`false`, zamiast `1`/`0`.

:::tip Doczenie odpowiedniego nag贸wka
Upewniej si, 偶e doczye nag贸wek `<iomanip>` (`#include <iomanip>`), aby m贸c u偶y `std::boolalpha`.
:::

<Columns columns={['2fr', '1fr']}>
<div>

```cpp title=" Wypisywanie true/false"
std::cout << true << " " << false << "\n";
// highlight-next-line
std::cout << std::boolalpha;
std::cout << true << " " << false << "\n";
```
</div>
<div>

```plaintext title="Wynik"
1 0
true false
```
</div>
</Columns>

Tak samo `std::cin` domylnie akceptuje tylko `0` lub `1` przy wprowadzaniu do zmiennej `bool`.
To zachowanie mo偶e by r贸wnie偶 zmienione przez "wprowadzenie" do flagi `std::boolalpha`.
W poni偶szym przykadzie, u偶ytkownik najpierw wprowadzi `0`, co reprezentuje `false`.
Nastpnie, wprowadzi `true` po zastosowaniu ustawienia `std::boolalpha`.

<Columns columns={['2fr', '1fr']}>
<div>

```cpp title=" Wprowadzanie true/false"
bool var;

std::cout << "Integral form: ";
std::cin >> var;

// highlight-next-line
std::cin >> std::boolalpha;

std::cout << "Alphanumeric form: ";
std::cin >> var;
```
</div>
<div>

```plaintext title="Input/Output"
Integral form: 1
Alphanumeric form: true
```
</div>
</Columns>

Jako wiczenie, spr贸buj zmodyfikowa nasz [program pogodowy](#typ-bool), tak, aby przyjmowa `true`/`false`,
zamiast `1`/`0`.

:::note Ciekawostka
Nazwa "boolalpha" pochodzi ze zczenia s贸w boolean i alphanumeric (ang.: *alfanumeryczny*)
:::

## Konwersja pomidzy `int` a `bool`

C++ posiada kolejne, do denerwujce, zachowanie, kt贸re powoduje, 偶e liczby i typy boolowskie mog
si niejawnie konwertowa pomidzy sob.
Warto boolowska `false` odpowiada liczbie o wartoi `0`, a `true` wartoci `1`.
Tak samo liczba o wartoci `0` odpowiada wartoci boolowskiej `false`, a ka偶da inna od `0`
odpowiada wartoci `true`.

```cpp title=" Przykad konwersji pomidzy liczbami a boolami"
int x = true; // x to 1
int y = false; // y to 0

bool a = 1; // a to true
bool b = 25; // b to true
bool c = -194; // c to true
bool d = 0; // d to false
```

Mimo, 偶e to zachowanie mo偶e si wydawa przydatne, czasem mo偶e si zdarzy, 偶e konwersja wydarzy si wtedy,
kiedy nie jest chciana.
Z tego powodu, jeli chcesz intencjonalnie spowodowa konwersjpomidzy `int` (lub ka偶dym innym typem cakowitoliczbowym),
a `bool` u偶y *casta*.

```cpp title=" Castowanie pomidzy int a bool"
int x = static_cast<int>(true); // Nowoczesny styl castowania
int y = (int) false; 			// Castowanie w stylu C

bool a = static_cast<bool>(1);
bool b = (bool) 0;
```

S dwa sposoby na jakie mo偶emy przeprowadzi takie castowanie w C++ - castowanie *nazwane*,
a konkretnie *static_cast* (nowoczesny spos贸b), lub castowanie w stylu C.

R贸偶nice midzy nimi poznasz w kursie dla redniozaawansowanych. Na razie wiedz tylko, 偶e,
w przypadku konwersji pomidzy `int`, a `bool`, obie opcje s r贸wnowa偶ne.
Jednak w nowoczesnym C++ generalnie preferowane jest u偶ywanie `static_cast`.

### Niechciane konwersje

Niechciane konwersje mog powodowa problemy tak, gdzie najmniej si ich spodziewasz.
Jednym z przykad贸w jest problem,
kt贸ry om贸wilimy w [zo偶one warunki logiczne](/learn/course/basics/conditions/intro/#zo偶one-warunki-logiczne).
Normalnie, jeli chcemy poczy dwa wyra偶enia logiczne, u偶ywamy do tego operator贸w logicznych:

```cpp
if (x > 10 && x < 25) { ... }
```

Mo偶e Ci kusi, aby przepisa ten warunek jako `10 < x < 25`.
**To spowoduje, 偶e program bdzie sizachowywa niepoprawnie**, poniewa偶 to wyra偶enie bdzie zawsze prawdziwe.
Dzieje si tak, poniewa偶 zachodzi tutaj ukryta konwersja z `bool` na `int`.
To wyra偶enie jest interpretowane w taki spos贸b: `(10 < x) < 25`.


Zobaczmy wic w jaki spos贸b to wyra偶enie zawsze ewaluuje si do `true` odnoszc si do
naszej [tabeli priorytet贸w operator贸w](/learn/course/basics/conditions/intro/#kolejno-operacji):

<Columns columns={['1fr', '1fr']}>
<div>

```cpp title=" Niepoprawne czenie warunk贸w z x = 15"
10 < x < 25    // Pocztkowe wyra偶enie
10 < 15 < 25   // Podstawiamy x
(10 < 15) < 25 // Kolejno operator贸w
(true) < 25    // Ewaluujemy podwyra偶enie
1 < 25		   // Konwersja z bool na int
true		   // Ewaluujemy wyra偶enie
```
</div>
<div>

```cpp title=" Niepoprawne czenie warunk贸w z x = 7"
10 < x < 25   // Pocztkowe wyra偶enie
10 < 7 < 25   // Podstawiamy x
(10 < 7) < 25 // Kolejno operator贸w
(false) < 25  // Ewaluujemy podwyra偶enie
0 < 25	      // Konwersja z bool na int
true	      // Ewaluujemy wyra偶enie
```
</div>
</Columns>

Ten sam problem mo偶e wystpi r贸wnie偶 w innych, podobnych scenariuszach.
Na przykad, podczas sprawdzania, czy pojedyncza zmienna jest jedn z wielu mo偶liwoci,
poprawnym sposobem byoby `x == 5 || x == 10 || x == 15`.
Kuszca opcja `x == 5 || 10 || 15` **nie zadziaa** z podobnego powodu jak wy偶ej -
zawsze bdzie to prawda. Zobaczmy dlaczego:

<Columns columns={['1fr', '1fr']}>
<div>

```cpp title=" Niepoprawne czenie warunk贸w z x = 5"
x == 5 || 10 || 15     // Pocztkowe wyra偶enie
5 == 5 || 10 || 15     // Podstawiamy x
((5 == 5) || 10) || 15 // Kolejno operator贸w
((true) || 10) || 15   // Ewaluujemy podwyra偶enie
(true || true) || 15   // Konwersja z int na bool
true || 15             // Ewaluujemy podwyra偶enie
true || true           // Konwersja z int na bool
true                   // Ewaluujemy wyra偶enie
```
</div>
<div>

```cpp title=" Niepoprawne czenie warunk贸w z x = 7"
x == 5 || 10 || 15     // Pocztkowe wyra偶enie
7 == 5 || 10 || 15     // Podstawiamy x
((7 == 5) || 10) || 15 // Kolejno operator贸w
((false) || 10) || 15  // Ewaluujemy podwyra偶enie
(false || true) || 15  // Konwersja z int na bool
true || 15             // Ewaluujemy podwyra偶enie
true || true           // Konwersja z int na bool
true                   // Ewaluujemy wyra偶enie
```
</div>
</Columns>


## Konkluzja

Podsumowaujc, nauczylimy si:
- Rozdziela warunkowe cie偶ki w programie za pomoc [instrukcji warunkowej if](/learn/course/basics/conditions/intro/#instrukcja-warunkowa)
- Tworzy [wyra偶enia logiczne](/learn/course/basics/conditions/intro/#wyra偶enia-logiczne)
- [czenia kilka warunk贸w](/learn/course/basics/conditions/compound/#zo偶ona-instrukcja-warunkowa) we wzajemnie wykluczajce si grupy
- [Zagnie偶d偶a ify](/learn/course/basics/conditions/compound/#zagnie偶d偶anie-instrukcji-warunkowych) wewntrz siebie
- Redukowa powtarzanie si kodu poprzez stosowanie [zasady DRY](/learn/course/basics/conditions/compound/#u偶ywanie-zmiennych-aby-ograniczy-powtarzanie-kodu)
- U偶ywa [zmiennych boolowskich](#typ-bool), aby ulepszy nasz kod

To bya duga podr贸偶, ale umiejtnoci, kt贸re zebrae w tej lekcji s bardzo wa偶ne
dla przyszej drogi. Przeczytaj kilka razy koncepcje przedstawione w tej lekcji, poniewa偶 podstawy
wyra偶e logicznych i instrukcji warunkowych s bardzo wa偶n umiejtnoci.
