---
sidebar_position:	9
sidebar_label:		"9. Metody"
title:				"Metody"
description:		"Lekcja: podstawy metod w jÄ™zyku C++"
tags:				[metoda, konstruktor, destruktor, struktura, klasa, obiekt, programowanie-obiektowe, oop]
hide_title:			true
---

{/* Components */}
import Columns			from '@site-comps/Columns';
import Tabs				from '@theme/Tabs';
import TabItem			from '@theme/TabItem';
import Image			from '@site-comps/Image';

{/*  Presets */}
import NotFinished		from '@site/i18n/pl/presets/NotFinished.mdx';
import ImproveSection	from '@site/i18n/pl/presets/ImproveSection.mdx';

<NotFinished/>

# Metody

Ta lekcja pokaÅ¼e Ci, jak umieszczaÄ‡ funkcje wewnÄ…trz struktury, czyli tworzyÄ‡ tzw. metody.

## Motywacja

W programowaniu czÄ™sto odwzorowuje siÄ™ obiekty z Å¼ycia, np. podczas tworzenia gry wyÅ›cigowej ğŸ
bÄ™dziemy chcieli umiesciÄ‡ pojazdy, ktÃ³re bÄ™dÄ… definiowane poprzez swoje

- **cechy**, np.:
	- markÄ™
	- model ğŸš˜
	- maks. prÄ™dkoÅ›Ä‡ ğŸš€
- **zachowania**, np.:
	- przyspieszanie ğŸ’¨
	- hamowanie ğŸ›‘

Ten sposÃ³b opisywania obiektÃ³w, rozdzielajÄ…cy cechy i zachowania, jest bardzo powszechny.
W lekcji o [strukturach](../structures) uczyliÅ›my siÄ™ jak zawieraÄ‡ rÃ³Å¼ne informacje
o obiektach wewnÄ…trz jednego typu, ktÃ³ry sami stworzyliÅ›my. W ten sposÃ³b opisaliÅ›my
jego **cechy**. Teraz przejdziemy do metod, ktÃ³re pozwolÄ… nam "nauczyÄ‡" obiekt
wykonywaÄ‡ konkretne zadania - okreÅ›lÄ… jego **zachowanie**. 

## Wprowadzenie

Na potrzeby tej lekcji stwÃ³rzmy strukturÄ™, ktÃ³ra zawiera cechy samochodu:

```cpp
struct Car
{
	// informacje o pojeÅºdzie
	std::string	brand;
	std::string	model;
	int			yearOfProduction;

	// poruszanie siÄ™
	float		topSpeed = 200;		// max. prÄ™dkoÅ›Ä‡ (km/h)
	float		acceleration = 50;	// przyspieszenie (km/h na sekundÄ™)
	float		speed = 0;			// aktualna prÄ™dkoÅ›Ä‡ (km/h)
};
```

WewnÄ…trz funkcji `main` stwÃ³rzmy obiekt tej struktury:

```cpp
int main()
{
	Car car;
	car.brand = "Ford";
	car.model = "Focus";
	car.yearOfProduction = 2010;

}
```

Teraz przejdziemy do tego, jak zmusiÄ‡ go (`car`) do dziaÅ‚ania.

## Tworzenie i uÅ¼ywanie metod

WewnÄ…trz struktury `Car`, na jej koniec, umieÅ›Ä‡my funkcjÄ™, o nazwie `accelerate`,
ktÃ³ra bÄ™dzie zwiÄ™kszaÅ‚a `speed` o wartoÅ›Ä‡ przyspieszenia `acceleration`:

```cpp
struct Car
{
	// informacje o pojeÅºdzie
	std::string	brand;	
	// ...

	// funkcja zwiÄ™kszajÄ…ca prÄ™dkoÅ›Ä‡
	// highlight-next-line
	void accelerate()
	{
		speed += acceleration;
	}
};
```

:::important Definicja
**Metodami** nazywamy funkcje, ktÃ³re naleÅ¼Ä… do struktur (lub klas, z ktÃ³rymi zapoznasz siÄ™ dalej w kursie).
:::

Tak utworzonÄ… metodÄ™, moÅ¼emy wywoÅ‚aÄ‡ na obiekcie, w ten sposÃ³b:

<Columns columns={['2fr', '1fr']}>
<div>

```cpp title="WywoÅ‚anie metody accelerate()"
// ...

int main()
{
	Car car;
	// poczÄ…tkowe wartoÅ›ci...

	// wywoÅ‚anie po raz pierwszy
	// highlight-next-line
	car.accelerate();
	std::cout << "Aktualna prÄ™dkoÅ›Ä‡: " << car.speed << " km/h\n";
	// wywoÅ‚anie po raz drugi
	// highlight-next-line
	car.accelerate();
	std::cout << "Aktualna prÄ™dkoÅ›Ä‡: " << car.speed << " km/h\n";
}
```

</div>
<div>

```plaintext title="Wynik"
Aktualna prÄ™dkoÅ›Ä‡: 50 km/h
Aktualna prÄ™dkoÅ›Ä‡: 100 km/h
```

</div>
</Columns>

Podajemy nazwÄ™ obiektu, ktÃ³ry ma wykonaÄ‡ danÄ… rzecz, nastÄ™pnie po kropce
podajemy nazwÄ™ metody i parametry - tak jak przy wywoÅ‚aniu zwykÅ‚ej funkcji.

<Columns columns={['1fr', '1fr']}>
<div>

```cpp title="WywoÅ‚anie metody"
obiekt.nazwaMetody(argumenty);
```

</div>
<div>

```cpp title="WywoÅ‚anie funkcji"
nazwaFunkcji(argumenty);
```

</div>
</Columns>

### KolejnoÅ›Ä‡ definicji

WewnÄ…trz struktury, metody nie muszÄ… byÄ‡ zdefiniowane przed deklaracjÄ… zmiennej lub innej metody,
ktÃ³ra teÅ¼ do tej struktury naleÅ¼y:

<Tabs>
<TabItem value="good1" label="âœ” Dobrze" default>

ZwrÃ³Ä‡ uwagÄ™ na kolejnoÅ›Ä‡ definiowania metod: `limitSpeed` zostaÅ‚a uÅ¼yta w `accelerate`,
mimo Å¼e jej definicja znajduje siÄ™ niÅ¼ej. Podobnie pola `speed` oraz `acceleration`,
zostaÅ‚y uÅ¼yte przed ich deklaracjÄ…, bo znajduje siÄ™ ona w kodzie **pod** tym uÅ¼yciem.
W ramach struktury jest to dozwolone.

```cpp
struct Car
{
	// funkcja zwiÄ™kszajÄ…ca prÄ™dkoÅ›Ä‡
	void accelerate()
	{
		speed += acceleration;
		limitSpeed();
	}

	void limitSpeed() {
		if (speed > topSpeed)
			speed = topSpeed;
	}

	// Zmienne naleÅ¼Ä…ce do klasy
	float topSpeed = 200;
	float acceleration = 50;
	float speed = 0;
	// reszta...
};
```

</TabItem>
<TabItem value="good2" label="âœ” Dobrze (zachowana kolejnoÅ›Ä‡)">

KolejnoÅ›Ä‡ funkcji i zmiennych jest ustawiona wedÅ‚ug ich uÅ¼ycia - rÃ³wnieÅ¼ poprawne.

```cpp
struct Car
{
	// Zmienne naleÅ¼Ä…ce do klasy
	float topSpeed = 200;
	float acceleration = 50;
	float speed = 0;
	// reszta...

	void limitSpeed() {
		if (speed > topSpeed)
			speed = topSpeed;
	}

	// funkcja zwiÄ™kszajÄ…ca prÄ™dkoÅ›Ä‡
	void accelerate()
	{
		speed += acceleration;
		limitSpeed();
	}
};
```

</TabItem>
<TabItem value="bad" label="âŒ Å¹le">

Poza strukturÄ…, taka zmiana kolejnoÅ›ci jest niedozwolona, bez uÅ¼ycia osobnej deklaracji:  

```cpp
// WyÅ›wietl "Hello, World!"
void printHelloWorld()
{
	// âŒ BÅ‚Ä…d, uÅ¼ycie funkcji `world` przed definicjÄ…
	// error-next-line
	std::cout << "Hello, " << world();
}

// ZwrÃ³Ä‡ napis "World!"
std::string world()
{
	return "World!";
}
```

</TabItem>
</Tabs>


### Deklaracja i definicja

Podobnie jak w przypadku funkcji, moÅ¼emy rozdzieliÄ‡ deklaracjÄ™ i definicjÄ™ metody.
DziÄ™ki temu jesteÅ›my w stanie przenieÅ›Ä‡ ich definicje poza ciaÅ‚o struktury:

```cpp
struct Car
{
	// Zmienne naleÅ¼Ä…ce do klasy
	float topSpeed = 200;
	float acceleration = 50;
	float speed = 0;
	// reszta...

	// Deklaracje metod:
	// highlight-start
	void limitSpeed();
	void accelerate();
	// highlight-end
};

// highlight-next-line
void Car::limitSpeed()
{
	if (speed > topSpeed)
		speed = topSpeed;
}

// highlight-next-line
void Car::accelerate()
{
	speed += acceleration;
	limitSpeed();
}
```

ZauwaÅ¼, Å¼e w takim przypadku poprzedzamy nazwÄ™ metody nazwÄ… struktury - `Car`,
oraz podwÃ³jnym dwukropkiem - `::`, czyli tzw. operatorem zakresu (ang.: *scope resolution operator*).

```cpp title="Schemat definicji poza ciaÅ‚em struktury"
typ NazwaStruktury::nazwaMetody(parametry)
{
	// ...
}
```

Jednym z plusÃ³w takiego zapisu jest moÅ¼liwoÅ›Ä‡ rozdzielenia *interfejsu*
struktury od *implementacji*. DziÄ™ki temu, gdy raz zaimplementujesz
jej metody, za kaÅ¼dym kolejnym razem bÄ™dziesz przeglÄ…daÄ‡ tylko zestaw
nazw zmiennych i metod, z ktÃ³rych bÄ™dziesz korzystaÄ‡, bez rozpraszania siÄ™
szczegÃ³Å‚ami implementacji.

Ten zapis jest teÅ¼ kluczowy przy dzieleniu kodu na wiele plikÃ³w - powiemy
o tym dalej w kursie.

## PrzykÅ‚ady

### Aggregate initialization
C++ wyrÃ³Å¼nia wiele rÃ³Å¼nych rodzajÃ³w typÃ³w - typy fundamentalne (*ang. fundamental types*),
typy trywialne (*ang. trivial types*), typy nietrywialne (*ang. non-trivial types*), typy "agregatowe" (*ang. aggregate types*).

Proste struktury jakie poznaliÅ›my w dzisiejszej lekcji naleÅ¼Ä… wÅ‚aÅ›nie do typÃ³w "agregatowych", co oznacza, Å¼e moÅ¼emy je inicjalizowaÄ‡ za pomocÄ… *aggregate initialization*.
W skrÃ³cie oznacza to, Å¼e zamiast
```cpp
int main()
{
	Car car;
	car.brand = "Ford";
	car.model = "Focus";
	car.yearOfProduction = 2010;
}
```
moglibyÅ›my po prostu zrobiÄ‡ jedno z poniÅ¼szych:

<Tabs>
<TabItem value="direct" label="Metoda 1">

```cpp
int main()
{
	Car car{"Ford", "Focus", 2010};
}
```

</TabItem>
<TabItem value="copy" label="Metoda 2">

```cpp
int main()
{
	Car car = {"Ford", "Focus", 2010};
}
```

</TabItem>
<TabItem value="copy2" label="Metoda 3">

```cpp
int main()
{
	Car car = Car{"Ford", "Focus", 2010};
}
```

</TabItem>
</Tabs>

MoÅ¼emy rÃ³wnieÅ¼ zastosowaÄ‡ tutaj skÅ‚adniÄ™ z `auto`:
```cpp
int main()
{
	auto car = Car{"Ford", "Focus", 2010};
}
```

OczywiÅ›cie kolejnoÅ›Ä‡ argumentÃ³w podawanych w nawiasie odpowiada kolejnym skÅ‚adowym struktury, w tym przypadku:
 - `Car::brand` zostanie zainicjalizowane wartoÅ›ciÄ… **"Ford"**
 - `Car::model` zostanie zainicjalizowane wartoÅ›ciÄ… **"Focus"**
 - `Car::yearOfProduction` zostanie zainicjalizowane wartoÅ›ciÄ… **2010**


### Designated initializers (C++20)

Od C++20 dostajemy rÃ³wnieÅ¼ funkcjonalnoÅ›Ä‡, ktÃ³ra pozwala nam jasno powiedzieÄ‡ jakie pola chcemy zainicjalizowaÄ‡.
Pola musimy wymieniaÄ‡ w tej samej kolejnoÅ›ci w jakiej sÄ… one zadeklarowane w strukturze:

```cpp title="UÅ¼ycie designated initializer"
int main()
{
	auto car = Car {
		.brand = "Ford",
		.model = "Focus",
		.yearOfProduction = 2010
	};
}
```

OczywiÅ›cie nowe linie sÄ… tutaj opcjonalne i moÅ¼na wszystko daÄ‡ w jednej linii, aczkolwiek takie podejÅ›cie jest znacznie bardziej czytelne.
GÅ‚Ã³wnymi tego zastosowaniami sÄ… czytelnoÅ›Ä‡ i pomijanie inicjalizacji niektÃ³rych pÃ³l.
Np. jeÅ›li chcemy na ten moment pominÄ…Ä‡ inicjalizacjÄ™ pola `brand`, moÅ¼emy to zrobiÄ‡ na dwa sposoby.

Pierwszy, nadajÄ…c wartoÅ›Ä‡ po zadeklarowaniu obiektu:
<Tabs>
<TabItem value="with-auto" label="Z auto">

```cpp
int main()
{
	auto car = Car();
	car.model = "Focus";
	car.yearOfProduction = 2010;
}
```

</TabItem>

<TabItem value="without-auto" label="Bez auto">

```cpp
int main()
{
	Car car;
	car.model = "Focus";
	car.yearOfProduction = 2010;
}
```

</TabItem>
</Tabs>

Lub drugi, uÅ¼ywajÄ…c *designated initializers*:

<Tabs>
<TabItem value="with-auto" label="Z auto">

```cpp
int main()
{
	auto car = Car {
		.model = "Focus",
		.yearOfProduction = 2010
	};
}
```

</TabItem>

<TabItem value="without-auto" label="Bez auto">

```cpp
int main()
{
	Car car = {
		.model = "Focus",
		.yearOfProduction = 2010
	};

	Car car2 = Car { // rÃ³wnieÅ¼ poprawne
		.model = "Focus",
		.yearOfProduction = 2010
	};
}
```

</TabItem>
</Tabs>

<ImproveSection />

## Potencjalne bÅ‚Ä™dy

### Brak typu struktury przy deklarowaniu metody poza niÄ…

NaleÅ¼y pamiÄ™taÄ‡, Å¼e kiedy deklarujemy metodÄ™ poza strukturÄ…:
```cpp title="Deklaracja metody poza strukturÄ…"
struct Woobledooble {
	int wooblines;
	int skadoodle();
};

int Woobledooble::skadoodle()
{
	return 5;
}

int main()
{}
```

Trzeba uwzglÄ™dniÄ‡ informacjÄ™ do jakiej struktury ta metoda naleÅ¼y.
JeÅ›li o tym zapomnimy, to nasza struktura formalnie nie bÄ™dzie miaÅ‚a danej metody, tylko bÄ™dzie to wolna funkcja.

```cpp title="âŒ Brak specyfikacji typu struktury"
struct Mage {
	int level = 0;
	// ...
	void levelUp();
};

// highlight-next-line
void levelUp() {
	level++;
}

int main()
{
	Mage chris;
	chris.levelUp();
}
```

#### ğŸ”´ TreÅ›Ä‡ bÅ‚Ä™du

<Tabs groupId="compiler">
<TabItem value="clang" label="CLANG" default>

```plaintext
error: use of undeclared identifier 'level'
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Ilustracja bÅ‚Ä™du - brak typu struktury"
		src="/img/tutorials/course/basic/methods/error-no-struct-scope-specified-clang.png"
	/>

</TabItem>
<TabItem value="gcc" label="GCC" default>

```plaintext
error: â€˜levelâ€™ was not declared in this scope; did you mean â€˜levelUpâ€™?
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Ilustracja bÅ‚Ä™du - brak typu struktury"
		src="/img/tutorials/course/basic/methods/error-no-struct-scope-specified-gcc.png"
	/>

</TabItem>
<TabItem value="msvc" label="MSVC">

```plaintext
error C2065: 'level': undeclared identifier
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Ilustracja bÅ‚Ä™du - brak typu struktury"
		src="/img/tutorials/course/basic/methods/error-no-struct-scope-specified-msvc.png"
	/>

</TabItem>
</Tabs>