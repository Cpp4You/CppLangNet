---
sidebar_position:	9
sidebar_label:		"9. Metody"
title:				"Metody"
description:		"Lekcja: podstawy metod w jÄ™zyku C++"
tags:				[metoda, konstruktor, destruktor, struktura, klasa, obiekt, programowanie-obiektowe, oop]
hide_title:			true
---

<!-- Components -->
import Columns			from '@site-comps/Columns';
import Tabs				from '@theme/Tabs';
import TabItem			from '@theme/TabItem';

<!--  Presets -->
import NotFinished		from '@site/i18n/pl/presets/NotFinished.mdx';
import ImproveSection	from '@site/i18n/pl/presets/ImproveSection.mdx';

<NotFinished/>

# Metody

Ta lekcja pokaÅ¼e Ci, jak umieszczaÄ‡ funkcje wewnÄ…trz struktury, czyli tworzyÄ‡ tzw. metody.

## Motywacja

W programowaniu czÄ™sto odwzorowuje siÄ™ obiekty z Å¼ycia, np. podczas tworzenia gry wyÅ›cigowej ğŸ
bÄ™dziemy chcieli umiesciÄ‡ pojazdy, ktÃ³re bÄ™dÄ… definiowane poprzez swoje

- **cechy**, np.:
	- markÄ™
	- model ğŸš˜
	- maks. prÄ™dkoÅ›Ä‡ ğŸš€
- **zachowania**, np.:
	- przyspieszanie ğŸ’¨
	- hamowanie ğŸ›‘

Ten sposÃ³b opisywania obiektÃ³w, rozdzielajÄ…cy cechy i zachowania, jest bardzo powszechny.
W lekcji o [strukturach](../structures) uczyliÅ›my siÄ™ jak zawieraÄ‡ rÃ³Å¼ne informacje
o obiektach wewnÄ…trz jednego typu, ktÃ³ry sami stworzyliÅ›my. W ten sposÃ³b opisaliÅ›my
jego **cechy**. Teraz przejdziemy do metod, ktÃ³re pozwolÄ… nam "nauczyÄ‡" obiekt
wykonywaÄ‡ konkretne zadania - okreÅ›lÄ… jego **zachowanie**. 

## Wprowadzenie

Na potrzeby tej lekcji stwÃ³rzmy strukturÄ™, ktÃ³ra zawiera cechy samochodu:

```cpp
struct Car
{
	// informacje o pojeÅºdzie
	std::string	brand;
	std::string	model;
	int			yearOfProduction;

	// poruszanie siÄ™
	float		topSpeed = 200;		// max. prÄ™dkoÅ›Ä‡ (km/h)
	float		acceleration = 50;	// przyspieszenie (km/h na sekundÄ™)
	float		speed = 0;			// aktualna prÄ™dkoÅ›Ä‡ (km/h)
};
```

WewnÄ…trz funkcji `main` stwÃ³rzmy obiekt tej struktury:

```cpp
int main()
{
	Car car;
	car.brand = "Ford";
	car.model = "Focus";
	car.yearOfProduction = 2010;

}
```

Teraz przejdziemy do tego, jak zmusiÄ‡ go (`car`) do dziaÅ‚ania.

## Tworzenie i uÅ¼ywanie metod

WewnÄ…trz struktury `Car`, na jej koniec, umieÅ›Ä‡my funkcjÄ™, o nazwie `accelerate`,
ktÃ³ra bÄ™dzie zwiÄ™kszaÅ‚a `speed` o wartoÅ›Ä‡ przyspieszenia `acceleration`:

```cpp
struct Car
{
	// informacje o pojeÅºdzie
	std::string	brand;	
	// ...

	// funkcja zwiÄ™kszajÄ…ca prÄ™dkoÅ›Ä‡
	// highlight-next-line
	void accelerate()
	{
		speed += acceleration;
	}
};
```

:::important Definicja
**Metodami** nazywamy funkcje, ktÃ³re naleÅ¼Ä… do struktur (lub klas, z ktÃ³rymi zapoznasz siÄ™ dalej w kursie).
:::

Tak utworzonÄ… metodÄ™, moÅ¼emy wywoÅ‚aÄ‡ na obiekcie, w ten sposÃ³b:

<Columns columns={['2fr', '1fr']}>
<div>

```cpp title="ğŸ”¹ WywoÅ‚anie metody accelerate()"
// ...

int main()
{
	Car car;
	// poczÄ…tkowe wartoÅ›ci...

	// wywoÅ‚anie po raz pierwszy
	// highlight-next-line
	car.accelerate();
	std::cout << "Aktualna prÄ™dkoÅ›Ä‡: " << car.speed << " km/h\n";
	// wywoÅ‚anie po raz drugi
	// highlight-next-line
	car.accelerate();
	std::cout << "Aktualna prÄ™dkoÅ›Ä‡: " << car.speed << " km/h\n";
}
```

</div>
<div>

```plaintext title="Wynik"
Aktualna prÄ™dkoÅ›Ä‡: 50 km/h
Aktualna prÄ™dkoÅ›Ä‡: 100 km/h
```

</div>
</Columns>

Podajemy nazwÄ™ obiektu, ktÃ³ry ma wykonaÄ‡ danÄ… rzecz, nastÄ™pnie po kropce
podajemy nazwÄ™ metody i parametry - tak jak przy wywoÅ‚aniu zwykÅ‚ej funkcji.

<Columns columns={['1fr', '1fr']}>
<div>

```cpp title="ğŸ”¸ WywoÅ‚anie metody"
obiekt.nazwaMetody(argumenty);
```

</div>
<div>

```cpp title="ğŸ”¹ WywoÅ‚anie funkcji"
nazwaFunkcji(argumenty);
```

</div>
</Columns>

### KolejnoÅ›Ä‡ definicji

WewnÄ…trz struktury, metody nie muszÄ… byÄ‡ zdefiniowane przed deklaracjÄ… zmiennej lub innej metody,
ktÃ³ra teÅ¼ do tej struktury naleÅ¼y:

<Tabs>
<TabItem value="good1" label="âœ” Dobrze" default>

ZwrÃ³Ä‡ uwagÄ™ na kolejnoÅ›Ä‡ definiowania metod: `limitSpeed` zostaÅ‚a uÅ¼yta w `accelerate`,
mimo Å¼e jej definicja znajduje siÄ™ niÅ¼ej. Podobnie pola `speed` oraz `acceleration`,
zostaÅ‚y uÅ¼yte przed ich deklaracjÄ…, bo znajduje siÄ™ ona w kodzie **pod** tym uÅ¼yciem.
W ramach struktury jest to dozwolone.

```cpp
struct Car
{
	// funkcja zwiÄ™kszajÄ…ca prÄ™dkoÅ›Ä‡
	void accelerate()
	{
		speed += acceleration;
		limitSpeed();
	}

	void limitSpeed() {
		if (speed > topSpeed)
			speed = topSpeed;
	}

	// Zmienne naleÅ¼Ä…ce do klasy
	float topSpeed = 200;
	float acceleration = 50;
	float speed = 0;
	// reszta...
};
```

</TabItem>
<TabItem value="good2" label="âœ” Dobrze (zachowana kolejnoÅ›Ä‡)">

KolejnoÅ›Ä‡ funkcji i zmiennych jest ustawiona wedÅ‚ug ich uÅ¼ycia - rÃ³wnieÅ¼ poprawne.

```cpp
struct Car
{
	// Zmienne naleÅ¼Ä…ce do klasy
	float topSpeed = 200;
	float acceleration = 50;
	float speed = 0;
	// reszta...

	void limitSpeed() {
		if (speed > topSpeed)
			speed = topSpeed;
	}

	// funkcja zwiÄ™kszajÄ…ca prÄ™dkoÅ›Ä‡
	void accelerate()
	{
		speed += acceleration;
		limitSpeed();
	}
};
```

</TabItem>
<TabItem value="bad" label="âŒ Å¹le">

Poza strukturÄ…, taka zmiana kolejnoÅ›ci jest niedozwolona, bez uÅ¼ycia osobnej deklaracji:  

```cpp
// WyÅ›wietl "Hello, World!"
void printHelloWorld()
{
	// âŒ BÅ‚Ä…d, uÅ¼ycie funkcji `world` przed definicjÄ…
	// highlight-next-line
	std::cout << "Hello, " << world();
}

// ZwrÃ³Ä‡ napis "World!"
std::string world()
{
	return "World!"
}
```

</TabItem>
</Tabs>


### Deklaracja i definicja

Podobnie jak w przypadku funkcji, moÅ¼emy rozdzieliÄ‡ deklaracjÄ™ i definicjÄ™ metody.
DziÄ™ki temu jesteÅ›my w stanie przenieÅ›Ä‡ ich definicje poza ciaÅ‚o struktury:

```cpp
struct Car
{
	// Zmienne naleÅ¼Ä…ce do klasy
	float topSpeed = 200;
	float acceleration = 50;
	float speed = 0;
	// reszta...

	// Deklaracje metod:
	// highlight-start
	void limitSpeed();
	void accelerate();
	// highlight-end
};

// highlight-next-line
void Car::limitSpeed()
{
	if (speed > topSpeed)
		speed = topSpeed;
}

// highlight-next-line
void Car::accelerate()
{
	speed += acceleration;
	limitSpeed();
}
```

ZauwaÅ¼, Å¼e w takim przypadku poprzedzamy nazwÄ™ metody nazwÄ… struktury - `Car`,
oraz podwÃ³jnym dwukropkiem - `::`, czyli tzw. operatorem zakresu (ang.: *scope resolution operator*).

```cpp title="ğŸ”¹ Schemat definicji poza ciaÅ‚em struktury"
typ NazwaStruktury::nazwaMetody(parametry)
{
	// ...
}
```

Jednym z plusÃ³w takiego zapisu jest moÅ¼liwoÅ›Ä‡ rozdzielenia *interfejsu*
struktury od *implementacji*. DziÄ™ki temu, gdy raz zaimplementujesz
jej metody, za kaÅ¼dym kolejnym razem bÄ™dziesz przeglÄ…daÄ‡ tylko zestaw
nazw zmiennych i metod, z ktÃ³rych bÄ™dziesz korzystaÄ‡, bez rozpraszania siÄ™
szczegÃ³Å‚ami implementacji.

Ten zapis jest teÅ¼ kluczowy przy dzieleniu kodu na wiele plikÃ³w - powiemy
o tym dalej w kursie.

## PrzykÅ‚ady

<ImproveSection />

## Potecjalne bÅ‚Ä™dy

<ImproveSection />