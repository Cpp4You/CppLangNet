---
sidebar_position:	2
sidebar_label:		ğŸ² LosowoÅ›Ä‡
title:				Liczby pseudolosowe
tags:				[losowoÅ›Ä‡, liczby-pseudolosowe]
description:		"ArtykuÅ‚ (podstawy): liczby pseudolosowe w jÄ™zyku C++"
hide_title:			true
---

<!-- Components -->
import Tabs					from "@theme/Tabs";
import TabItem				from "@theme/TabItem";
import Columns				from "@site-comps/Columns";
import CustomCodeBlock		from "@site-comps/CustomCodeBlock";
import Image				from "@site-comps/Image";
import Replit				from "@site-comps/Replit";

<!-- Presets -->
import NotFinished			from "@site/i18n/pl/presets/NotFinished.mdx";

# Liczby pseudolosowe

<center>
	<iframe src='https://gfycat.com/ifr/DarkBrokenCivet' frameBorder='0' scrolling='no' allowFullScreen width='640' height='404'></iframe>
</center>

<br/>

Wymaga znajomoÅ›ci: [**1. Pierwszy program**](../../first-program) - [**7. Funkcje**](../../functions)

## Motywacja

W rÃ³Å¼nych dziedzinach informatyki, np. w kryptografii, cyberbezpieczeÅ„stwie
czy przy tworzeniu gier komputerowych, potrzebna jest moÅ¼liwoÅ›c generowania
losowych liczb. PrzykÅ‚adowo:

- ğŸ”‘ tworzenie hasÅ‚a z losowych znakÃ³w
- ğŸ’¥ losowe zdarzenia w Å›wiecie gry
- ğŸ² szansa na zadanie obraÅ¼eÅ„ oparta na rzucie kostkÄ…


## Dlaczego "pseudolosowe"

Jak moÅ¼esz zauwaÅ¼yÄ‡, artykuÅ‚ nazywa siÄ™ "liczby **pseudo**losowe".
Komputer nie jest w stanie samodzielnie wygenerowaÄ‡ prawdziwie losowych liczb
jednak moÅ¼e, za pomocÄ… pewnych sztuczek, daÄ‡ nam zÅ‚udzenie losowoÅ›ci,
ktÃ³ra jest jak najbardziej wystarczajÄ…ca.

## Generowanie liczb

:::caution Uwaga
W tym artykule skupimy siÄ™ na bardzo prymitywnym, ale jednoczeÅ›nie Å‚atwym
sposobie. W dalszej czÄ™Å›ci kursu poznasz duÅ¼o potÄ™Å¼niejsze narzÄ™dzia, pochodzÄ…ce z
biblioteki `<random>`. Wtedy z `std::rand` naleÅ¼y zrezygnowaÄ‡.
:::

W tym artykule bÄ™dziemy korzystaÄ‡ z poniÅ¼szych nagÅ‚Ã³wkÃ³w:

```cpp title="ğŸ”¹ Potrzebne nagÅ‚Ã³wki"
#include <cstdlib>
#include <ctime>
```

Zobaczmy na przykÅ‚adzie jak z tego siÄ™ korzysta:

<Columns columns={['8fr', '4fr']}>
<div>

```cpp title="ğŸ”¹ Losowanie 5 liczb"
#include <iostream>
#include <cstdlib>
#include <ctime>

int main() {
	// highlight-next-line
	std::srand( std::time(0) );

	std::cout << "GenerujÄ™ 5 losowych liczb:\n";
	for (int i = 0; i < 5; ++i)
	// highlight-next-line
		std::cout << std::rand() << '\n';
}
```

</div>
<div>

```plaintext title="PrzykÅ‚adowy wynik"
GenerujÄ™ 5 losowych liczb:
570368048
1028036926
1798519773
2028832115
1034913436
```

</div>
</Columns>

### Uzyskiwanie kolejnych liczb

KluczowÄ… funkcjÄ… jest tutaj
```cpp
std::rand()
```
(od ang. *random*), ktÃ³ra generuje i zwraca
kolejnÄ… pseudolosowÄ… liczbÄ™ z sekwencji. Taka sekwencja jest bardzo
nieprzewidywalna, co daje zÅ‚udzenie losowoÅ›ci.

### Ustawianie ziarna

To z jakich liczb bÄ™dzie ta sekwencja siÄ™ skÅ‚adaÄ‡ zaleÅ¼y od tzw. **ziarna** (*ang.: seed*),
ktÃ³re rÃ³wnieÅ¼ jest pewnÄ… liczbÄ…. Do ustawiania ziarna sÅ‚uÅ¼y funkcja:

```cpp title="ğŸ”¹ Ustawianie ziarna"
std::srand( <ziarno> )
```
(od ang. *seed random*)


:::danger Uwaga
JeÅ›li pozostawimy domyÅ›lne ziarno, generowana sekwencja bÄ™dzie **zawsze taka sama**.
:::

Dobrym pomysÅ‚em jest ustawianie go **raz, na poczÄ…tku programu**, tak jak w przykÅ‚adzie.
Za ziarno posÅ‚uÅ¼yÅ‚ nam aktualny czas, w formie liczby, ktÃ³ra zwiÄ™ksza siÄ™ z kaÅ¼dÄ… sekundÄ…, dlatego
za kaÅ¼dym uruchomieniem programu dostaniemy inny efekt. UzyskaliÅ›my to za pomocÄ… wywoÅ‚ania funkcji:

```cpp title="ğŸ”¹ Aktualny czas (w sekundach)"
std::time(0)
```

### Wady `std::rand`

Funkcja `std::rand()` jest prosta w uÅ¼yciu i wÅ‚aÅ›ciwie na tym jej zalety siÄ™ koÅ„czÄ…. Problemem jest m.in. to,
Å¼e zakres zwracanych przez niÄ… liczb nie jest Å›ciÅ›le okreÅ›lony i rÃ³Å¼ni siÄ™ w zaleÅ¼noÅ›ci
np. od uÅ¼ytego kompilatora czy systemu operacyjnego.

MoÅ¼emy byÄ‡ jedynie pewni tego, Å¼e zwrÃ³cona liczba jest zawsze z zakresu `[0; RAND_MAX]`,
przy czym to `RAND_MAX` to pewna staÅ‚a, zaleÅ¼na od systemu czy kompilatora (nie mniejsza niÅ¼ `32767`).

<Image center alt="Zakres od 0 do RAND_MAX"
		src="/img/tutorials/course/basic/random/0_to_rand_max.png"
	/>
<br/>

To jakÄ… wartoÅ›Ä‡ ma `RAND_MAX` moÅ¼na banalnie sprawdziÄ‡:

```cpp title="ğŸ”¹ Sprawdzanie maks. moÅ¼liwej liczby do uzyskania z rand"
#include <iostream>
#include <cstdlib>

int main() {
	std::cout << "RAND_MAX: " << RAND_MAX;
}
```

MoÅ¼liwy wynik:

<Tabs>
<TabItem value="msvc-windows" label="MSVC (Windows)" default>
Wersja z Visual Studio 2022 Preview.

```plaintext
RAND_MAX: 32767
```

</TabItem>
<TabItem value="gcc-windows" label="GCC 11.2 (Windows)">
Wersja GCC 11.2 z paczki MSYS2.

```plaintext
RAND_MAX: 32767
```

</TabItem>
<TabItem value="gcc-wandbox" label="GCC 12.0 (Linux)">
GCC 12.0.0, ze strony [https://wandbox.org](https://wandbox.org)

```plaintext
RAND_MAX: 2147483647
```

</TabItem>
<TabItem value="clang-wandbox" label="Clang 13.0 (Linux)">
Clang 13.0.0, ze strony [https://wandbox.org](https://wandbox.org)

```plaintext
RAND_MAX: 2147483647
```

</TabItem>
</Tabs>

PowyÅ¼sze wyniki jasno ukazujÄ… ten problem.
Na Windowsie uzyskaliÅ›my wynik 2<sup>15</sup> - 1, a na Linuxie 2<sup>31</sup> - 1

### Ograniczanie zakresu liczb

WiedzÄ…c, Å¼e `std::rand()` daje nam liczby z zakresu `[0; RAND_MAX]`, moÅ¼emy siÄ™
tym trochÄ™ "pobawiÄ‡".

#### Liczby rzeczywiste od `0` do `1`

<Image center alt="Zakres od 0 do 1"
		src="/img/tutorials/course/basic/random/0_to_1.png"
	/>
<br/>

Wystarczy podzieliÄ‡ uzyskanÄ… liczbÄ™, przez `RAND_MAX`, by uzyskaÄ‡ wartoÅ›Ä‡
z zakresu od `0` do `1`.

```cpp title="ğŸ”¹ Liczba od 0 do 1"
float randomFloat() {
	return float( std::rand() ) / RAND_MAX;
}
```

:::danger Rzutowanie na float
ZwrÃ³Ä‡ uwagÄ™, Å¼e **musimy** skonwertowaÄ‡ co najmniej jednÄ… z tych liczb
na typ `float`. Obie z tych rzeczy - `RAND_MAX` oraz `rand()` sÄ…
liczbami caÅ‚kowitymi, w zwiÄ…zku z tym operacje na nich dajÄ…
rÃ³wnieÅ¼ liczbÄ™ caÅ‚kowitÄ….
W uproszczeniu:
```cpp
int / int = int
```

Po konwersji bÄ™dzie to wyglÄ…daÄ‡ tak:
```cpp
float / int = float
```
:::

JeÅ›li siÄ™ zastanawiasz dlaczego to tak dziaÅ‚a, zobacz tÄ… prostÄ… analizÄ™:
- dla liczby `0` dostaniemy `0 / RAND_MAX`, czyli nadal `0`
- dla `RAND_MAX` (czyli maks. liczby) dostaniemy `RAND_MAX / RAND_MAX`, czyli `1`
- dla wszystkich wartoÅ›ci poÅ›rednich uzyskamy liczbÄ™ wiÄ™kszÄ… od `0` i mniejszÄ… od `1`

#### Liczby rzeczywiste od `A` do `B`

<Image center alt="Zakres od A do B"
		src="/img/tutorials/course/basic/random/a_to_b.png"
	/>
<br/>

KorzystajÄ…c z poprzedniej funkcji `randomFloat()`, moÅ¼emy
zdefiniowaÄ‡ podobnÄ… funkcje, ktÃ³ra wygeneruje liczbÄ™ rzeczywistÄ…
w zakresie od `A` do `B`.

Co musimy zrobiÄ‡:
- obliczyÄ‡ nowego zakresu, `float Length = B - A`
- pomnoÅ¼yÄ‡ liczbÄ™ `[0; 1]` przez tÄ… dÅ‚ugoÅ›Ä‡, by uzyskaÄ‡ zakres `[0; Length]`
- przesunÄ…Ä‡ caÅ‚y zakres o `A`, by uzyskaÄ‡: `[A; Length + A]`, czyli `[A; B]`

```cpp title="ğŸ”¹ Liczba rzeczywista w zakresie"
// MoÅ¼emy uÅ¼yÄ‡ tej samej nazwy, bo mamy
// inne parametry (przeÅ‚adowanie funkcji)
float randomFloat(float from, float to)
{
	float length = to - from;

	return randomFloat()*length + from;
}
```

lub upraszczajÄ…c:

```cpp title="ğŸ”¹ Liczba rzeczywista w zakresie (uproszczone)"
float randomFloat(float from, float to)
{
	return randomFloat()*(to - from) + from;
}
```

#### Liczby caÅ‚kowite od `A` do `B`

W dokÅ‚adnie ten sam sposÃ³b co powyÅ¼ej, moÅ¼emy utworzyÄ‡ funkcjÄ™ `randomInt`:

```cpp title="ğŸ”¹Liczba caÅ‚kowita w zakresie"
int randomInt(int from, int to)
{
	return int( randomFloat()*(to - from) ) + from;
}
```

## PrzykÅ‚ady uÅ¼ycia

### Funkcje z tego artykuÅ‚u

Korzystanie z wyÅ¼ej utworzonych funkcji jest bardzo proste i wygodne:

<Tabs>
<TabItem value="source" label="PeÅ‚en kod" default>

<CustomCodeBlock lineNumbers maxLines={30}>

```cpp
#include <iostream>
#include <cstdlib>
#include <ctime>
#include <iomanip>

// Deklaracja funkcji
float	randomFloat(); // od 0 do 1
float	randomFloat(float from, float to); // od "from" do "to"
int		randomInt(int from, int to); // od "from" do "to" (int)

int main()
{
	// Ustawienie ziarna
	std::srand( std::time(0) );

	// Ustawiam precyzjÄ™ wyÅ›wietlania float-Ã³w
	std::cout << std::fixed;
	std::cout.precision(2);

	std::cout << "LosujÄ™ 5 liczb od 0 do 1:\n";
	for (int i = 0; i < 5; ++i)
		std::cout << randomFloat() << ' ';

	std::cout << "\n\nLosujÄ™ 5 float-Ã³w od 10 do 30:\n";
	for (int i = 0; i < 5; ++i)
		std::cout << randomFloat(10, 30) << ' ';

	std::cout << "\n\nLosujÄ™ 5 int-Ã³w od 0 do 100:\n";
	for (int i = 0; i < 5; ++i)
		std::cout << randomInt(0, 100) << ' ';

	std::cout << std::endl;
}


// Definicja funkcji do losowania
/////////////////////////////////////
float randomFloat()
{
	return float( std::rand() ) / RAND_MAX;
}

/////////////////////////////////////
float randomFloat(float from, float to)
{
	return randomFloat()*(to - from) + from;
}

/////////////////////////////////////
int randomInt(int from, int to)
{
	return int( randomFloat()*(to - from) ) + from;
}
```

</CustomCodeBlock>
</TabItem>
<TabItem value="try-it" label="Uruchom â–¶">
	<Replit.PlayInfo />
	<Replit embed fullwidth user="poetakodu" repl="Random-Numbers-Test" />
</TabItem>
</Tabs>

### Losowa szansa na zdarzenie

JeÅ›li chcemy, by pewne zdarzenie miaÅ‚o np. 30% szans na wystÄ…pienie,
moÅ¼emy wylosowaÄ‡ liczbÄ™ caÅ‚kowitÄ… z zakresu `[1; 100]` i sprawdziÄ‡,
czy `liczba <= 30`:

```cpp title="ğŸ² Losowa szansa (30%)"
int randomChance = randomInt(1, 100);

if (randomChance <= 30)
{
	std::cout << "Wygrana :)";
}
else
{
	std::cout << "Przegrana :(";
}
```

MoÅ¼esz teÅ¼ zrezygnowaÄ‡ z procentÃ³w i uÅ¼yÄ‡ zwykÅ‚ych uÅ‚amkÃ³w:

```cpp title="ğŸ² Losowa szansa (30%)"
float randomChance = randomFloat();

if (randomChance <= 0.30f)
{
	std::cout << "Wygrana :)";
}
else
{
	std::cout << "Przegrana :(";
}
```