---
sidebar_label:		 System plik贸w
title:				System plik贸w
tags:				[system plik贸w, plik, filesystem,]
description:		"Artyku (podstawy): korzystanie z systemu plik贸w w jzyku C++"
hide_title:			true
---

<!-- Components -->
import Tabs					from "@theme/Tabs";
import TabItem				from "@theme/TabItem";
import Details				from "@theme/Details";
import Columns				from "@site-comps/Columns";
import CustomCodeBlock		from "@site-comps/CustomCodeBlock";
import Image				from "@site-comps/Image";
import Replit				from "@site-comps/Replit";

<!-- Examples -->
import Example_FilesystemAliasGlobal		from "./_codes/files/example-filesystem-alias-global.mdx";
import Example_FilesystemAliasWithinFunc	from "./_codes/files/example-filesystem-alias-within-func.mdx";

# System plik贸w

Wymaga znajomoci: [**1. Pierwszy program**](../../first-program) - [**9. Metody**](../../methods) oraz [**11. Referencje**](../../references)
oraz artykuu o [obsudze plik贸w](../files).

W tym artykule poka偶emy Ci jak poprawnie korzysta z systemu plik贸w w jzyku C++.

## Motywacja

Korzystanie z systemu plik贸w jest czsto niezbdn czci aplikacji. Programy przechowuj swoje dane
na dysku komputerowym. Aplikacje biurowe zapisuj dokumenty utworzone przez u偶ytkownika.
Czsto korzystaj z plik贸w konfiguracyjnych, kt贸re r贸wnie偶 znajduj si na dysku. Gry wideo trzymaj modele, d藕wiki,
tekstury i inn tego typu zawarto wewntrz swoich plik贸w.

## Wstp

Do obsugi systemu plik贸w bdziemy korzystali z nag贸wka z biblioteki standardowej:

```cpp
#include <filesystem>
```

Dziki niemu bdziemy mogli m.in.:

- tworzy i usuwa foldery
- przeglda zawarto folder贸w
- sprawdza rozmiar plik贸w
- sprawdza czy pliki lub foldery istniej

:::caution Wsparcie kompilatora
Upewnij si, 偶e Tw贸j kompilator wspiera wersj jzyka **C++17** i ten tryb wsparcia jest wczony,
poniewa偶 `<filesystem>` zosta dodany do biblioteki standardowej wanie w tej wersji.
:::

### Alias dla filesystem

:::important Uwaga
Ten krok jest opcjonalny.
:::

Ze wzgldu na to, 偶e wszelka funkcjonalno zwizana z `<filesystem>` jest zawarta wewntrz
przestrzeni nazw `std::filesystem`, bdziemy dla wygody u偶ywa aliasu `fs`, kt贸ry tworzymy w ten spos贸b:

```cpp
namespace fs = std::filesystem;
```

Por贸wnanie:

<Tabs>
<TabItem label=" Bez aliasu" value="without-alias" default>

```cpp
std::filesystem::path("file.txt")
std::filesystem::exists("other_file.txt")
std::filesystem::recursive_directory_iterator("folder")
```

</TabItem>
<TabItem label=" Z aliasem" value="with-alias">

```cpp
fs::path("file.txt")
fs::exists("other_file.txt")
fs::recursive_directory_iterator("folder")
```

</TabItem>
</Tabs>


Powy偶szy alias mo偶esz umieci w zale偶noci od preferencji:
- wewntrz funkcji, by ograniczy zakres "dziaania" aliasu do danego bloku kodu
<details>
	<summary>Przykad</summary>
	<div>
		<Example_FilesystemAliasWithinFunc />
	</div>
</details>
- zaraz po instrukcji `#include <filesystem>`, by m贸c u偶ywa go w caym pliku
<details>
	<summary>Przykad</summary>
	<div>
		<Example_FilesystemAliasGlobal />
	</div>
</details>

Przy czym warto podkreli, 偶e pierwszy spos贸b jest bezpieczniejszy i powinien by u偶ywany,
chyba 偶e jeste dobrze zaznajomiony z [przestrzeniami nazw](../../namespaces) i [aliasami](../../aliases)
i masz absolutn pewno, 偶e wiesz co robisz.

### Klasa cie偶ki `path`

```cpp
auto p = fs::path("C:/plik.txt");
```

### Czy plik istnieje

```cpp
auto p = fs::path("plik.txt");
std::cout << "Plik " << p << (fs::exists(p) ? "istnieje" : "nie istnieje") << '\n';
```

### Folder roboczy i relatywne cie偶ki

```cpp
std::cout << fs::current_path() << '\n';
```





### Zawarto folderu



#### Iteracja po zawartoci

```cpp
for (auto entry : fs::directory_iterator("C:/folder"))
{
	std::cout << entry.path() << '\n';
}
```

#### Iteracja rekursywna

```cpp
for (auto entry : fs::recursive_directory_iterator("C:/folder"))
{
	std::cout << entry.path() << '\n';
}
```

## Wicej przykad贸w

