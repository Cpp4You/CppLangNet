---
sidebar_position:	7
sidebar_label:		"7. Funkcje"
title:				"Funkcje"
description:		"Lekcja: funkcje w jÄ™zyku C++"
tags:				[funkcja, wywoÅ‚anie]
hide_title:			true
---

<!-- Presets -->
import NotFinished				from '@site/i18n/pl/presets/NotFinished.mdx';
import ImproveSection			from '@site/i18n/pl/presets/ImproveSection.mdx';

<!-- Components -->
import CustomCodeBlock			from '@site-comps/CustomCodeBlock';
import GoogleSlides				from '@site-comps/GoogleSlides';
import Columns					from '@site-comps/Columns';
import Image					from '@site-comps/Image';
import Tabs						from '@theme/Tabs';
import TabItem					from '@theme/TabItem';

<!-- Codes -->
import Code_TopExampleWithout				from "./_codes/functions/top-example-without.mdx";
import Code_TopExampleWith					from "./_codes/functions/top-example-with.mdx";

import Code_ExampleReuse					from "./_codes/functions/example-reuse.mdx";
import Code_ExampleReuseWithParam			from "./_codes/functions/example-reuse-with-param.mdx";
import Code_ExampleReuseWithParams			from "./_codes/functions/example-reuse-with-params.mdx";

<NotFinished/>

# Funkcje

W tej lekcji dowiesz siÄ™ jak nauczyÄ‡ program wykonywania akcji, z moÅ¼liwoÅ›ciÄ…
ich wielokrotnego uÅ¼ytku.

## Motywacja

Jednym z plusÃ³w uÅ¼ywania funkcji jest redukcja potwÃ³rzeÅ„ w kodzie. Zobacz przykÅ‚ad
poniÅ¼ej, w wersji bez uÅ¼ycia funkcji oraz z uÅ¼yciem. Na ten moment
nie musisz rozumieÄ‡ zapisu z przykÅ‚adu z funkcjÄ… - do wyjaÅ›nienia
przejdziemy w dalszej czÄ™Å›ci tej lekcji.

<hr/>

<Tabs>
	<TabItem value="without-functions" label="âš  Bez funkcji">
		<Code_TopExampleWithout />
	</TabItem>
	<TabItem value="with-function" label="ğŸŸ¢ Z funkcjÄ…">
		<Code_TopExampleWith />
	</TabItem>
</Tabs>

<hr/>

W przykÅ‚adzie powyÅ¼ej tworzymy tablicÄ™ liczb i modyfikujemy jÄ…, kaÅ¼dorazowo wyÅ›wietlajÄ…c zawartoÅ›Ä‡.
RÃ³Å¼nica miÄ™dzy tymi dwoma wersjami jest taka, Å¼e pierwszy zawiera fragment kodu, ktÃ³ry przekleiliÅ›my
parÄ™ razy komendÄ… kopiuj-wklej. W drugiej, bardziej prawidÅ‚owej wersji, jednorazowo **uczymy nasz program
jak wyÅ›wietliÄ‡ tablicÄ™ liczb** a nastÄ™pnie korzystamy z tego wielokrotnie wtedy, kiedy tego potrzebujemy.

Funkcje majÄ… jeszcze bardzo wiele innych zastosowaÅ„ i czÄ™Å›Ä‡ z nich w tej lekcji pokaÅ¼emy. PÃ³ki co jednak
musimy powrÃ³ciÄ‡ na sam poczÄ…tek do podstaw.

## Wprowadzenie

:::important Definicja
Funkcja to wydzielony fragment kodu, ktÃ³ry moÅ¼emy wielokrotnie wykorzystywaÄ‡.
:::

Od samego poczÄ…tku nauki w naszych programach umieszczaliÅ›my specjalnÄ… funkcjÄ™,
ktÃ³rÄ… jest `main`.

```cpp
int main() {
	// kod programu
}
```

Komputer uruchamiajÄ…c program znajduje funkcjÄ™ `main` a nastÄ™pnie jÄ… wykonuje,
przechodzÄ…c po kaÅ¼dej instrukcji wewnÄ…trz, linijka po linijce.

## Tworzenie funkcji

Zaczniemy od najprostszych funkcji, stopniowo przechodzÄ…c do coraz bardziej zaawansowanych.

### Bez parametrÃ³w

<Image center border
		src="/img/tutorials/course/basic/functions/proc-no-params-pl.png"
		desc="Schemat najprostszej funkcji"
	/>

Jak widzimy wyÅ¼ej, definiujÄ…c wÅ‚asnÄ… funkcjÄ™, musimy zadbaÄ‡ o jej nazwÄ™ oraz ciaÅ‚o, trzymajÄ…c
siÄ™ przy tym skÅ‚adni. Po sÅ‚owie `void` piszemy **nazwÄ™ funkcji**, nastÄ™pnie dajemy puste
**nawiasy okrÄ…gÅ‚e** (o tym powiemy dalej w tej lekcji), potem **bez Å›rednika** umieszczamy poniÅ¼ej
blok kodu, ktÃ³ry nazywamy **ciaÅ‚em funkcji**.

:::important Nazewnictwo
NazywajÄ…c funkcjÄ™ przestrzegamy tych samych zasad co przy [nazwach zmiennych](../variables/#nazwa-zmiennej).
:::

W ten sposÃ³b mamy juÅ¼ zdefiniowanÄ… funkcjÄ™. Oznacza to, Å¼e gdy tylko bÄ™dziemy tego chcieli, moÅ¼emy
jÄ… **wywoÅ‚aÄ‡**. Robimy to w ten sposÃ³b:

```cpp title="ğŸ”¹ WywoÅ‚anie funkcji"
print();
```

:::caution Uwaga
ZwrÃ³Ä‡ uwagÄ™, Å¼e umieÅ›ciliÅ›my **Å›rednik** po wywoÅ‚aniu funkcji, bo jest to teÅ¼ koniec instrukcji.
:::

Napiszmy przykÅ‚adowÄ… funkcjÄ™, ktÃ³ra wyÅ›wietla 10 liczb parzystych i uÅ¼yjmy jej kilka razy:

<div>
	<Code_ExampleReuse />
</div>

### Z parametrami

<Image center border
		src="/img/tutorials/course/basic/functions/proc-params-pl.png"
		desc="Schemat funkcji z parametrami"
	/>

DziaÅ‚anie funkcji moÅ¼emy uzaleÅ¼niÄ‡ od **parametrÃ³w**. ChcÄ…c, Å¼eby funkcja wyÅ›wietlaÅ‚a
dowolnie duÅ¼o liczb parzystych, moÅ¼emy utworzyÄ‡ w funkcji parametr,
ktÃ³ry bÄ™dzie to kontrolowaÅ‚. Parametr jest zmiennÄ… wewnÄ…trz funkcji, ktÃ³rÄ… tworzymy
w Å›rodku nawiasÃ³w okrÄ…gÅ‚ych:

<div>
	<Code_ExampleReuseWithParam />
</div>

PowyÅ¼szy zapis

```cpp
printEvenNumbers(10);
```

oznacza, Å¼e w momencie wywoÅ‚ania, do parametru `howMany` wewnÄ…trz tej funkcji
zostanie przypisana wartoÅ›Ä‡ `10`. MoÅ¼emy do funkcji przekazywaÄ‡ dowolnÄ… liczbÄ™ parametrÃ³w.
Oddzielamy je przecinkami:

<div>
	<Code_ExampleReuseWithParams />
</div>

:::danger Popularny bÅ‚Ä…d
ZauwaÅ¼, Å¼e kolejne parametry funkcji umieszczamy po przecinku, kaÅ¼dorazowo podajÄ…c jego typ.
CzÄ™stym bÅ‚Ä™dem wÅ›rÃ³d poczÄ…tkujÄ…cych jest pominiÄ™cie typu w nastÄ™pnych parametrach.

<Tabs>
<TabItem label="âŒ Å¹le" value="bad" default>

```cpp
void printBiggerNumber(int a, b)
```

</TabItem>
<TabItem label="âœ” Dobrze" value="good">

```cpp
void printBiggerNumber(int a, int b)
```

</TabItem>
</Tabs>

:::

### Instrukcja powrotu

MoÅ¼emy kazaÄ‡ programowi wczeÅ›niej powrÃ³ciÄ‡ z funkcji, za pomocÄ… instrukcji:

```cpp
return;
```

W momencie jej napotkania, program przestaje wykonywaÄ‡ kolejne instrukcje w funkcji
i wraca do miejsca, z ktÃ³rego zostaÅ‚a ona wywoÅ‚ana. Przytoczmy stworzonÄ… przez nas wczeÅ›niej
funkcjÄ™ `printEvenNumbers`:

```cpp
void printEvenNumbers(int howMany)
{
	for (int i = 0; i < howMany; i++)
		std::cout << (i * 2) << ' ';
	std::cout << '\n';
}
```

Co siÄ™ stanie, jeÅ›li podamy ujemnÄ… liczbÄ™ do `howMany`?

```cpp
printEvenNumbers(-10);
```

Wykonywanie funkcji z takÄ… wartoÅ›ciÄ… parametru nie ma sensu, dlatego moÅ¼emy to juÅ¼ na samym poczÄ…tku
wychwyciÄ‡ i wykonaÄ‡ powrÃ³t:

```cpp
void printEvenNumbers(int howMany)
{
	if (howMany <= 0)
		return;

	for (int i = 0; i < howMany; i++)
		std::cout << (i * 2) << ' ';
	std::cout << '\n';
}
```

Teraz gdy podamy wartoÅ›Ä‡ mniejszÄ… lub rÃ³wnÄ… zero do parametru funkcji, funkcja juÅ¼ na poczÄ…tku zostanie przerwana.

### WartoÅ›Ä‡ zwracana

<Image center border
		src="/img/tutorials/course/basic/functions/retval-params-pl.png"
		desc="Schemat funkcji z parametrami i wartoÅ›ciÄ… zwracanÄ…"
	/>


Funkcje mogÄ… pozostawiÄ‡ po swoim wykonaniu pewien **rezultat**. Åatwiej bÄ™dzie to zrozumieÄ‡ gdy zastosujemy analogiÄ™ do
realnego Å¼ycia. Rodzic wysyÅ‚a swoje dziecko do sklepu po 10 jajek. Po powrocie dziecka, bÄ™dzie chciaÅ‚ wiedzieÄ‡,
czy udaÅ‚o mu siÄ™ kupiÄ‡ tyle ile poprosiÅ‚, czy nie. Tak samo my, wykonujÄ…c niektÃ³re funkcje w kodzie,
chcemy znaÄ‡ ich rezultat, czyli **wartoÅ›Ä‡ zwracanÄ…**.

#### Typ zwracanej wartoÅ›ci

Wymagane jest, aby okreÅ›liÄ‡ jakiego typu jest wartoÅ›Ä‡ zwracana. Podajemy go **przed** nazwÄ… funkcji, przykÅ‚adowo:

```cpp title="ğŸ”¹ Zwracamy liczbÄ™ caÅ‚kowitÄ…" 
int sum(int from, int to)
```

```cpp title="ğŸ”¹ Brak zwracanej wartoÅ›ci"
void print(int number)
```

ZauwaÅ¼, Å¼e wprowadziliÅ›my nowy typ: `void` (z ang.: *pusty*). JeÅ›li wpiszemy go w miejsce typu zwracanego,
bÄ™dzie to oznaczaÅ‚o, Å¼e funkcja nie zwraca wartoÅ›ci, tj. nie potrzebujemy znaÄ‡ jej rezultatu.
ZauwaÅ¼, Å¼e z `void` korzystaliÅ›my w poprzednich sekcjach tej lekcji, wÅ‚aÅ›nie z tego powodu.

:::danger Typ pusty i zmienne
Typ `void` nie moÅ¼e byÄ‡ uÅ¼yty do stworzenia zmiennej:

```cpp title="âŒ NieprawidÅ‚owy zapis"
void variable;
```

Zmienna z zaÅ‚oÅ¼enia przechowuje wartoÅ›Ä‡, co byÅ‚oby niemoÅ¼liwe gdyby byÅ‚a typu `void`.
:::

#### Zastosowanie

Zaimplementujmy funkcjÄ™ ze schematu wyÅ¼ej. Ma ona zliczyÄ‡ sumÄ™ wszystkich liczb w zakresie od `from` do `to` wÅ‚Ä…cznie.

```cpp
int sum(int from, int to)
{
	int result = 0;
	for (int i = from; i <= to; i++)
		result += i;
	return result;
}
```

ZwrÃ³conÄ… wartoÅ›Ä‡ moÅ¼emy uÅ¼yÄ‡ np. zapisujÄ…c jÄ… do zmiennej:

```cpp title="ğŸ”¹ Zapisywanie rezultatu do zmiennej"
int s = sum(10, 100);
```

... lub uÅ¼yÄ‡ w wyraÅ¼eniu (np. jako parametr funkcji):

```cpp title="ğŸ”¹ UÅ¼ywanie rezultatu"
std::cout << "Suma liczb z zakresu [10; 100] wynosi: " << sum(10, 100);
```

#### Wymogi

:::danger ZwrÃ³cenie wartoÅ›ci jest obowiÄ…zkowe
Funkcja, ktÃ³ra zwraca jakÄ…Å› wartoÅ›Ä‡ (wszystko poza typem `void`), **musi** na samym koÅ„cu swojego wykonania
zwrÃ³ciÄ‡ jakÄ…Å› wartoÅ›Ä‡.

```cpp title="âŒ BÅ‚Ä…d: brak zwracanej wartoÅ›ci"
int sum(int from, int to)
{
	int result = 0;
	for (int i = from; i <= to; i++)
		result += i;
	// error-next-line
	// âŒ Brak instrukcji return!
}
```

WyjÄ…tkiem jest funkcja `main`, ktÃ³ra mimo zwracania typu `int`, wykonuje automatyczne zwrÃ³cenie wartoÅ›ci
gdy pominiemy `return`:

```cpp title="âœ” OK"
int main() {
	// Brak instrukcji return
}
```

O funkcji `main` powiemy wiÄ™cej w przyszÅ‚oÅ›ci.

:::

### Deklaracja a definicja

Aby mÃ³c uÅ¼yÄ‡ powyÅ¼szej funkcji `sum`, musimy upewniÄ‡ siÄ™, Å¼e znajduje siÄ™ ona **przed** tym uÅ¼yciem, przykÅ‚adowo:

<Tabs>
<TabItem value="bad" label="âŒ Å¹le" default>

```cpp
#include <iostream>

int main()
{
	// BÅ‚Ä…d: uÅ¼ycie przed definicjÄ…
	// error-next-line
	std::cout << "Suma liczb z zakresu [10; 100] wynosi: " << sum(10, 100);
}

// highlight-next-line
int sum(int from, int to)
{
	int result = 0;
	for (int i = from; i <= to; i++)
		result += i;
	return result;
}
```

</TabItem>
<TabItem value="good" label="âœ” Dobrze">

```cpp
#include <iostream>

int sum(int from, int to)
{
	int result = 0;
	for (int i = from; i <= to; i++)
		result += i;
	return result;
}

int main()
{
	std::cout << "Suma liczb z zakresu [10; 100] wynosi: " << sum(10, 100);
}
```

</TabItem>
</Tabs>

Dbanie o to, Å¼eby kolejnoÅ›Ä‡ zawsze siÄ™ zgadzaÅ‚a jest uciÄ…Å¼liwe a czasami nawet niemoÅ¼liwe.
Å»eby naprawiÄ‡ bÅ‚Ä…d z powyÅ¼szego przykÅ‚adu musimy zastosowaÄ‡ tzw. **deklaracjÄ™ funkcji**.

PÃ³ki co tworzÄ…c funkcjÄ™, uÅ¼ywaliÅ›my **definicjÄ™ funkcji**, ktÃ³ra oprÃ³cz deklaracji,
zawiera teÅ¼ caÅ‚Ä… jej implementacjÄ™ (ciaÅ‚o). Deklarowanie funkcji wyglÄ…da jak jej definiowanie,
**bez podawania jej ciaÅ‚a**. Musimy teÅ¼ zadbaÄ‡, Å¼eby po deklaracji daÄ‡ Å›rednik.

<Columns columns={['1fr', '1fr']}>
<div>

```cpp title="ğŸ”µ Definicja"
int sum(int from, int to)
{
	int result = 0;
	for (int i = from; i <= to; i++)
		result += i;
	return result;
}
```

</div>
<div>

```cpp title="ğŸŸ£ Deklaracja"
int sum(int from, int to);
```

</div>
</Columns>

Zasada jest taka, Å¼e aby uÅ¼yÄ‡ funkcji, musi byÄ‡ ona wczeÅ›niej **zadeklarowana**.
Definicja musi siÄ™ pojawiÄ‡, jednak nie ma znaczenia czy bÄ™dzie ona przed czy po uÅ¼yciu.
Oto dwa przykÅ‚ady:

<Tabs>
<TabItem value="good" label="âœ” OK" default>

```cpp
#include <iostream>

// ğŸŸ£ Deklaracja
// highlight-next-line
int sum(int from, int to);

int main()
{
	std::cout << "Suma liczb z zakresu [10; 100] wynosi: " << sum(10, 100);
}

// ğŸ”µ Definicja
// highlight-next-line
int sum(int from, int to)
{
	int result = 0;
	for (int i = from; i <= to; i++)
		result += i;
	return result;
}
```

</TabItem>
<TabItem value="good2" label="âœ” OK (definicja przed)">

```cpp
#include <iostream>

// ğŸŸ£ Deklaracja
// highlight-next-line
int sum(int from, int to);

// ğŸ”µ Definicja
// highlight-next-line
int sum(int from, int to)
{
	int result = 0;
	for (int i = from; i <= to; i++)
		result += i;
	return result;
}

int main()
{
	std::cout << "Suma liczb z zakresu [10; 100] wynosi: " << sum(10, 100);
}
```

</TabItem>
<TabItem value="good3" label="âœ” OK (wiele dekl.)">

```cpp
#include <iostream>

// ğŸŸ£ Deklaracje
// highlight-start
int sum(int from, int to);
int sum(int from, int to); // OK, wiele deklaracji dopuszczalne
int sum(int from, int to); // tylko po co to tutaj? ğŸ¤”
// highlight-end

int main()
{
	std::cout << "Suma liczb z zakresu [10; 100] wynosi: " << sum(10, 100);
}

// ğŸ”µ Definicja
// highlight-next-line
int sum(int from, int to)
{
	int result = 0;
	for (int i = from; i <= to; i++)
		result += i;
	return result;
}
```

</TabItem>
</Tabs>

:::danger Zasada jednej definicji (ang.: *ODR*)
Definicja **musi** pojawiÄ‡ siÄ™ w kodzie **tylko raz** (deklaracji moÅ¼e byÄ‡ wiele).
:::

## PrzykÅ‚ady ğŸš§

<ImproveSection />

## Potencjalne bÅ‚Ä™dy ğŸš§

<ImproveSection />

## Dodatkowe informacje ğŸš§

<ImproveSection />

## Dobre praktyki

### Dobra nazwa

KaÅ¼da funkcja to pewien kod, ktÃ³ry reprezentuje jednÄ… logicznÄ… operacjÄ™.
Nawyk dobrego nazywania funkcji powinien wejÅ›Ä‡ w krew jak najszybciej,
albowiem nazwy funkcji bardzo wpÅ‚ywajÄ… na czytelnoÅ›Ä‡ kodu oraz kilka innych kluczowych jego aspektÃ³w.

Funkcja ma cel, ktÃ³ry ma wykonywaÄ‡, oraz implementacjÄ™. Celem bÄ™dzie np. policzenie rÃ³wnania kwadratowego, implementacjÄ… bÄ™dzie sam kod, ktÃ³ry bÄ™dzie to wykonywaÄ‡.
Nazwa funkcji powinna odwzorowywaÄ‡ **cel**, nie implementacjÄ™.

GÅ‚Ã³wnym tego powodem jest to, Å¼e osoby wywoÅ‚ujÄ…cÄ… funkcjÄ™ nie powinno interesowaÄ‡ to **w jaki sposÃ³b** dana funkcja coÅ› robi, tylko **co** robi.
Drugim powÃ³d jest taki, Å¼e implementacja funkcji moÅ¼e siÄ™ zmieniÄ‡ na przestrzeni rozwoju naszej aplikacji.
MoÅ¼emy zmieniaÄ‡, naprawiaÄ‡, dodawaÄ‡ i usuwaÄ‡ kod w Å›rodku (czyt. zmieniaÄ‡ implementacjÄ™), ale o ile cel naszej funkcji dalej jest taki sam - nazwa pozostanie taka sama,
co rÃ³wnieÅ¼ pozwoli uniknÄ…Ä‡ tzw. zÅ‚amania API (*ang. API breakage*).

:::note Åamanie API
Podstawowe pytanie - czym jest **API**?
**API**, z angielskiego to **A**plication **P**rogramming **I**nterface.

Brzmi tajemniczo, ale przyjrzyjmy siÄ™ temu trochÄ™ bliÅ¼ej. Czym jest **interfejs**?

WyobraÅºmy sobie pralkÄ™. Pralka ma w Å›rodku skomplikowanÄ… maszyneriÄ™, duÅ¼o elementÃ³w mechanicznych i elektronicznych,
ktÃ³rych celem jest finalnie wypranie naszych ubraÅ„.
My do komunikacji z pralkÄ… uÅ¼ywamy przyciskÃ³w, pokrÄ™tÅ‚, ekranÃ³w dotykowych, etc. To wÅ‚aÅ›nie jest **interfejs**. Pozwala on na interakcjÄ™ z pralkÄ….

W przypadku programowania, **API** to rÃ³wnieÅ¼ wszystko co pozwala na interakcjÄ™. Funkcja ma nazwÄ™, parametry i typ zwracany.
WeÅºmy dla przykÅ‚adu takÄ… funkcjÄ™:
```cpp
void assignPlayerToTeam(std::string player)
{
	...;
}
```
Mamy tutaj funkcjÄ™ `assignPlayerToTeam`.
W czÄ™Å›Ä‡ jej **interfejsu** wchodzi jej nazwa (`assignPlayerToTeam`), typy jej parametrÃ³w (`std::string`) oraz jej typ zwracany (`void`).

Dlaczego Å‚amanie API jest takie niebezpieczne?

CÃ³Å¼, wyobraÅº sobie, Å¼e masz caÅ‚Ä… halÄ™ peÅ‚nÄ… pralek oraz po jednym robocie obsÅ‚ugujÄ…cym kaÅ¼dÄ… pralkÄ™ (pralka - funkcja, robot - kod korzystajÄ…cy z funkcji).
```cpp
std::vector<float> washingMachine3000(std::string button, int knob)
{
	...
}
```
KaÅ¼dy robot jest dokÅ‚adnie nauczony gdzie znajduje siÄ™ jaka pralka,
gdzie na tej pralce sÄ… jakie przyciski i w jakiej kolejnoÅ›ci jakie akcje naleÅ¼y wykonaÄ‡, aby doprowadziÄ‡ do udanego wyprania ubraÅ„.
```cpp
std::vector<float> result = washingMachine3000("click", 123);
```

WyobraÅº sobie teraz, Å¼e producent tych pralek nagle podmienia swojÄ… czarodziejskÄ… rÃ³Å¼dÅ¼kÄ… wszystkie stare pralki na nowszy model.
MoÅ¼na powiedzieÄ‡ - powÃ³d do radoÅ›ci, w koÅ„cu nowszy model, pralki sÄ… szybsze, pobierajÄ… mniej wody i prÄ…du, super.
Nie do koÅ„ca - nowy model pralek ma zmieniony interfejs - poprzestawianie guziki, brak niektÃ³rych pokrÄ™tÅ‚,
zastÄ…pione innych elementÃ³w dotykowymi panelami (zmieniona nazwa funkcji, inny typ zwracany, inne typy czy kolejnoÅ›Ä‡ argumentÃ³w).
```cpp
std::string washingMachine5000(float touchPanel, std::string button)
{
	...
}
...
std::vector<float> result = washingMachine3000("click", 123); // oops!
```

Nagle kaÅ¼dy robot (kod korzystajÄ…cy z funkcji) szaleje i wybucha, poniewaÅ¼ kaÅ¼dy robot jest nauczony korzystaÄ‡ z okreÅ›lonej pralki (funkcji) w okreÅ›lony sposÃ³b,
jednak interfejs siÄ™ zmieniÅ‚, wiÄ™c nic nie dziaÅ‚a tak jak powinno.

Åamanie API to bardzo czÄ™sto sytuacja ktÃ³rej chcemy uniknÄ…Ä‡, poniewaÅ¼ sprawia duÅ¼o kÅ‚opotÃ³w programistom utrzymujÄ…cym kod, ktÃ³ry korzysta z naszych funkcji.
Nie zawsze jest to moÅ¼liwe i wtedy stosuje siÄ™ rÃ³Å¼nego rodzaju techniki, ktÃ³re powiadamiajÄ… programistÃ³w o **przyszÅ‚ym** zÅ‚amaniu obietnicy, ktÃ³rÄ… jest interfejs.
:::

### Jedna logiczna operacja

Funkcje powinny wykonywaÄ‡ tylko i wyÅ‚Ä…cznie jednÄ… logicznÄ… operacjÄ™, powinny realizowaÄ‡ tylko jeden cel na raz.
Wydzielanie jak najmniejszych kawaÅ‚kÃ³w kodu do funkcji niesie za sobÄ… caÅ‚y szereg korzyÅ›ci:

 - :::info ZwiÄ™kszenie **reuÅ¼ywalnoÅ›ci** funkcji
	JeÅ›li funkcje wykonujÄ… tylko jednÄ… logicznÄ… operacjÄ™, to jest wiÄ™ksza szansa, Å¼e bÄ™dzie moÅ¼na je wykorzystaÄ‡ w wielu miejscach,
	w porÃ³wnaniu do funkcji, ktÃ³re robiÄ… wiele rzeczy.

	JeÅ›li mamy funkcjÄ™, ktÃ³ra usuwa spacje z przodu i z tyÅ‚u napisu, to nie uÅ¼yjemy jej tam, gdzie bÄ™dziemy potrzebowaÄ‡ usunÄ…Ä‡ tylko spacje z przodu.
	Za to jeÅ›li bÄ™dziemy mieÄ‡ dwie funkcje - jednÄ… usuwajÄ…cÄ… spacje z przodu, a drugÄ… z tyÅ‚u, to nie doÅ›Ä‡, Å¼e bÄ™dziemy mogli zaimplementowaÄ‡ funkcjÄ™, ktÃ³ra
	usuwa znaki jednoczeÅ›nie i z przodu i tyÅ‚u na podstawie tamtych dwÃ³ch, to jeszcze bÄ™dzie mieli do dyspozycji dwie inne, bardziej specyficzne,
	usuwajÄ…ce tyko z przodu lub z tyÅ‚u.
	:::

 - :::info WiÄ™ksza szansa na optymalizacje
	Nie bÄ™dziemy siÄ™ wgÅ‚Ä™biaÄ‡ w powody dlaczego tak jest. Warto po prostu zapamiÄ™taÄ‡, Å¼e kompilator potrafi lepiej zoptymalizowaÄ‡ kod, ktÃ³ry
	uÅ¼ywa maÅ‚ych, dobrze podzielonych funkcji, w przeciwieÅ„stwie do takiego, w ktÃ³rym funkcje sÄ… duÅ¼e i nie wykonujÄ… maÅ‚ej iloÅ›ci operacji.
	:::

 - :::info Åatwiejszy w analizie kod
	MaÅ‚e funkcje sÄ… zazwyczaj Å‚atwiejsze w analizie niÅ¼ duÅ¼e funkcje.
	Kod korzystajÄ…cy z maÅ‚ych, dobrze nazwanych funkcji rÃ³wnieÅ¼ jest zazwyczaj Å‚atwiejszy w analizie, niÅ¼ taki, ktÃ³ry korzysta z funkcji,
	ktÃ³re ukrywajÄ… duÅ¼o rzeczy przed programistÄ….

	JeÅ›li funkcja nazywa siÄ™ `stringToInt`, to programista czytajÄ…c zapis `stringToInt("3113")` spodziewa siÄ™ tylko i wyÅ‚Ä…cznie zwrÃ³cenia przez tÄ™ funkcjÄ™
	liczby o wartoÅ›ci 3113, Å¼adnego wypisywania ani Å¼adnych innych akcji w tle. Wszystko co powinno byÄ‡ widoczne, bÄ™dzie w takim ukÅ‚adzie widoczne.
	:::

 - :::info Funkcje Å‚atwiejsze w testowaniu
	Testowanie nie jest tematem dla poczÄ…tkujÄ…cych, aczkolwiek zdecydowanie jest aspektem waÅ¼nym w pracy programisty.
	Testowanie polega na niczym innym niÅ¼ sprawdzaniu, czy kod napisany przez programistÄ™ jest poprawny (tzn. czy speÅ‚nia ustalone zaÅ‚oÅ¼enia).

	Testowanie funkcji, ktÃ³re same za siebie mÃ³wiÄ… co robiÄ…, sÄ… podzielone na logiczne operacje i nie majÄ… efektÃ³w ubocznych,
	jest znacznie prostsze, niÅ¼ testowanie potworÃ³w o niebotycznych wielkoÅ›ciach, rozwiÄ…zujÄ…cych wszystkie problemy Å›wiata.
	:::

 - :::info Funkcje Å‚atwiejsze w nazywaniu
	Tak jak juÅ¼ wczeÅ›niej powiedzieliÅ›my - nazwa funkcji powinna odzwierciedlaÄ‡ operacjÄ™, ktÃ³rÄ… ta funkcja wykonuje.
	Funkcje wykonujÄ…ce pojedyncze operacje nazwaÄ‡ jest doÅ›Ä‡ Å‚atwo i szybko.

	W przypadku funkcji, ktÃ³re nie podÄ…Å¼ajÄ… za tÄ… dobrÄ… praktykÄ…, musimy siÄ™ namyÅ›leÄ‡ jak oddaÄ‡ istotÄ™ funkcji, ktÃ³ra robi wiele rzeczy na raz, co jest
	oczywiÅ›cie trudniejsze.
	:::