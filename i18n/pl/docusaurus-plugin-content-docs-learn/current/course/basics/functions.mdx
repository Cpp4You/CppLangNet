---
sidebar_position:	7
sidebar_label:		"7. Funkcje"
title:				"Funkcje"
description:		"Lekcja: funkcje w jÄ™zyku C++"
tags:				[funkcja, wywoÅ‚anie]
hide_title:			true
---

<!-- Presets -->
import NotFinished				from '@site/i18n/pl/presets/NotFinished.mdx';
import ImproveSection			from '@site/i18n/pl/presets/ImproveSection.mdx';

<!-- Components -->
import CustomCodeBlock			from '@site-comps/CustomCodeBlock';
import GoogleSlides				from '@site-comps/GoogleSlides';
import Columns					from '@site-comps/Columns';
import Image					from '@site-comps/Image';
import Tabs						from '@theme/Tabs';
import TabItem					from '@theme/TabItem';

<!-- Codes -->
import Code_TopExampleWithout				from "./_codes/functions/top-example-without.mdx";
import Code_TopExampleWith					from "./_codes/functions/top-example-with.mdx";

import Code_ExampleReuse					from "./_codes/functions/example-reuse.mdx";
import Code_ExampleReuseWithParam			from "./_codes/functions/example-reuse-with-param.mdx";
import Code_ExampleReuseWithParams			from "./_codes/functions/example-reuse-with-params.mdx";

<NotFinished/>

# Funkcje

W tej lekcji dowiesz siÄ™ jak nauczyÄ‡ program wykonywania akcji, z moÅ¼liwoÅ›ciÄ…
ich wielokrotnego uÅ¼ytku.

## Motywacja

Jednym z plusÃ³w uÅ¼ywania funkcji jest redukcja potwÃ³rzeÅ„ w kodzie. Zobacz przykÅ‚ad
poniÅ¼ej, w wersji bez uÅ¼ycia funkcji oraz z uÅ¼yciem. Na ten moment
nie musisz rozumieÄ‡ zapisu z przykÅ‚adu z funkcjÄ… - do wyjaÅ›nienia
przejdziemy w dalszej czÄ™Å›ci tej lekcji.

<hr/>

<Tabs>
	<TabItem value="without-functions" label="âš  Bez funkcji">
		<Code_TopExampleWithout />
	</TabItem>
	<TabItem value="with-function" label="ğŸŸ¢ Z funkcjÄ…">
		<Code_TopExampleWith />
	</TabItem>
</Tabs>

<hr/>

W przykÅ‚adzie powyÅ¼ej tworzymy tablicÄ™ liczb i modyfikujemy jÄ…, kaÅ¼dorazowo wyÅ›wietlajÄ…c zawartoÅ›Ä‡.
RÃ³Å¼nica miÄ™dzy tymi dwoma wersjami jest taka, Å¼e pierwszy zawiera fragment kodu, ktÃ³ry przekleiliÅ›my
parÄ™ razy komendÄ… kopiuj-wklej. W drugiej, bardziej prawidÅ‚owej wersji, jednorazowo **uczymy nasz program
jak wyÅ›wietliÄ‡ tablicÄ™ liczb** a nastÄ™pnie korzystamy z tego wielokrotnie wtedy, kiedy tego potrzebujemy.

Funkcje majÄ… jeszcze bardzo wiele innych zastosowaÅ„ i czÄ™Å›Ä‡ z nich w tej lekcji pokaÅ¼emy. PÃ³ki co jednak
musimy powrÃ³ciÄ‡ na sam poczÄ…tek do podstaw.

## Wprowadzenie

:::important Definicja
Funkcja to wydzielony fragment kodu, ktÃ³ry moÅ¼emy wielokrotnie wykorzystywaÄ‡.
:::

Od samego poczÄ…tku nauki w naszych programach umieszczaliÅ›my specjalnÄ… funkcjÄ™,
ktÃ³rÄ… jest `main`.

```cpp
int main() {
	// kod programu
}
```

Komputer uruchamiajÄ…c program znajduje funkcjÄ™ `main` a nastÄ™pnie jÄ… wykonuje,
przechodzÄ…c po kaÅ¼dej instrukcji wewnÄ…trz, linijka po linijce.

## Tworzenie funkcji

Zaczniemy od najprostszych funkcji, stopniowo przechodzÄ…c do coraz bardziej zaawansowanych.

### Bez parametrÃ³w

<Image center border
		src="/img/tutorials/course/basic/functions/proc-no-params-pl.png"
		desc="Schemat najprostszej funkcji"
	/>

Jak widzimy wyÅ¼ej, definiujÄ…c wÅ‚asnÄ… funkcjÄ™, musimy zadbaÄ‡ o jej nazwÄ™ oraz ciaÅ‚o, trzymajÄ…c
siÄ™ przy tym skÅ‚adni. Po sÅ‚owie `void` piszemy **nazwÄ™ funkcji**, nastÄ™pnie dajemy puste
**nawiasy okrÄ…gÅ‚e** (o tym powiemy dalej w tej lekcji), potem **bez Å›rednika** umieszczamy poniÅ¼ej
blok kodu, ktÃ³ry nazywamy **ciaÅ‚em funkcji**.

:::important Nazewnictwo
NazywajÄ…c funkcjÄ™ przestrzegamy tych samych zasad co przy [nazwach zmiennych](../variables/#nazwa-zmiennej).
:::

W ten sposÃ³b mamy juÅ¼ zdefiniowanÄ… funkcjÄ™. Oznacza to, Å¼e gdy tylko bÄ™dziemy tego chcieli, moÅ¼emy
jÄ… **wywoÅ‚aÄ‡**. Robimy to w ten sposÃ³b:

```cpp title="ğŸ”¹ WywoÅ‚anie funkcji"
print();
```

:::caution Uwaga
ZwrÃ³Ä‡ uwagÄ™, Å¼e umieÅ›ciliÅ›my **Å›rednik** po wywoÅ‚aniu funkcji, bo jest to teÅ¼ koniec instrukcji.
:::

Napiszmy przykÅ‚adowÄ… funkcjÄ™, ktÃ³ra wyÅ›wietla 10 liczb parzystych i uÅ¼yjmy jej kilka razy:

<>
<Code_ExampleReuse />
</>

### Z parametrami

<Image center border
		src="/img/tutorials/course/basic/functions/proc-params-pl.png"
		desc="Schemat funkcji z parametrami"
	/>

DziaÅ‚anie funkcji moÅ¼emy uzaleÅ¼niÄ‡ od **parametrÃ³w**. ChcÄ…c, Å¼eby funkcja wyÅ›wietlaÅ‚a
dowolnie duÅ¼o liczb parzystych, moÅ¼emy utworzyÄ‡ w funkcji parametr,
ktÃ³ry bÄ™dzie to kontrolowaÅ‚. Parametr jest zmiennÄ… wewnÄ…trz funkcji, ktÃ³rÄ… tworzymy
w Å›rodku nawiasÃ³w okrÄ…gÅ‚ych:

<>
<Code_ExampleReuseWithParam />
</>

PowyÅ¼szy zapis

```cpp
printEvenNumbers(10);
```

oznacza, Å¼e w momencie wywoÅ‚ania, do parametru `howMany` wewnÄ…trz tej funkcji
zostanie przypisana wartoÅ›Ä‡ `10`. MoÅ¼emy do funkcji przekazywaÄ‡ dowolnÄ… liczbÄ™ parametrÃ³w.
Oddzielamy je przecinkami:

<>
<Code_ExampleReuseWithParams />
</>

:::danger Popularny bÅ‚Ä…d
ZauwaÅ¼, Å¼e kolejne parametry funkcji umieszczamy po przecinku, kaÅ¼dorazowo podajÄ…c jego typ.
CzÄ™stym bÅ‚Ä™dem wÅ›rÃ³d poczÄ…tkujÄ…cych jest pominiÄ™cie typu w nastÄ™pnych parametrach.

<Tabs>
<TabItem label="âŒ Å¹le" value="bad" default>

```cpp
void printBiggerNumber(int a, b)
```

</TabItem>
<TabItem label="âœ” Dobrze" value="good">

```cpp
void printBiggerNumber(int a, int b)
```

</TabItem>
</Tabs>

:::

### Instrukcja powrotu

MoÅ¼emy kazaÄ‡ programowi wczeÅ›niej powrÃ³ciÄ‡ z funkcji, za pomocÄ… instrukcji:

```cpp
return;
```

W momencie jej napotkania, program przestaje wykonywaÄ‡ kolejne instrukcje w funkcji
i wraca do miejsca, z ktÃ³rego zostaÅ‚a ona wywoÅ‚ana. Przytoczmy stworzonÄ… przez nas wczeÅ›niej
funkcjÄ™ `printEvenNumbers`:

```cpp
void printEvenNumbers(int howMany)
{
	for (int i = 0; i < howMany; i++)
		std::cout << (i * 2) << ' ';
	std::cout << '\n';
}
```

Co siÄ™ stanie, jeÅ›li podamy ujemnÄ… liczbÄ™ do `howMany`?

```cpp
printEvenNumbers(-10);
```

Wykonywanie funkcji z takÄ… wartoÅ›ciÄ… parametru nie ma sensu, dlatego moÅ¼emy to juÅ¼ na samym poczÄ…tku
wychwyciÄ‡ i wykonaÄ‡ powrÃ³t:

```cpp
void printEvenNumbers(int howMany)
{
	if (howMany <= 0)
		return;

	for (int i = 0; i < howMany; i++)
		std::cout << (i * 2) << ' ';
	std::cout << '\n';
}
```

Teraz gdy podamy wartoÅ›Ä‡ mniejszÄ… lub rÃ³wnÄ… zero do parametru funkcji, funkcja juÅ¼ na poczÄ…tku zostanie przerwana.

### WartoÅ›Ä‡ zwracana

<Image center border
		src="/img/tutorials/course/basic/functions/retval-params-pl.png"
		desc="Schemat funkcji z parametrami i wartoÅ›ciÄ… zwracanÄ…"
	/>


Funkcje mogÄ… pozostawiÄ‡ po swoim wykonaniu pewien **rezultat**. Åatwiej bÄ™dzie to zrozumieÄ‡ gdy zastosujemy analogiÄ™ do
realnego Å¼ycia. Rodzic wysyÅ‚a swoje dziecko do sklepu po 10 jajek. Po powrocie dziecka, bÄ™dzie chciaÅ‚ wiedzieÄ‡,
czy udaÅ‚o mu siÄ™ kupiÄ‡ tyle ile poprosiÅ‚, czy nie. Tak samo my, wykonujÄ…c niektÃ³re funkcje w kodzie,
chcemy znaÄ‡ ich rezultat, czyli **wartoÅ›Ä‡ zwracanÄ…**.

#### Typ zwracanej wartoÅ›ci

Wymagane jest, aby okreÅ›liÄ‡ jakiego typu jest wartoÅ›Ä‡ zwracana. Podajemy go **przed** nazwÄ… funkcji, przykÅ‚adowo:

```cpp title="ğŸ”¹ Zwracamy liczbÄ™ caÅ‚kowitÄ…" 
int sum(int from, int to)
```

```cpp title="ğŸ”¹ Brak zwracanej wartoÅ›ci"
void print(int number)
```

ZauwaÅ¼, Å¼e wprowadziliÅ›my nowy typ: `void` (z ang.: *pusty*). JeÅ›li wpiszemy go w miejsce typu zwracanego,
bÄ™dzie to oznaczaÅ‚o, Å¼e funkcja nie zwraca wartoÅ›ci, tj. nie potrzebujemy znaÄ‡ jej rezultatu.
ZauwaÅ¼, Å¼e z `void` korzystaliÅ›my w poprzednich sekcjach tej lekcji, wÅ‚aÅ›nie z tego powodu.

:::danger Typ pusty i zmienne
Typ `void` nie moÅ¼e byÄ‡ uÅ¼yty do stworzenia zmiennej:

```cpp title="âŒ NieprawidÅ‚owy zapis"
void variable;
```

Zmienna z zaÅ‚oÅ¼enia przechowuje wartoÅ›Ä‡, co byÅ‚oby niemoÅ¼liwe gdyby byÅ‚a typu `void`.
:::

#### Zastosowanie

Zaimplementujmy funkcjÄ™ ze schematu wyÅ¼ej. Ma ona zliczyÄ‡ sumÄ™ wszystkich liczb w zakresie od `from` do `to` wÅ‚Ä…cznie.

```cpp
int sum(int from, int to)
{
	int result = 0;
	for (int i = from; i <= to; i++)
		result += i;
	return result;
}
```

ZwrÃ³conÄ… wartoÅ›Ä‡ moÅ¼emy uÅ¼yÄ‡ np. zapisujÄ…c jÄ… do zmiennej:

```cpp title="ğŸ”¹ Zapisywanie rezultatu do zmiennej"
int s = sum(10, 100);
```

... lub uÅ¼yÄ‡ w wyraÅ¼eniu (np. jako parametr funkcji):

```cpp title="ğŸ”¹ UÅ¼ywanie rezultatu"
std::cout << "Suma liczb z zakresu [10; 100] wynosi: " << sum(10, 100);
```

#### Wymogi

:::danger ZwrÃ³cenie wartoÅ›ci jest obowiÄ…zkowe
Funkcja, ktÃ³ra zwraca jakÄ…Å› wartoÅ›Ä‡ (wszystko poza typem `void`), **musi** na samym koÅ„cu swojego wykonania
zwrÃ³ciÄ‡ jakÄ…Å› wartoÅ›Ä‡.

```cpp title="âŒ BÅ‚Ä…d: brak zwracanej wartoÅ›ci"
int sum(int from, int to)
{
	int result = 0;
	for (int i = from; i <= to; i++)
		result += i;
	// highlight-next-line
	// âŒ Brak instrukcji return!
}
```

WyjÄ…tkiem jest funkcja `main`, ktÃ³ra mimo zwracania typu `int`, wykonuje automatyczne zwrÃ³cenie wartoÅ›ci
gdy pominiemy `return`:

```cpp title="âœ” OK"
int main() {
	// Brak instrukcji return
}
```

O funkcji `main` powiemy wiÄ™cej w przyszÅ‚oÅ›ci.

:::

### Deklaracja a definicja

Aby mÃ³c uÅ¼yÄ‡ powyÅ¼szej funkcji `sum`, musimy upewniÄ‡ siÄ™, Å¼e znajduje siÄ™ ona **przed** tym uÅ¼yciem, przykÅ‚adowo:

<Tabs>
<TabItem value="bad" label="âŒ Å¹le" default>

```cpp
#include <iostream>

int main()
{
	// Uwaga, uÅ¼ycie przed definicjÄ…
	// highlight-next-line
	std::cout << "Suma liczb z zakresu [10; 100] wynosi: " << sum(10, 100); // âŒ
}

// highlight-next-line
int sum(int from, int to)
{
	int result = 0;
	for (int i = from; i <= to; i++)
		result += i;
	return result;
}
```

</TabItem>
<TabItem value="good" label="âœ” Dobrze">

```cpp
#include <iostream>

int sum(int from, int to)
{
	int result = 0;
	for (int i = from; i <= to; i++)
		result += i;
	return result;
}

int main()
{
	std::cout << "Suma liczb z zakresu [10; 100] wynosi: " << sum(10, 100);
}
```

</TabItem>
</Tabs>

Dbanie o to, Å¼eby kolejnoÅ›Ä‡ zawsze siÄ™ zgadzaÅ‚a jest uciÄ…Å¼liwe a czasami nawet niemoÅ¼liwe.
Å»eby naprawiÄ‡ bÅ‚Ä…d z powyÅ¼szego przykÅ‚adu musimy zastosowaÄ‡ tzw. **deklaracjÄ™ funkcji**.

PÃ³ki co tworzÄ…c funkcjÄ™, uÅ¼ywaliÅ›my **definicjÄ™ funkcji**, ktÃ³ra oprÃ³cz deklaracji,
zawiera teÅ¼ caÅ‚Ä… jej implementacjÄ™ (ciaÅ‚o). Deklarowanie funkcji wyglÄ…da jak jej definiowanie,
**bez podawania jej ciaÅ‚a**. Musimy teÅ¼ zadbaÄ‡, Å¼eby po deklaracji daÄ‡ Å›rednik.

<Columns columns={['1fr', '1fr']}>
<div>

```cpp title="ğŸ”µ Definicja"
int sum(int from, int to)
{
	int result = 0;
	for (int i = from; i <= to; i++)
		result += i;
	return result;
}
```

</div>
<div>

```cpp title="ğŸŸ£ Deklaracja"
int sum(int from, int to);
```

</div>
</Columns>

Zasada jest taka, Å¼e aby uÅ¼yÄ‡ funkcji, musi byÄ‡ ona wczeÅ›niej **zadeklarowana**.
Definicja musi siÄ™ pojawiÄ‡, jednak nie ma znaczenia czy bÄ™dzie ona przed czy po uÅ¼yciu.
Oto dwa przykÅ‚ady:

<Tabs>
<TabItem value="good" label="âœ” OK" default>

```cpp
#include <iostream>

// ğŸŸ£ Deklaracja
// highlight-next-line
int sum(int from, int to);

int main()
{
	std::cout << "Suma liczb z zakresu [10; 100] wynosi: " << sum(10, 100);
}

// ğŸ”µ Definicja
// highlight-next-line
int sum(int from, int to)
{
	int result = 0;
	for (int i = from; i <= to; i++)
		result += i;
	return result;
}
```

</TabItem>
<TabItem value="good2" label="âœ” OK (definicja przed)">

```cpp
#include <iostream>

// ğŸŸ£ Deklaracja
// highlight-next-line
int sum(int from, int to);

// ğŸ”µ Definicja
// highlight-next-line
int sum(int from, int to)
{
	int result = 0;
	for (int i = from; i <= to; i++)
		result += i;
	return result;
}

int main()
{
	std::cout << "Suma liczb z zakresu [10; 100] wynosi: " << sum(10, 100);
}
```

</TabItem>
<TabItem value="good3" label="âœ” OK (wiele dekl.)">

```cpp
#include <iostream>

// ğŸŸ£ Deklaracje
// highlight-start
int sum(int from, int to);
int sum(int from, int to); // OK, wiele deklaracji dopuszczalne
int sum(int from, int to); // tylko po co to tutaj? ğŸ¤”
// highlight-end

int main()
{
	std::cout << "Suma liczb z zakresu [10; 100] wynosi: " << sum(10, 100);
}

// ğŸ”µ Definicja
// highlight-next-line
int sum(int from, int to)
{
	int result = 0;
	for (int i = from; i <= to; i++)
		result += i;
	return result;
}
```

</TabItem>
</Tabs>

:::danger Zasada jednej definicji (ang.: *ODR*)
Definicja **musi** pojawiÄ‡ siÄ™ w kodzie **tylko raz** (deklaracji moÅ¼e byÄ‡ wiele).
:::

## PrzykÅ‚ady ğŸš§

<ImproveSection />

## Potencjalne bÅ‚Ä™dy

### Brak widocznej deklaracji

Jednym z bardzo czÄ™sto popeÅ‚nianych bÅ‚Ä™dÃ³w jest prÃ³ba uÅ¼ycia funkcji, bez jej deklaracji:

<Tabs>
<TabItem value="bad" label="âŒ Å¹le" default>

```cpp title="âŒ Brak deklaracji"
#include <iostream>

int main()
{
	std::cout << "Suma od 1 do 10 wynosi: " << sum(1, 10) << '\n';
}

int sum(int from, int to)
{
	int result = 0;
	for (int i = from; i <= to; i++)
		result += i;
	return result;
}
```

Kompilator musi wiedzieÄ‡, Å¼e funkcja istnieje jeszcze przed jej uÅ¼yciem (konkretniej - musi znaÄ‡ jej typ zwracany, nazwÄ™ oraz typy parametrÃ³w).

#### ğŸ”´ TreÅ›Ä‡ bÅ‚Ä™du

<Tabs groupId="compiler">
<TabItem value="clang" label="CLANG" default>

```plaintext
error: use of undeclared identifier 'sum'
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Ilustracja bÅ‚Ä™du - brak deklaracji funkcji"
		src="/img/tutorials/course/basic/functions/error-no-declaration-pl-clang.png"
	/>

</TabItem>
<TabItem value="gcc" label="GCC">

```plaintext
error: â€˜sumâ€™ was not declared in this scope
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Ilustracja bÅ‚Ä™du - brak deklaracji funkcji"
		src="/img/tutorials/course/basic/functions/error-no-declaration-pl-gcc.png"
	/>

</TabItem>
<TabItem value="msvc" label="MSVC">

```plaintext
error C3861: 'sum': identifier not found
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Ilustracja bÅ‚Ä™du - brak deklaracji funkcji"
		src="/img/tutorials/course/basic/functions/error-no-declaration-pl-msvc.png"
	/>

</TabItem>
</Tabs>

</TabItem>
<TabItem value="good" label="âœ” Dobrze">

```cpp title="âœ” Deklaracja przed uÅ¼yciem"
#include <iostream>

int sum(int from, int to);

int main()
{
	std::cout << "Suma od 1 do 10 wynosi: " << sum(1, 10) << '\n';
}

int sum(int from, int to)
{
	int result = 0;
	for (int i = from; i <= to; i++)
		result += i;
	return result;
}
```

</TabItem>
<TabItem value="good2" label="âœ” RÃ³wnieÅ¼ dobrze">

```cpp title="âœ” Definicja przed uÅ¼yciem"
#include <iostream>

int sum(int from, int to)
{
	int result = 0;
	for (int i = from; i <= to; i++)
		result += i;
	return result;
}

int main() 
{
	std::cout << "Suma od 1 do 10 wynosi: " << sum(1, 10) << '\n';
}
```

</TabItem>
</Tabs>


### Brak widocznej definicji

Kolejnym bardzo czÄ™sto spotykanym bÅ‚Ä™dem jest zadeklarowanie funkcji i niedostarczenie jej definicji.
W takim wypadku dostaniemy bÅ‚Ä…d **linkera**, nie **kompilatora**.

```cpp title="âŒ Brak definicji"
#include <iostream>

int sum(int from, int to);

int main()
{
	std::cout << "Suma od 1 do 10 wynosi: " << sum(1, 10) << '\n';
}
```

#### ğŸ”´ TreÅ›Ä‡ bÅ‚Ä™du

<Tabs groupId="compiler">
<TabItem value="clang" label="CLANG" default>

```plaintext
undefined reference to `sum(int, int)`
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Ilustracja bÅ‚Ä™du - brak definicji"
		src="/img/tutorials/course/basic/functions/error-no-definition-pl-clang.png"
	/>

</TabItem>
<TabItem value="gcc" label="GCC">

```plaintext
undefined reference to `sum(int, int)`
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Ilustracja bÅ‚Ä™du - brak definicji"
		src="/img/tutorials/course/basic/functions/error-no-definition-pl-gcc.png"
	/>

</TabItem>
<TabItem value="msvc" label="MSVC">

```plaintext
error LNK2019: unresolved external symbol "int __cdecl sum(int,int)" (?sum@@YAHHH@Z) referenced in function main
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Ilustracja bÅ‚Ä™du - brak definicji"
		src="/img/tutorials/course/basic/functions/error-no-definition-pl-msvc.png"
	/>

</TabItem>
</Tabs>

:::important Kompilator vs linker
RÃ³Å¼nica pomiÄ™dzy kompilatorem a linkerem jest taka, Å¼e kompilator tylko i wyÅ‚Ä…cznie bierze nasz kod i zamienia kod w **pliki obiektowe**,
ktÃ³ra sÄ… niczym innym niÅ¼ kodem zrozumiaÅ‚ym przez nasz komputer.
Na plikach obiektowych siÄ™ jednak nie koÅ„czy, poniewaÅ¼ pliki obiektowe sÄ… jedynie efektem skompilowania pojedynczych plikÃ³w ÅºrÃ³dÅ‚owych (`.cpp`).

Zaraz po kompilatorze wkracza **linker**, ktÃ³ry Å‚Ä…czy (linkuje) wszystkie nasze pliki obiektowe, biblioteki itd. w jeden, caÅ‚y **plik wykonywalny**.
Linker jest trochÄ™ gÅ‚upi, poniewaÅ¼ linker nie potrafi czytaÄ‡ kodu - on czyta tylko pliki obiektowe wygenerowane przez kompilator.
W ich Å›rodku nie ma kodu (takiego C++owego), ale jest kod binarny i **symbole**.

WyobraÅºmy sobie przykÅ‚adowy, zmyÅ›lony proces kompilacji, w ktÃ³rym kompilator zamienia nasz przykÅ‚adowy kod:
```cpp
#include <iostream>

int sum(int from, int to);

int main()
{
	std::cout << "Suma od 1 do 10 wynosi: " << sum(1, 10) << '\n';
}
```
w
```asm
symbol int_main:
	cout "Suma od 1 do 10 wynosi"
	result = call int_sum_int_int
	cout result
	cout '\n'
```
`symbol int_main` oznaczaÅ‚by deklaracjÄ™ symbolu, nastÄ™pnie w Å›rodku znajdujÄ… siÄ™ instrukcje w naszym mainie.
ZauwaÅ¼, Å¼e znajduje siÄ™ tam tylko i wyÅ‚Ä…cznie odwoÅ‚anie do `int_sum_int_int`.

Tak mniej wiÄ™cej wyglÄ…da to w pliku obiektowym, tyle, Å¼e trochÄ™ bardziej strasznie i magicznie.
WywoÅ‚anie funkcji w naszym programie, to po po prostu przejÅ›cie pod odpowiedni **adres** w pliku wykonywalnym,
wykonanie kodu, a potem powrÃ³cenie (potencjalnie zapisujÄ…c wartoÅ›Ä‡ zwrÃ³conÄ… *gdzieÅ›*).

Linker podczas czytania takiego pliku obiektowego prÃ³buje znaleÅºÄ‡ **adres** symbolu `int_sum_int_int`,
Å¼eby moÅ¼na go potem byÅ‚o wstawiÄ‡ do pliku wykonywalnego - **jednak nie moÅ¼e!**, takiego symbolu w ogÃ³le nie ma w naszym pliku obiektowym,
poniewaÅ¼ nie napisaliÅ›my definicji.

WÅ‚aÅ›nie z tego powodu dostajemy bÅ‚Ä…d. Dla porÃ³wnania spÃ³jrzmy na innÄ…, hipotetycznÄ… sytuacjÄ™, w ktÃ³rej kod jest poprawny:
```cpp
#include <iostream>

int sum(int from, int to);

int main()
{
	std::cout << "Suma od 1 do 10 wynosi: " << sum(1, 10) << '\n';
}

int sum(int from, int to)
{
	int result = 0;
	for (int i = from; i <= to; i++)
		result += i;
	return result;
}
```
Kompilator w naszym przykÅ‚adzie zamieni to na:
```asm
symbol int_main:
	cout "Suma od 1 do 10 wynosi"
	result = call int_sum_int_int
	cout result
	cout '\n'

symbol int_sum_int_int:
	// kod
```

Linker czytajÄ…c taki plik moÅ¼e odnaleÅºÄ‡ adres naszej funkcji, wziÄ…Ä‡ go i wsadziÄ‡ w miejsce `call int_sum_int_int`.
Wszystko kompiluje siÄ™ poprawnie, linkuje siÄ™ poprawnie i wykonuje siÄ™ poprawnie.
:::


### Wiele definicji

WeÅºmy pod lupÄ™ taki kod:

```cpp title="ğŸ”¹ Wiele definicji funkcji"
#include <iostream>

int sum(int from, int to)
{
	int result = 0;
	for (int i = from; i <= to; i++)
		result += i;
	return result;
}

int main()
{
	std::cout << "Suma od 1 do 10 wynosi: " << sum(1, 10) << '\n';
}

int sum(int from, int to)
{
	int result = 0;
	for (int i = from; i <= to; i++)
		result += i;
	return result;
}
```

Programista przez przypadek zdefiniowaÅ‚ tutaj funkcjÄ™ `sum` dwa razy.
Jak wyÅ¼ej zostaÅ‚o wspomniane - jest to zÅ‚amanie zasady **ODR** (*ang. One Definition Rule*).
W programie jest dozwolona tylko jedna definicja funkcji, poniewaÅ¼ kompilator nie bÄ™dzie zgadywaÄ‡ ktÃ³ra akurat
jest poprawna, a wiele definicji moÅ¼e oznaczaÄ‡ bÅ‚Ä…d programisty.

#### ğŸ”´ TreÅ›Ä‡ bÅ‚Ä™du

<Tabs groupId="compiler">
<TabItem value="clang" label="CLANG" default>

```plaintext
error: redefinition of 'sum'
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Ilustracja bÅ‚Ä™du - wiele definicji"
		src="/img/tutorials/course/basic/functions/error-multiple-definitions-clang.png"
	/>

</TabItem>
<TabItem value="gcc" label="GCC">

```plaintext
error: redefinition of â€˜int sum(int, int)â€™
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Ilustracja bÅ‚Ä™du - wiele definicji"
		src="/img/tutorials/course/basic/functions/error-multiple-definitions-gcc.png"
	/>

</TabItem>
<TabItem value="msvc" label="MSVC">

```plaintext
error C2084: function 'int sum(int,int)' already has a body
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Ilustracja bÅ‚Ä™du - wiele definicji"
		src="/img/tutorials/course/basic/functions/error-multiple-definitions-msvc.png"
	/>

</TabItem>
</Tabs>


### Niezapisanie typu zwracanego

Czasami moÅ¼emy zobaczyÄ‡ kod pokroju:

```cpp title="âŒ Funkcja bez typu zwracanego"
main()
{
	...
}
```

Widzimy tutaj funkcjÄ™ gÅ‚Ã³wnÄ… **main** bez typu zwracanego.
Jest to absolutnie niepoprawny kod. NiektÃ³re kompilatory mogÄ… go zaakceptowaÄ‡ i skompilowÄ…Ä‡ (w ramach rozszerzenia), aczkolwiek kod ten jest nielegalny.
Jest to zaszÅ‚oÅ›Ä‡ z C (notabene - zapis ten usuniÄ™to rÃ³wnieÅ¼ w C, w standardzie C99), ktÃ³ra, jeÅ›li typ nie zostaje podany, automatycznie zakÅ‚ada typ zwracany `int`.
FukcjonalnoÅ›Ä‡ ta jest nazywana *"implicit int"* i nie powinno siÄ™ na niej w ogÃ³le polegaÄ‡.

#### ğŸ”´ TreÅ›Ä‡ bÅ‚Ä™du

<Tabs groupId="compiler">
<TabItem value="clang" label="CLANG" default>

```plaintext
error: C++ requires a type specifier for all declarations
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Ilustracja bÅ‚Ä™du - brak typu zwracanego main"
		src="/img/tutorials/course/basic/functions/error-implicit-int-clang.png"
	/>

</TabItem>
<TabItem value="gcc" label="GCC">

```plaintext
warning: ISO C++ forbids declaration of â€˜mainâ€™ with no type [-Wreturn-type]
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Ilustracja bÅ‚Ä™du - brak typu zwracanego main"
		src="/img/tutorials/course/basic/functions/error-implicit-int-gcc.png"
	/>

</TabItem>
<TabItem value="msvc" label="MSVC">

```plaintext
error C4430: missing type specifier - int assumed. Note: C++ does not support default-int
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Ilustracja bÅ‚Ä™du - brak typu zwracanego main"
		src="/img/tutorials/course/basic/functions/error-implicit-int-msvc.png"
	/>

</TabItem>
</Tabs>

:::caution Rozszerzenia kompilatora
ZauwaÅ¼, Å¼e kompilator gcc w tym przypadku wystosowaÅ‚ tylko i wyÅ‚Ä…cznie ostrzeÅ¼enie, zamiast bÅ‚Ä™du.
Jak juÅ¼ wczeÅ›niej pisaÅ‚em, jest to dlatego, Å¼e niektÃ³re kompilatory mogÄ… zezwalaÄ‡ na pewne rzeczy w kodzie, ktÃ³re technicznie, wg standardu C++ nie powinny siÄ™ skompilowaÄ‡, w ramach rozszerzeÅ„.
Jak widaÄ‡, gcc pozwala na niezapisywanie typu zwracanego, jednak daje nam ostrzeÅ¼enie, Å¼e nie jest to poprawny kod.

Na rozszerzeniach nie powinno siÄ™ polegaÄ‡, poniewaÅ¼ sprawiajÄ… one, Å¼e nasz kod jest zaleÅ¼ny od kompilatora, mniej przenoÅ›ny i nie ma w 100% gwarantowanego dziaÅ‚ania.
:::

### ZwrÃ³cenie wartoÅ›ci innego typu niÅ¼ oczekiwany

Jak poznaliÅ›my w tej lekcji, funkcje albo mogÄ… zwracaÄ‡ wartoÅ›ci okreÅ›lonego typu, albo nie zwracaÄ‡ nic.
W obu przypadkach, musimy albo zwrÃ³ciÄ‡ wartoÅ›Ä‡ tego typu, albo nie zwracaÄ‡ nic, inaczej dostaniemy bÅ‚Ä…d.

<Tabs>
<TabItem value="function-returning-something" label="ğŸ”¢ Funkcja coÅ› zwracajÄ…ca" efault>

```cpp
int foo()
{
	return "?";
}

int main()
{
	foo();
}
```

W przypadku funkcji ktÃ³ra zwraca wartoÅ›Ä‡ innego typu, niÅ¼ zadeklarowany typ zwracany (tutaj zwracamy napis, kiedy typ zwracany to liczba),
dostaniemy bÅ‚Ä…d wewnÄ…trz funkcji ktÃ³ry mÃ³wi o niekompatybilnych typach, czasem ta informacja moÅ¼e byÄ‡ doÅ›Ä‡ nieczytelna.

#### ğŸ”´ TreÅ›Ä‡ bÅ‚Ä™du

<Tabs groupId="compiler">
<TabItem value="clang" label="CLANG" default>

```plaintext
error: cannot initialize return object of type 'int' with an lvalue of type 'const char [2]'
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Ilustracja bÅ‚Ä™du - niepoprawny cudzysÅ‚Ã³w"
		src="/img/tutorials/course/basic/functions/error-returning-string-from-int-clang.png"
	/>

</TabItem>
<TabItem value="gcc" label="GCC">

```plaintext
error: invalid conversion from â€˜const char*â€™ to â€˜intâ€™ [-fpermissive]
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Ilustracja bÅ‚Ä™du - niepoprawny cudzysÅ‚Ã³w"
		src="/img/tutorials/course/basic/functions/error-returning-string-from-int-gcc.png"
	/>

</TabItem>
<TabItem value="msvc" label="MSVC">

```plaintext
error C2440: 'return': cannot convert from 'const char [2]' to 'int'
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Ilustracja bÅ‚Ä™du - niepoprawny cudzysÅ‚Ã³w"
		src="/img/tutorials/course/basic/functions/error-returning-string-from-int-msvc.png"
	/>

</TabItem>
</Tabs>

</TabItem>
<TabItem value="function-returning-nothing" label="âšª Funkcja nic nie zwracajÄ…ca">

```cpp
void foo()
{
	return 5;
}

int main()
{
	foo();
}
```

W przypadku zwracania jakiejkolwiek wartoÅ›ci z funkcji, ktÃ³ra deklaruje, Å¼e Å¼adnej nie zwraca (tutaj zwracamy liczbÄ™, mimo, Å¼e mÃ³wimy, ze nie zwracamy nic),
dostaniemy czytelny bÅ‚Ä…d o tym, Å¼e zwracamy z funkcji, ktÃ³ra nie powinna nic zwracaÄ‡.

#### ğŸ”´ TreÅ›Ä‡ bÅ‚Ä™du

<Tabs groupId="compiler">
<TabItem value="clang" label="CLANG" default>

```plaintext
error: void function 'foo' should not return a value [-Wreturn-type]
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Ilustracja bÅ‚Ä™du - zwracanie wartoÅ›ci int z void"
		src="/img/tutorials/course/basic/functions/error-returning-int-from-void-clang.png"
	/>

</TabItem>
<TabItem value="gcc" label="GCC">

```plaintext
error: return-statement with a value, in function returning â€˜voidâ€™ [-fpermissive]
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Ilustracja bÅ‚Ä™du - zwracanie wartoÅ›ci int z void"
		src="/img/tutorials/course/basic/functions/error-returning-int-from-void-gcc.png"
	/>

</TabItem>
<TabItem value="msvc" label="MSVC">

```plaintext
error C2562: 'foo': 'void' function returning a value
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Ilustracja bÅ‚Ä™du - zwracanie wartoÅ›ci int z void"
		src="/img/tutorials/course/basic/functions/error-returning-int-from-void-msvc.png"
	/>

</TabItem>
</Tabs>

</TabItem>
</Tabs>

### Niezwracanie wartoÅ›ci

MÃ³wiliÅ›my wczeÅ›niej w lekcji o tablicach o tzw. **niezdefiniowanym zachowaniu**.
Niezdefiniowane zachowanie nie tyczy siÄ™ jednak tylko wychodzenia poza tablicÄ™. Tak naprawdÄ™ zachowaÅ„, ktÃ³ra uwaÅ¼a siÄ™ za niezdefiniowane jest bardzo wiele.
Jednym z nich jest niezwracanie wartoÅ›ci z funkcji, ktÃ³ra deklaruje, Å¼e zwraca wartoÅ›Ä‡ jakiegoÅ› typu, np.:

```cpp title="âŒ Funkcja niezwracajÄ…ca wartoÅ›ci"
#include <iostream>

int fun()
{}

int main()
{
	std::cout << fun();
}
```
Bardzo moÅ¼liwe, Å¼e dostaniemy ostrzeÅ¼enie o braku zwrÃ³conej wartoÅ›ci, ale kod ten powinien siÄ™ skompilowaÄ‡ siÄ™.
Kiedy bÄ™dziemy jednak prÃ³bowali uruchomiÄ‡ nasz program, moÅ¼emy siÄ™ zaskoczyÄ‡:

<Tabs groupId="platform">
<TabItem value="clang" label="CLANG, LINUX" default>

Skompilowany przez `clang` po uruchomieniu sprawia, Å¼e niektÃ³re powÅ‚oki pokazujÄ… bÅ‚Ä…d "Illegal instruction" lub nie pokazuje nic:

<Tabs groupId="shell">
<TabItem value="bash" label="BASH" default>

```plaintext
Illegal instruction
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Pokazanie segmentation fault - bash"
		src="/img/tutorials/course/basic/functions/error-no-return-bash.png"
	/>
</TabItem>
<TabItem value="zsh" label="ZSH">

```plaintext
zsh: illegal hardware instruction  <nazwa programu>
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Pokazanie segmentation fault - zsh"
		src="/img/tutorials/course/basic/functions/error-no-return-zsh.png"
	/>
</TabItem>
<TabItem value="fish" label="FISH">

```plaintext
fish: Job 1, '<nazwa programu>' terminated by signal SIGSEGV (Address boundary error)
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Pokazanie segmentation fault - fish"
		src="/img/tutorials/course/basic/functions/error-no-return-fish.png"
	/>

</TabItem>
</Tabs>
</TabItem>

<TabItem value="gcc" label="GCC">

Program skompilowany przez `gcc` po uruchomieniu nie pokazuje Å¼adnego bÅ‚Ä™du, a proces zwraca kod 0 - czyli wykonanie pomyÅ›lne.

</TabItem>

<TabItem value="msvc" label="MSVC">

W przypadku kompilatora `MSVC`, dostajemy jednak bÅ‚Ä…d, Å¼e `foo` musi zwracaÄ‡ wartoÅ›Ä‡:

```plaintext
error C4716: 'foo': must return a value
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Ilustracja bÅ‚Ä™du - bÅ‚Ä…d MSVC 'foo must return a value'"
		src="/img/tutorials/course/basic/functions/error-foo-must-return-a-value.png"
	/>

</TabItem>

</Tabs>

## Dodatkowe informacje

### Dedukcja typu i "wiodÄ…cy typ zwracany"

<Image center border
		src="/img/tutorials/course/basic/functions/auto-return-type-pl.png"
		desc="Schemat funkcji z dedukcjÄ… typu 'auto'"
	/>

Tak samo jak moÅ¼emy uÅ¼yÄ‡ sÅ‚Ã³wka kluczowego `auto` w przypadku zmiennych, aby typ zmiennej zostaÅ‚ wydedukowany przez kompilator,
moÅ¼emy rÃ³wnieÅ¼ zamiast typu zwracanego funkcji daÄ‡ `auto`, aby typ zwracanej wartoÅ›ci byÅ‚ wydedukowany, np.

```cpp title="ğŸ”¹ Dedukcja typu zwracanego funkcji"
auto println(std::string msg) {
	std::cout << msg << '\n';
}
```
Tutaj typ zwracany zostaje wydedukowany do `void`, bowiem nie zwracamy Å¼adnej wartoÅ›ci.

```cpp title="ğŸ”¹ Dedukcja typu zwracanego funkcji"
auto clamp(int value, int low, int high) {
	if(value < low) return low;
	if(value > high) return high;

	return value;
}
```
W przypadku funkcji wyÅ¼ej, typ zwracanej wartoÅ›ci to `int`.

:::note `clamp`
`clamp` to funkcja czÄ™sto uÅ¼ywana np. w gamedevie, aby upewniÄ‡ siÄ™, Å¼e gracz znajduje siÄ™ w pewnym ustalonym przedziale koordynatÃ³w na mapie.
Bierze wartoÅ›Ä‡ oraz przedziaÅ‚ w postaci dwÃ³ch kolejnych argumentÃ³w o tym samym typie.
Jej zadaniem jest upewnienie siÄ™, Å¼e dana wartoÅ›Ä‡ nie przekracza przedziaÅ‚u z Å¼adnej stron.


JeÅ›li wartoÅ›Ä‡ jest wiÄ™ksza od gÃ³rnej wartoÅ›ci, zwracana jest gÃ³rna wartoÅ›Ä‡:

<Image center border
		src="/img/tutorials/course/basic/functions/car-clamp-above-pl.png"
		desc="Auto nad koordynatami"
	/>

JeÅ›li wartoÅ›Ä‡ jest jest mniejsza od dolnej wartoÅ›ci, zwracana jest dolna wartoÅ›Ä‡:

<Image center border
		src="/img/tutorials/course/basic/functions/car-clamp-below-pl.png"
		desc="Auto pod koordynatami"
	/>

W przeciwnym wypadku zwracana jest oryginalna wartoÅ›Ä‡:

<Image center border
		src="/img/tutorials/course/basic/functions/car-clamp-in-between-pl.png"
		desc="Auto miÄ™dzy koordynatami"
	/>

OczywiÅ›cie w prawdziwej grze przy prÃ³bie przekroczenia poprawnych koordynatÃ³w akcja ich "clampowania" dzieje siÄ™ tak szybko, Å¼e gracz
nie ma nawet szansy zobaczyÄ‡, Å¼e wyszedÅ‚ poza ustalone granice, po prostu nie moÅ¼e przejechaÄ‡ dalej.

W C++ nie musimy jej rÃ³wnieÅ¼ pisaÄ‡ sami, w standardzie C++ znajdziemy funkcjÄ™ `std::clamp` znajdujÄ…cÄ… siÄ™ w nagÅ‚Ã³wku `<algorithm>`.
:::

Problemem z dedukcjÄ… wartoÅ›ci jest to, Å¼e nie moÅ¼e ona byÄ‡ stosowana zawsze.
GÅ‚Ã³wne dwa scenariusze w ktÃ³rych nie moÅ¼na stosowaÄ‡ dedukcji typu zwracanego, to:
1. Deklaracja funkcji przed jej definicjÄ…
2. Rekurencja

O rekurencji dowiemy siÄ™ kiedy indziej, jednak co do pierwszego punktu - gdy wywoÅ‚ujemy funkcjÄ™, kompilator musi znaÄ‡ wszystkie informacje o niej (nazwa, typ zwracany, argumenty).
Dedukcja typu zwracanego funkcji, jest moÅ¼liwa dopiero po poznaniu ciaÅ‚a, definicji funkcji. Dlatego nie moÅ¼emy uÅ¼yÄ‡ funkcji ktÃ³ra zostaÅ‚a zadeklarowana z `auto` zamiast typu,
przed poznaniem definicji.


<Tabs>
<TabItem value="bad" label="âŒ Å¹le" default>

```cpp
#include <iostream>

// highlight-next-line
auto clamp(int value, int low, int high);

int main()
{
	int playerY = 300;
	// highlight-next-line
	auto clampedPlayerY = clamp(playerY, 100, 200); // typ zwracany nie jest tutaj jeszcze znany, bÅ‚Ä…d kompilacji

	std::cout << clampedPlayerY << '\n';
}

auto clamp(int value, int low, int high)
{
	if(value < low) return low;
	if(value > high) return high;

	return value;
}
```

</TabItem>
<TabItem value="good" label="âœ” Dobrze" default>

```cpp
#include <iostream>

// highlight-next-line
auto clamp(int value, int low, int high)
{
	if(value < low) return low;
	if(value > high) return high;

	return value;
}

int main()
{
	int playerY = 300;
	// highlight-next-line
	auto clampedPlayerY = clamp(playerY, 100, 200); // ok, typ zwracany jest znany

	std::cout << clampedPlayerY << '\n';
}

```

</TabItem>
</Tabs>

Co ciekawe - C++ pozwala rÃ³wnieÅ¼ na podanie typu w tym przypadku.
Typ ten zapisujemy po strzaÅ‚ce, po deklaracji:
```cpp
auto clamp(int value, int low, int high) -> int;
```
Jest to rÃ³wnowaÅ¼ne z:
```cpp
int clamp(int value, int low, int high);
```
Notacja ta nazywa siÄ™ z angielskiego *trailing return type* (wiodÄ…cy typ zwracany).

Wiele innych jÄ™zykÃ³w uÅ¼ywa podobnej skÅ‚adni, funkcje w tego typu notacji lepiej ukÅ‚adajÄ… siÄ™ pod sobÄ… + sÄ… przypadki,
kiedy typ zwracany zaleÅ¼y od typu parametru i wtedy trzeba uÅ¼yÄ‡ tej notacji.

## Dobre praktyki

### Dobra nazwa

KaÅ¼da funkcja to pewien kod, ktÃ³ry reprezentuje jednÄ… logicznÄ… operacjÄ™.
Nawyk dobrego nazywania funkcji powinien wejÅ›Ä‡ w krew jak najszybciej,
albowiem nazwy funkcji bardzo wpÅ‚ywajÄ… na czytelnoÅ›Ä‡ kodu oraz kilka innych kluczowych jego aspektÃ³w.

Funkcja ma cel, ktÃ³ry ma wykonywaÄ‡, oraz implementacjÄ™. Celem bÄ™dzie np. policzenie rÃ³wnania kwadratowego, implementacjÄ… bÄ™dzie sam kod, ktÃ³ry bÄ™dzie to wykonywaÄ‡.
Nazwa funkcji powinna odwzorowywaÄ‡ **cel**, nie implementacjÄ™.

GÅ‚Ã³wnym tego powodem jest to, Å¼e osoby wywoÅ‚ujÄ…cÄ… funkcjÄ™ nie powinno interesowaÄ‡ to **w jaki sposÃ³b** dana funkcja coÅ› robi, tylko **co** robi.
Drugim powÃ³d jest taki, Å¼e implementacja funkcji moÅ¼e siÄ™ zmieniÄ‡ na przestrzeni rozwoju naszej aplikacji.
MoÅ¼emy zmieniaÄ‡, naprawiaÄ‡, dodawaÄ‡ i usuwaÄ‡ kod w Å›rodku (czyt. zmieniaÄ‡ implementacjÄ™), ale o ile cel naszej funkcji dalej jest taki sam - nazwa pozostanie taka sama,
co rÃ³wnieÅ¼ pozwoli uniknÄ…Ä‡ tzw. zÅ‚amania API (*ang. API breakage*).

:::note Åamanie API
Podstawowe pytanie - czym jest **API**?
**API**, z angielskiego to **A**plication **P**rogramming **I**nterface.

Brzmi tajemniczo, ale przyjrzyjmy siÄ™ temu trochÄ™ bliÅ¼ej. Czym jest **interfejs**?

WyobraÅºmy sobie pralkÄ™. Pralka ma w Å›rodku skomplikowanÄ… maszyneriÄ™, duÅ¼o elementÃ³w mechanicznych i elektronicznych,
ktÃ³rych celem jest finalnie wypranie naszych ubraÅ„.
My do komunikacji z pralkÄ… uÅ¼ywamy przyciskÃ³w, pokrÄ™tÅ‚, ekranÃ³w dotykowych, etc. To wÅ‚aÅ›nie jest **interfejs**. Pozwala on na interakcjÄ™ z pralkÄ….

W przypadku programowania, **API** to rÃ³wnieÅ¼ wszystko co pozwala na interakcjÄ™. Funkcja ma nazwÄ™, parametry i typ zwracany.
WeÅºmy dla przykÅ‚adu takÄ… funkcjÄ™:
```cpp
void assignPlayerToTeam(std::string player)
{
	...;
}
```
Mamy tutaj funkcjÄ™ `assignPlayerToTeam`.
W czÄ™Å›Ä‡ jej **interfejsu** wchodzi jej nazwa (`assignPlayerToTeam`), typy jej parametrÃ³w (`std::string`) oraz jej typ zwracany (`void`).

Dlaczego Å‚amanie API jest takie niebezpieczne?

CÃ³Å¼, wyobraÅº sobie, Å¼e masz caÅ‚Ä… halÄ™ peÅ‚nÄ… pralek oraz po jednym robocie obsÅ‚ugujÄ…cym kaÅ¼dÄ… pralkÄ™ (pralka - funkcja, robot - kod korzystajÄ…cy z funkcji).
```cpp
std::vector<float> washingMachine3000(std::string button, int knob)
{
	...
}
```
KaÅ¼dy robot jest dokÅ‚adnie nauczony gdzie znajduje siÄ™ jaka pralka,
gdzie na tej pralce sÄ… jakie przyciski i w jakiej kolejnoÅ›ci jakie akcje naleÅ¼y wykonaÄ‡, aby doprowadziÄ‡ do udanego wyprania ubraÅ„.
```cpp
std::vector<float> result = washingMachine3000("click", 123);
```

WyobraÅº sobie teraz, Å¼e producent tych pralek nagle podmienia swojÄ… czarodziejskÄ… rÃ³Å¼dÅ¼kÄ… wszystkie stare pralki na nowszy model.
MoÅ¼na powiedzieÄ‡ - powÃ³d do radoÅ›ci, w koÅ„cu nowszy model, pralki sÄ… szybsze, pobierajÄ… mniej wody i prÄ…du, super.
Nie do koÅ„ca - nowy model pralek ma zmieniony interfejs - poprzestawianie guziki, brak niektÃ³rych pokrÄ™tÅ‚,
zastÄ…pione innych elementÃ³w dotykowymi panelami (zmieniona nazwa funkcji, inny typ zwracany, inne typy czy kolejnoÅ›Ä‡ argumentÃ³w).
```cpp
std::string washingMachine5000(float touchPanel, std::string button)
{
	...
}
...
std::vector<float> result = washingMachine3000("click", 123); // oops!
```

Nagle kaÅ¼dy robot (kod korzystajÄ…cy z funkcji) szaleje i wybucha, poniewaÅ¼ kaÅ¼dy robot jest nauczony korzystaÄ‡ z okreÅ›lonej pralki (funkcji) w okreÅ›lony sposÃ³b,
jednak interfejs siÄ™ zmieniÅ‚, wiÄ™c nic nie dziaÅ‚a tak jak powinno.

Åamanie API to bardzo czÄ™sto sytuacja ktÃ³rej chcemy uniknÄ…Ä‡, poniewaÅ¼ sprawia duÅ¼o kÅ‚opotÃ³w programistom utrzymujÄ…cym kod, ktÃ³ry korzysta z naszych funkcji.
Nie zawsze jest to moÅ¼liwe i wtedy stosuje siÄ™ rÃ³Å¼nego rodzaju techniki, ktÃ³re powiadamiajÄ… programistÃ³w o **przyszÅ‚ym** zÅ‚amaniu obietnicy, ktÃ³rÄ… jest interfejs.
:::

### Jedna logiczna operacja

Funkcje powinny wykonywaÄ‡ tylko i wyÅ‚Ä…cznie jednÄ… logicznÄ… operacjÄ™, powinny realizowaÄ‡ tylko jeden cel na raz.
Wydzielanie jak najmniejszych kawaÅ‚kÃ³w kodu do funkcji niesie za sobÄ… caÅ‚y szereg korzyÅ›ci:

 - :::info ZwiÄ™kszenie **reuÅ¼ywalnoÅ›ci** funkcji
	JeÅ›li funkcje wykonujÄ… tylko jednÄ… logicznÄ… operacjÄ™, to jest wiÄ™ksza szansa, Å¼e bÄ™dzie moÅ¼na je wykorzystaÄ‡ w wielu miejscach,
	w porÃ³wnaniu do funkcji, ktÃ³re robiÄ… wiele rzeczy.

	JeÅ›li mamy funkcjÄ™, ktÃ³ra usuwa spacje z przodu i z tyÅ‚u napisu, to nie uÅ¼yjemy jej tam, gdzie bÄ™dziemy potrzebowaÄ‡ usunÄ…Ä‡ tylko spacje z przodu.
	Za to jeÅ›li bÄ™dziemy mieÄ‡ dwie funkcje - jednÄ… usuwajÄ…cÄ… spacje z przodu, a drugÄ… z tyÅ‚u, to nie doÅ›Ä‡, Å¼e bÄ™dziemy mogli zaimplementowaÄ‡ funkcjÄ™, ktÃ³ra
	usuwa znaki jednoczeÅ›nie i z przodu i tyÅ‚u na podstawie tamtych dwÃ³ch, to jeszcze bÄ™dzie mieli do dyspozycji dwie inne, bardziej specyficzne,
	usuwajÄ…ce tyko z przodu lub z tyÅ‚u.
	:::

 - :::info WiÄ™ksza szansa na optymalizacje
	Nie bÄ™dziemy siÄ™ wgÅ‚Ä™biaÄ‡ w powody dlaczego tak jest. Warto po prostu zapamiÄ™taÄ‡, Å¼e kompilator potrafi lepiej zoptymalizowaÄ‡ kod, ktÃ³ry
	uÅ¼ywa maÅ‚ych, dobrze podzielonych funkcji, w przeciwieÅ„stwie do takiego, w ktÃ³rym funkcje sÄ… duÅ¼e i nie wykonujÄ… maÅ‚ej iloÅ›ci operacji.
	:::

 - :::info Åatwiejszy w analizie kod
	MaÅ‚e funkcje sÄ… zazwyczaj Å‚atwiejsze w analizie niÅ¼ duÅ¼e funkcje.
	Kod korzystajÄ…cy z maÅ‚ych, dobrze nazwanych funkcji rÃ³wnieÅ¼ jest zazwyczaj Å‚atwiejszy w analizie, niÅ¼ taki, ktÃ³ry korzysta z funkcji,
	ktÃ³re ukrywajÄ… duÅ¼o rzeczy przed programistÄ….

	JeÅ›li funkcja nazywa siÄ™ `stringToInt`, to programista czytajÄ…c zapis `stringToInt("3113")` spodziewa siÄ™ tylko i wyÅ‚Ä…cznie zwrÃ³cenia przez tÄ™ funkcjÄ™
	liczby o wartoÅ›ci 3113, Å¼adnego wypisywania ani Å¼adnych innych akcji w tle. Wszystko co powinno byÄ‡ widoczne, bÄ™dzie w takim ukÅ‚adzie widoczne.
	:::

 - :::info Funkcje Å‚atwiejsze w testowaniu
	Testowanie nie jest tematem dla poczÄ…tkujÄ…cych, aczkolwiek zdecydowanie jest aspektem waÅ¼nym w pracy programisty.
	Testowanie polega na niczym innym niÅ¼ sprawdzaniu, czy kod napisany przez programistÄ™ jest poprawny (tzn. czy speÅ‚nia ustalone zaÅ‚oÅ¼enia).

	Testowanie funkcji, ktÃ³re same za siebie mÃ³wiÄ… co robiÄ…, sÄ… podzielone na logiczne operacje i nie majÄ… efektÃ³w ubocznych,
	jest znacznie prostsze, niÅ¼ testowanie potworÃ³w o niebotycznych wielkoÅ›ciach, rozwiÄ…zujÄ…cych wszystkie problemy Å›wiata.
	:::

 - :::info Funkcje Å‚atwiejsze w nazywaniu
	Tak jak juÅ¼ wczeÅ›niej powiedzieliÅ›my - nazwa funkcji powinna odzwierciedlaÄ‡ operacjÄ™, ktÃ³rÄ… ta funkcja wykonuje.
	Funkcje wykonujÄ…ce pojedyncze operacje nazwaÄ‡ jest doÅ›Ä‡ Å‚atwo i szybko.

	W przypadku funkcji, ktÃ³re nie podÄ…Å¼ajÄ… za tÄ… dobrÄ… praktykÄ…, musimy siÄ™ namyÅ›leÄ‡ jak oddaÄ‡ istotÄ™ funkcji, ktÃ³ra robi wiele rzeczy na raz, co jest
	oczywiÅ›cie trudniejsze.
	:::