---
sidebar_position:	7
sidebar_label:		"7. Funkcje"
title:				Funkcje
description:		"Lekcja: funkcje w jÄ™zyku C++"
tags:				[funkcja]
hide_title:			true
---

<!-- Presets -->
import NotFinished				from '@site/i18n/pl/presets/NotFinished.mdx';
import ImproveSection			from '@site/i18n/pl/presets/ImproveSection.mdx';

<!-- Components -->
import CustomCodeBlock			from '@site-comps/CustomCodeBlock';
import GoogleSlides				from '@site-comps/GoogleSlides';
import Columns					from '@site-comps/Columns';
import Image					from '@site-comps/Image';
import Tabs						from '@theme/Tabs';
import TabItem					from '@theme/TabItem';

<!-- Codes -->
import Code_TopExampleWithout				from "./_codes/functions/top-example-without.mdx";
import Code_TopExampleWith					from "./_codes/functions/top-example-with.mdx";

import Code_ExampleReuse					from "./_codes/functions/example-reuse.mdx";
import Code_ExampleReuseWithParam			from "./_codes/functions/example-reuse-with-param.mdx";
import Code_ExampleReuseWithParams			from "./_codes/functions/example-reuse-with-params.mdx";

<NotFinished/>

# Funkcje

W tej lekcji dowiesz siÄ™ jak nauczyÄ‡ program wykonywania akcji, z moÅ¼liwoÅ›ciÄ…
ich wielokrotnego uÅ¼ytku.

## Motywacja

Jednym z plusÃ³w uÅ¼ywania funkcji jest redukcja potwÃ³rzeÅ„ w kodzie. Zobacz przykÅ‚ad
poniÅ¼ej, w wersji bez uÅ¼ycia funkcji oraz z uÅ¼yciem. Na ten moment
nie musisz rozumieÄ‡ zapisu z przykÅ‚adu z funkcjÄ… - do wyjaÅ›nienia
przejdziemy w dalszej czÄ™Å›ci tej lekcji.

<hr/>

<Tabs>
	<TabItem value="without-functions" label="âš  Bez funkcji">
		<Code_TopExampleWithout />
	</TabItem>
	<TabItem value="with-function" label="ğŸŸ¢ Z funkcjÄ…">
		<Code_TopExampleWith />
	</TabItem>
</Tabs>

<hr/>

W przykÅ‚adzie powyÅ¼ej tworzymy tablicÄ™ liczb i modyfikujemy jÄ…, kaÅ¼dorazowo wyÅ›wietlajÄ…c zawartoÅ›Ä‡.
RÃ³Å¼nica miÄ™dzy tymi dwoma wersjami jest taka, Å¼e pierwszy zawiera fragment kodu, ktÃ³ry przekleiliÅ›my
parÄ™ razy komendÄ… kopiuj-wklej. W drugiej, bardziej prawidÅ‚owej wersji, jednorazowo **uczymy nasz program
jak wyÅ›wietliÄ‡ tablicÄ™ liczb** a nastÄ™pnie korzystamy z tego wielokrotnie wtedy, kiedy tego potrzebujemy.

Funkcje majÄ… jeszcze bardzo wiele innych zastosowaÅ„ i czÄ™Å›Ä‡ z nich w tej lekcji pokaÅ¼emy. PÃ³ki co jednak
musimy powrÃ³ciÄ‡ na sam poczÄ…tek do podstaw.

## Wprowadzenie

:::important Definicja
Funkcja to wydzielony fragment kodu, ktÃ³ry moÅ¼emy wielokrotnie wykorzystywaÄ‡.
:::

Od samego poczÄ…tku nauki w naszych programach umieszczaliÅ›my specjalnÄ… funkcjÄ™,
ktÃ³rÄ… jest `main`.

```cpp
int main() {
	// kod programu
}
```

Komputer uruchamiajÄ…c program znajduje funkcjÄ™ `main` a nastÄ™pnie jÄ… wykonuje,
przechodzÄ…c po kaÅ¼dej instrukcji wewnÄ…trz, linijka po linijce.

## Tworzenie funkcji

Zaczniemy od najprostszych funkcji, stopniowo przechodzÄ…c do coraz bardziej zaawansowanych.

### Bez parametrÃ³w

<Image center border
		src="/img/tutorials/course/basic/functions/proc-no-params-pl.png"
		desc="Schemat najprostszej funkcji"
	/>

Jak widzimy wyÅ¼ej, definiujÄ…c wÅ‚asnÄ… funkcjÄ™, musimy zadbaÄ‡ o jej nazwÄ™ oraz ciaÅ‚o, trzymajÄ…c
siÄ™ przy tym skÅ‚adni. Po sÅ‚owie `void` piszemy **nazwÄ™ funkcji**, nastÄ™pnie dajemy puste
**nawiasy okrÄ…gÅ‚e** (o tym powiemy dalej w tej lekcji), potem **bez Å›rednika** umieszczamy poniÅ¼ej
blok kodu, ktÃ³ry nazywamy **ciaÅ‚em funkcji**.

:::important Nazewnictwo
NazywajÄ…c funkcjÄ™ przestrzegamy tych samych zasad co przy [nazwach zmiennych](../variables/#nazwa-zmiennej).
:::

W ten sposÃ³b mamy juÅ¼ zdefiniowanÄ… funkcjÄ™. Oznacza to, Å¼e gdy tylko bÄ™dziemy tego chcieli, moÅ¼emy
jÄ… **wywoÅ‚aÄ‡**. Robimy to w ten sposÃ³b:

```cpp title="ğŸ”¹ WywoÅ‚anie funkcji"
print();
```

:::caution Uwaga
ZwrÃ³Ä‡ uwagÄ™, Å¼e dajemy **Å›rednik** po wywoÅ‚aniu funkcji.
:::

Napiszmy przykÅ‚adowÄ… funkcjÄ™, ktÃ³ra wyÅ›wietla 10 liczb parzystych i uÅ¼yjmy jej kilka razy:

<>
<Code_ExampleReuse />
</>

### Z parametrami

<Image center border
		src="/img/tutorials/course/basic/functions/proc-params-pl.png"
		desc="Schemat funkcji z parametrami"
	/>

DziaÅ‚anie funkcji moÅ¼emy uzaleÅ¼niÄ‡ od **parametrÃ³w**. ChcÄ…c, Å¼eby funkcja wyÅ›wietlaÅ‚a
dowolnie duÅ¼o liczb parzystych, moÅ¼emy utworzyÄ‡ w funkcji parametr,
ktÃ³ry bÄ™dzie to kontrolowaÅ‚. Parametr jest zmiennÄ… wewnÄ…trz funkcji, ktÃ³rÄ… tworzymy
w Å›rodku nawiasÃ³w okrÄ…gÅ‚ych:

<>
<Code_ExampleReuseWithParam />
</>

PowyÅ¼szy zapis

```cpp
printEvenNumbers(10);
```

oznacza, Å¼e w momencie wywoÅ‚ania, do parametru `howMany` wewnÄ…trz tej funkcji
zostanie przypisana wartoÅ›Ä‡ `10`. MoÅ¼emy do funkcji przekazywaÄ‡ dowolnÄ… liczbÄ™ parametrÃ³w.
Oddzielamy je przecinkami:

<>
<Code_ExampleReuseWithParams />
</>

:::danger Popularny bÅ‚Ä…d
ZauwaÅ¼, Å¼e kolejne parametry funkcji umieszczamy po przecinku, kaÅ¼dorazowo podajÄ…c jego typ.
CzÄ™stym bÅ‚Ä™dem wÅ›rÃ³d poczÄ…tkujÄ…cych jest pominiÄ™cie typu w nastÄ™pnych parametrach.

<Tabs>
<TabItem label="âŒ Å¹le" value="bad" default>

```cpp
void printBiggerNumber(int a, b)
```

</TabItem>
<TabItem label="âœ” Dobrze" value="good">

```cpp
void printBiggerNumber(int a, int b)
```

</TabItem>
</Tabs>

:::

### Instrukcja powrotu

MoÅ¼emy kazaÄ‡ programowi wczeÅ›niej powrÃ³ciÄ‡ z funkcji, za pomocÄ… instrukcji:

```cpp
return;
```

W momencie jej napotkania, program przestaje wykonywaÄ‡ kolejne instrukcje w funkcji
i wraca do miejsca, z ktÃ³rego zostaÅ‚a ona wywoÅ‚ana. Przytoczmy stworzonÄ… przez nas wczeÅ›niej
funkcjÄ™ `printEvenNumbers`:

```cpp
void printEvenNumbers(int howMany)
{
	for (int i = 0; i < howMany; i++)
		std::cout << (i * 2) << ' ';
	std::cout << '\n';
}
```

Co siÄ™ stanie, jeÅ›li podamy ujemnÄ… liczbÄ™ do `howMany`?

```cpp
printEvenNumbers(-10);
```

Wykonywanie funkcji z takÄ… wartoÅ›ciÄ… parametru nie ma sensu, dlatego moÅ¼emy to juÅ¼ na samym poczÄ…tku
wychwyciÄ‡ i wykonaÄ‡ powrÃ³t:

```cpp
void printEvenNumbers(int howMany)
{
	if (howMany <= 0)
		return;

	for (int i = 0; i < howMany; i++)
		std::cout << (i * 2) << ' ';
	std::cout << '\n';
}
```

Teraz gdy podamy wartoÅ›Ä‡ mniejszÄ… lub rÃ³wnÄ… zero do parametru funkcji, funkcja juÅ¼ na poczÄ…tku zostanie przerwana.

### WartoÅ›Ä‡ zwracana

<Image center border
		src="/img/tutorials/course/basic/functions/retval-params-pl.png"
		desc="Schemat funkcji z parametrami i wartoÅ›ciÄ… zwracanÄ…"
	/>


Funkcje mogÄ… pozostawiÄ‡ po swoim wykonaniu pewien **rezultat**. Åatwiej bÄ™dzie to zrozumieÄ‡ gdy zastosujemy analogiÄ™ do
realnego Å¼ycia. Rodzic wysyÅ‚a swoje dziecko do sklepu po 10 jajek. Po powrocie dziecka, bÄ™dzie chciaÅ‚ wiedzieÄ‡,
czy udaÅ‚o mu siÄ™ kupiÄ‡ tyle ile poprosiÅ‚, czy nie. Tak samo my, wykonujÄ…c niektÃ³re funkcje w kodzie,
chcemy znaÄ‡ ich rezultat, czyli **wartoÅ›Ä‡ zwracanÄ…**.

#### Typ zwracanej wartoÅ›ci

Wymagane jest, aby okreÅ›liÄ‡ jakiego typu jest wartoÅ›Ä‡ zwracana. Podajemy go **przed** nazwÄ… funkcji, przykÅ‚adowo:

```cpp title="ğŸ”¹ Zwracamy liczbÄ™ caÅ‚kowitÄ…" 
int sum(int from, int to)
```

```cpp title="ğŸ”¹ Brak zwracanej wartoÅ›ci"
void print(int number)
```

ZauwaÅ¼, Å¼e wprowadziliÅ›my nowy typ: `void` (z ang.: *pusty*). JeÅ›li wpiszemy go w miejsce typu zwracanego,
bÄ™dzie to oznaczaÅ‚o, Å¼e funkcja nie zwraca wartoÅ›ci, tj. nie potrzebujemy znaÄ‡ jej rezultatu.
ZauwaÅ¼, Å¼e z `void` korzystaliÅ›my w poprzednich sekcjach tej lekcji, wÅ‚aÅ›nie z tego powodu.

:::danger Typ pusty i zmienne
Typ `void` nie moÅ¼e byÄ‡ uÅ¼yty do stworzenia zmiennej:

```cpp title="âŒ NieprawidÅ‚owy zapis"
void variable;
```

Zmienna z zaÅ‚oÅ¼enia przechowuje wartoÅ›Ä‡, co byÅ‚oby niemoÅ¼liwe gdyby byÅ‚a typu `void`.
:::

#### Zastosowanie

Zaimplementujmy funkcjÄ™ ze schematu wyÅ¼ej. Ma ona zliczyÄ‡ sumÄ™ wszystkich liczb w zakresie od `from` do `to` wÅ‚Ä…cznie.

```cpp
int sum(int from, int to)
{
	int result = 0;
	for (int i = from; i <= to; i++)
		result += i;
	return result;
}
```

ZwrÃ³conÄ… wartoÅ›Ä‡ moÅ¼emy uÅ¼yÄ‡ np. zapisujÄ…c jÄ… do zmiennej:

```cpp title="ğŸ”¹ Zapisywanie rezultatu do zmiennej"
int s = sum(10, 100);
```

... lub uÅ¼yÄ‡ w wyraÅ¼eniu (np. jako parametr funkcji):

```cpp title="ğŸ”¹ UÅ¼ywanie rezultatu"
std::cout << "Suma liczb z zakresu [10; 100] wynosi: " << sum(10, 100);
```

#### Wymogi

:::danger ZwrÃ³cenie wartoÅ›ci jest obowiÄ…zkowe
Funkcja, ktÃ³ra zwraca jakÄ…Å› wartoÅ›Ä‡ (wszystko poza typem `void`), **musi** na samym koÅ„cu swojego wykonania
zwrÃ³ciÄ‡ jakÄ…Å› wartoÅ›Ä‡.

```cpp title="âŒ BÅ‚Ä…d: brak zwracanej wartoÅ›ci"
int sum(int from, int to)
{
	int result = 0;
	for (int i = from; i <= to; i++)
		result += i;
	// highlight-next-line
	// âŒ Brak instrukcji return!
}
```

WyjÄ…tkiem jest funkcja `main`, ktÃ³ra mimo zwracania typu `int`, wykonuje automatyczne zwrÃ³cenie wartoÅ›ci
gdy pominiemy `return`:

```cpp title="âœ” OK"
int main() {
	// Brak instrukcji return
}
```

O funkcji `main` powiemy wiÄ™cej w przyszÅ‚oÅ›ci.

:::

### Deklaracja a definicja

Aby mÃ³c uÅ¼yÄ‡ powyÅ¼szej funkcji `sum`, musimy upewniÄ‡ siÄ™, Å¼e znajduje siÄ™ ona **przed** tym uÅ¼yciem, przykÅ‚adowo:

<Tabs>
<TabItem value="bad" label="âŒ Å¹le" default>

```cpp
#include <iostream>

int main()
{
	// Uwaga, uÅ¼ycie przed definicjÄ…
	// highlight-next-line
	std::cout << "Suma liczb z zakresu [10; 100] wynosi: " << sum(10, 100); // âŒ
}

// highlight-next-line
int sum(int from, int to)
{
	int result = 0;
	for (int i = from; i <= to; i++)
		result += i;
	return result;
}
```

</TabItem>
<TabItem value="good" label="âœ” Dobrze">

```cpp
#include <iostream>

int sum(int from, int to)
{
	int result = 0;
	for (int i = from; i <= to; i++)
		result += i;
	return result;
}

int main()
{
	std::cout << "Suma liczb z zakresu [10; 100] wynosi: " << sum(10, 100);
}
```

</TabItem>
</Tabs>

Dbanie o to, Å¼eby kolejnoÅ›Ä‡ zawsze siÄ™ zgadzaÅ‚a jest uciÄ…Å¼liwe a czasami nawet niemoÅ¼liwe.
Å»eby naprawiÄ‡ bÅ‚Ä…d z powyÅ¼szego przykÅ‚adu musimy zastosowaÄ‡ tzw. **deklaracjÄ™ funkcji**.

PÃ³ki co tworzÄ…c funkcjÄ™, uÅ¼ywaliÅ›my **definicjÄ™ funkcji**, ktÃ³ra oprÃ³cz deklaracji,
zawiera teÅ¼ caÅ‚Ä… jej implementacjÄ™ (ciaÅ‚o). Deklarowanie funkcji wyglÄ…da jak jej definiowanie,
**bez podawania jej ciaÅ‚a**. Musimy teÅ¼ zadbaÄ‡, Å¼eby po deklaracji daÄ‡ Å›rednik.

<Columns columns={['1fr', '1fr']}>
<div>

```cpp title="ğŸ”µ Definicja"
int sum(int from, int to)
{
	int result = 0;
	for (int i = from; i <= to; i++)
		result += i;
	return result;
}
```

</div>
<div>

```cpp title="ğŸŸ£ Deklaracja"
int sum(int from, int to);
```

</div>
</Columns>

Zasada jest taka, Å¼e aby uÅ¼yÄ‡ funkcji, musi byÄ‡ ona wczeÅ›niej **zadeklarowana**.
Definicja musi siÄ™ pojawiÄ‡, jednak nie ma znaczenia czy bÄ™dzie ona przed czy po uÅ¼yciu.
Oto dwa przykÅ‚ady:

<Tabs>
<TabItem value="good" label="âœ” OK" default>

```cpp
#include <iostream>

// ğŸŸ£ Deklaracja
// highlight-next-line
int sum(int from, int to);

int main()
{
	std::cout << "Suma liczb z zakresu [10; 100] wynosi: " << sum(10, 100);
}

// ğŸ”µ Definicja
// highlight-next-line
int sum(int from, int to)
{
	int result = 0;
	for (int i = from; i <= to; i++)
		result += i;
	return result;
}
```

</TabItem>
<TabItem value="good2" label="âœ” OK (definicja przed)">

```cpp
#include <iostream>

// ğŸŸ£ Deklaracja
// highlight-next-line
int sum(int from, int to);

// ğŸ”µ Definicja
// highlight-next-line
int sum(int from, int to)
{
	int result = 0;
	for (int i = from; i <= to; i++)
		result += i;
	return result;
}

int main()
{
	std::cout << "Suma liczb z zakresu [10; 100] wynosi: " << sum(10, 100);
}
```

</TabItem>
<TabItem value="good3" label="âœ” OK (wiele dekl.)">

```cpp
#include <iostream>

// ğŸŸ£ Deklaracje
// highlight-start
int sum(int from, int to);
int sum(int from, int to); // OK, wiele deklaracji dopuszczalne
int sum(int from, int to); // tylko po co to tutaj? ğŸ¤”
// highlight-end

int main()
{
	std::cout << "Suma liczb z zakresu [10; 100] wynosi: " << sum(10, 100);
}

// ğŸ”µ Definicja
// highlight-next-line
int sum(int from, int to)
{
	int result = 0;
	for (int i = from; i <= to; i++)
		result += i;
	return result;
}
```

</TabItem>
</Tabs>

:::danger Zasada jednej definicji (ang.: *ODR*)
Definicja **musi** pojawiÄ‡ siÄ™ w kodzie **tylko raz** (deklaracji moÅ¼e byÄ‡ wiele).
:::

## PrzykÅ‚ady âš 

<ImproveSection />

## Potencjalne bÅ‚Ä™dy âš 

<ImproveSection />

## Dodatkowe informacje âš 

<ImproveSection />