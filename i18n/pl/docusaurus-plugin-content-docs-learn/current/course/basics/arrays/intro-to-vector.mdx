---
sidebar_position:	1
sidebar_label:		"1. Wstp do vector-贸w"
title:				Wstp do vector-贸w
description: 		"Lekcja: wstp do tablic z u偶yciem vectora w jzyku C++"
hide_title:			true
---

<!-- Components -->
import Image			from "@site-comps/Image";

<!-- Presets -->
import NotFinished		from "@site/i18n/pl/presets/NotFinished.mdx";
import ImproveSection	from "@site/i18n/pl/presets/ImproveSection.mdx";

<NotFinished />

# Wstp do `std::vector`

W tej lekcji poka偶 Ci czym s i do czego su偶 tablice, w ich
najprostszej formie, z u偶yciem narzdzia [`std::vector`](/docs/std/containers/arrays/vector/).

## Motywacja

Za贸偶my, 偶e chcemy przechowywa nicki graczy, kt贸rzy s na serwerze.
Nick jest tekstem, kt贸ry bdziemy zapisywa w zmiennej typu [`std::string`](/docs/std/containers/strings/string/).

```cpp
#include <iostream>
#include <string>

int main()
{
	std::string playerName1;
	std::string playerName2;
	std::string playerName3;

	std::cout << "Podaj nick gracza 1: ";
	std::cin >> playerName1;

	std::cout << "Podaj nick gracza 2: ";
	std::cin >> playerName2;

	std::cout << "Podaj nick gracza 3: ";
	std::cin >> playerName3;
}
```

Zakadajc, 偶e mamy trzech graczy na serwerze, mo偶emy skonstruowa
kod taki jak wy偶ej. W sytuacji, gdy bdziemy chcieli mie
5 graczy, bdziemy musieli bawi si komend "kopiuj -> wklej"
dodatkowe razy. Powtarzanie tego bardzo szybko traci sens.
Czy istnieje narzdzie, kt贸re pozwoli nam skr贸ci ten kod
i nie u偶ywa tyle razy kopiowania?

Posu偶 nam do tego **tablice**.

## Czym jest tablica

<Image center border
		maxheight="300px"
		src="/img/tutorials/course/basic/arrays/car-brand-names-pl.png"
		alt="Tablica zawierajca marki pojazd贸w"
	/>
<br/>


Tablica to kontener, kt贸ry mo偶e przechowywa wewntrz *ile* element贸w
jakiego okrelonego typu. Popatrz na wy偶ej umieszczon ilustracj.
Wewntrz tablicy, znajduj si nazwy marek pojazd贸w. Zauwa偶, 偶e
ka偶dy element ma sw贸j unikalny **indeks**.

Istniej tablice o staym rozmiarze, kt贸re zawsze maj tyle samo element贸w,
oraz **dynamiczne** tablice, kt贸rych rozmiar mo偶e si zmienia.

:::important Indeksy tablicy
Elementy tablicy s **indeksowane od zera** w g贸r.
Pierwszy element ma indeks `0`, drugi `1` itd.
:::

Indeksy pozwalaj rozr贸偶ni poszczeg贸lne elementy tablicy.
Za ich pomoc mo偶emy korzysta z tych element贸w w kodzie.

## U偶ywanie tablic

W kodzie, podanym wy偶ej w sekcji [**Motywacja**](#motywacja), mamy bardzo dobrych
kandydat贸w, do zrobienia z nich jednej tablicy.

Zmienne

```cpp
std::string playerName1;
std::string playerName2;
std::string playerName3;
```

s tego samego typu i r贸偶ni si tylko numerkiem.
Zamiast robi trzy osobne, mo偶emy stworzy jedn
**tablic**, kt贸ra zawiera trzy elementy:

### Tworzenie zmiennej tablicowej

```cpp
#include <iostream>
#include <string>
#include <vector> // niezbdne do korzystania z std::vector

int main()
{
	std::vector< std::string > playerNames(3);
	// ...
}
```

呕eby u偶y typu `std::vector`, musimy doda kolejnego `#include`, tym razem:

```cpp
#include <vector>
```

`vector` jest tzw. szablonem, a to oznacza, 偶e mo偶na go u偶y z r贸偶nymi typami,
kt贸re podajemy w **nawiasie ostrym**, zaraz po `std::vector`:

```cpp
std::vector< int >
std::vector< float >
std::vector< char >
std::vector< std::string >
std::vector< /*cokolwiek*/ >
```

Ale co to oznacza "*vector danego typu*"? Nale偶y rozumie przez to tyle,
偶e `std::vector< T >` przechowuje elementy typu `T`.

Zapis:
```cpp
std::vector< std::string > playerNames(3);
```

oznacza, 偶e tworzymy *zmienn typu tablicowego* o nazwie `playerNames`,
kt贸ra przechowuje teksty (`std::string`).

Nawias z tr贸jk w rodku na kocu tego zapisu:

```cpp
playerNames(3)
```

sprawi, 偶e przy utworzeniu tej tablicy, zostan utworzone
automatycznie wewntrz niej `3` zmienne typu `std::string`.

### Dostp do element贸w

Mo偶emy w ka偶dej chwili dosta si do elementu tablicy, korzystajc
z jego indeksu:

```cpp
#include <iostream>
#include <string>
#include <vector>

int main()
{
	std::vector< std::string > playerNames(3);

	// Ustawianie nazw graczy:
	playerNames[0] = "HappyBanana";
	playerNames[1] = "AngryCrab";
	playerNames[2] = "SadWolf";

	// Wywietlenie nazw graczy:
	std::cout << "Gracz 0 ma nick: " << playerNames[0];
}
```

:::important Elementy tablicy
Aby uzyska dostp do elementu tablicy, podajemy jego indeks
**w nawiasie kwadratowym**, zaraz po nazwie tablicy:

```cpp
tablica[ indeks ]
```
:::

### Dodawanie element贸w

Na ten moment nasza tablica ma 3 elementy, o indeksach `0`, `1` i `2`:

| Indeks | Nazwa |
| ------ | ---- |
| 0      | HappyBanana |
| 1      | AngryCrab   |
| 2      | SadWolf     |

Aby doda kolejny element do tablicy, musimy skorzysta z `push_back`.
U偶ywamy tego w ten spos贸b:

```cpp title=" Dodawanie elementu do tablicy"
#include <iostream>
#include <string>
#include <vector>

int main()
{
	std::vector< std::string > playerNames(3);

	// Ustawianie nazw graczy:
	playerNames[0] = "HappyBanana";
	playerNames[1] = "AngryCrab";
	playerNames[2] = "SadWolf";

	// Dodawanie nowego gracza:
	// highlight-next-line
	playerNames.push_back("WickedWitch");

	// Wywietlenie nazw graczy:
	std::cout << "Gracz 3 ma nick: " << playerNames[3];
}
```

Od momentu wywoania `push_back`, tablica `playerNames` ma ju偶 cztery elementy.
Powy偶szy zapis u偶ywa tzw. *wywoania metody `push_back()`*. O wywoaniach
i metodach powiemy sobie w przyszoci wicej. Na ten moment zapamitaj tylko ten
zapis:

- po nazwie tablicy dajemy kropk
- piszemy nazw *metody*, czyli w tym wypadku `push_back`
- nastpnie w nawiasie okrgym podajemy co chcemy doda (np. warto lub zmienn)

:::important Zakres indeks贸w
Zwr贸 uwag, 偶e tablica o iloci element贸w `N`, zawsze ma indeksy
od `0` do `N-1` wcznie. Czteroelementowa tablica `playerNames`
ma indeksy od `0` do `3` wcznie.
:::

Pr贸ba zapisania do tablicy o indeksie `4` spowoduje bd:

```cpp title=" Bd wykonania"
playerNames[4] = "NewPlayer"; // BD!
```

Powodem jest to, 偶e element o indeksie `4` nie istnieje.
Taki kod zostanie poprawnie skompilowany (by mo偶e dostaniemy ostrze偶enie),
ale uruchomienie tego programu spowoduje bd.

### Odczytywanie rozmiaru

Aktualny rozmiar tablicy mo偶emy odczyta u偶ywajc metody `size()`:

```cpp
// Ustawianie nazw graczy:
playerNames[0] = "HappyBanana";
playerNames[1] = "AngryCrab";
playerNames[2] = "SadWolf";

// highlight-next-line
std::cout << "Tablica posiada " << playerNames.size() << " element贸w\n";

// Dodawanie nowego gracza:
playerNames.push_back("WickedWitch");
std::cout << "Dodano nowego gracza.\n";
// highlight-next-line
std::cout << "Tablica posiada " << playerNames.size() << " element贸w\n";
```

Tak jak wy偶ej z metod `push_back`, piszemy nazw po kropce i dajemy
nawiasy okrge, w tym wypadku puste.

### Usuwanie element贸w

Na tym etapie nauki bdziesz musia/a mi troch zaufa.
Nie bd zagbia si w szczeg贸y, bo to na teraz zbyt skomplikowane.
Aby usun `n`-ty element z vectora (np. z `playerNames`), u偶ywamy zapisu:

```cpp title=" Usuwanie z tablicy"
playerNames.erase( playerNames.begin() + n );
```

W bardzo du偶ym uproszczeniu `erase` usuwa konkretny element, ale sam indeks nie wystarczy.
Musimy u偶y `begin()` i doda do niego ten indeks.

:::tip Zapamitaj
Mo偶esz zapamita to rozr贸偶niajc te dwa pojcia:

- **indeks** (liczba nieujemna)
- **pozycja**

S to dwie r贸偶ne, ale tematycznie zbli偶one rzeczy. Do `erase` podajemy *pozycj*, kt贸r uzyskujemy wanie
dodajc *indeks* do *pozycji poczatkowej* (`playerNames.begin()`).
:::

:::danger Uwaga
Zanim usuniesz dany element tablicy, upewnij si, 偶e istnieje (czyli jest z zakresu `[0, N)`).

```cpp title=" Usuwanie z tablicy (zabezpieczone)"
int index;
std::cin >> index;

if (index >= 0 && index < playerNames.size())
{
	playerNames.erase( playerNames.begin() + index );
}
else
	std::cout << "Indeks " << index << " nie jest prawidowy!";
```
:::

### Wywietlanie element贸w

Jeli chcemy wywietli **wszystkie** elementy tablicy, bedziemy musieli u偶y **ptli**.
O ptlach powiemy sobie w przyszoci wicej. Ptla pozwala wykona ten sam fragment
kodu wielokrotnie.

```cpp title=" Wywietlanie element贸w"
for (std::string name : playerNames)
{
	std::cout << "Nick gracza: " << name << '\n';
}
```

呕eby to zrozumie, poka偶 Ci jak to "przeczyta":

```cpp
for (std::string name : playerNames)
```

> **Dla** <small>(`for`)</small> **ka偶dej nazwy** <small>(`name`)</small> **kt贸ra jest typu** `std::string`
> **z tablicy** `playerNames` **wykonuj nastpujcy blok kodu...**

Wewntrz tego bloku kodu jest tylko jedna instrukcja:

```cpp
std::cout << "Nick gracza: " << name << '\n';
```

Ptla bdzie zapisywa kolejno nicki gracz贸w do zmiennej `name`,
i wykonywa dla ka偶dego z nich instrukcj wywietlenia.

:::tip Dedukcja typu
**Jeli mo偶na atwo si domyle** jakiego typu elementy przechowuje tablica,
mo偶esz skr贸ci zapis:

```cpp
for (std::string name : playerNames)
```

do

```cpp
for (auto name : playerNames)
```

wtedy `auto` spowoduje, 偶e typ elementu zostanie wykryty automatycznie.
:::

## Potencjalne bdy

### Brak nag贸wka `<vector>`

<ImproveSection />

### Mieszanie typ贸w

<ImproveSection />

### Wyjcie poza rozmiar tablicy

<ImproveSection />

