---
sidebar_position:	1
sidebar_label:		"1. WstÄ™p do vector-Ã³w"
title:				WstÄ™p do vector-Ã³w
description: 		"Lekcja: wstÄ™p do tablic z uÅ¼yciem vectora w jÄ™zyku C++"
hide_title:			true
---

<!-- Components -->
import Image			from "@site-comps/Image";

<!-- Presets -->
import NotFinished		from "@site/i18n/pl/presets/NotFinished.mdx";
import ImproveSection	from "@site/i18n/pl/presets/ImproveSection.mdx";
import Tabs				from '@theme/Tabs';
import TabItem			from "@theme/TabItem";

<NotFinished />

# WstÄ™p do `std::vector`

W tej lekcji pokaÅ¼Ä™ Ci czym sÄ… i do czego sÅ‚uÅ¼Ä… tablice, w ich
najprostszej formie, z uÅ¼yciem typu [`std::vector`](/docs/std/containers/arrays/vector/).

## Motywacja

ZaÅ‚Ã³Å¼my, Å¼e chcemy przechowywaÄ‡ nicki graczy, ktÃ³rzy sÄ… na serwerze.
Nick jest tekstem, ktÃ³ry bÄ™dziemy zapisywaÄ‡ w zmiennej typu [`std::string`](/docs/std/containers/strings/string/).

```cpp
#include <iostream>
#include <string>

int main()
{
	std::string playerName1;
	std::string playerName2;
	std::string playerName3;

	std::cout << "Podaj nick gracza 1: ";
	std::cin >> playerName1;

	std::cout << "Podaj nick gracza 2: ";
	std::cin >> playerName2;

	std::cout << "Podaj nick gracza 3: ";
	std::cin >> playerName3;
}
```

ZakÅ‚adajÄ…c, Å¼e mamy trzech graczy na serwerze, moÅ¼emy napisaÄ‡ kod taki jak wyÅ¼ej.
W sytuacji, gdy bÄ™dziemy chcieli mieÄ‡ 5 graczy,
bÄ™dziemy musieli bawiÄ‡ siÄ™ komendÄ… "kopiuj -> wklej" dodatkowe dwa razy.
Powtarzanie tego bardzo szybko traci sens. 
Czy istnieje narzÄ™dzie, ktÃ³re pozwoli nam skrÃ³ciÄ‡ ten kod i nie uÅ¼ywaÄ‡ tyle razy kopiowania?

PosÅ‚uÅ¼Ä… nam do tego **tablice**.

## Czym jest tablica?

<Image center border
		maxheight="300px"
		src="/img/tutorials/course/basic/arrays/car-brand-names-pl.png"
		alt="Tablica zawierajÄ…ca marki pojazdÃ³w"
	/>
<br/>

Tablica to kontener, ktÃ³ry moÅ¼e przechowywaÄ‡ wewnÄ…trz *ileÅ›* elementÃ³w
jakiegoÅ› okreÅ›lonego typu. Popatrz na wyÅ¼ej umieszczonÄ… ilustracjÄ™.
WewnÄ…trz tablicy, znajdujÄ… siÄ™ nazwy marek pojazdÃ³w. ZauwaÅ¼, Å¼e
kaÅ¼dy element ma swÃ³j unikalny **indeks**.

IstniejÄ… tablice o staÅ‚ym rozmiarze, ktÃ³re zawsze majÄ… tyle samo elementÃ³w,
oraz **dynamiczne** tablice, ktÃ³rych rozmiar moÅ¼e siÄ™ zmieniaÄ‡.

:::important Indeksy tablicy
Elementy tablicy sÄ… **indeksowane od zera** w gÃ³rÄ™.
Pierwszy element ma indeks `0`, drugi `1` itd.
:::

Indeksy pozwalajÄ… rozrÃ³Å¼niÄ‡ poszczegÃ³lne elementy tablicy.
Za ich pomocÄ… moÅ¼emy korzystaÄ‡ z tych elementÃ³w w kodzie.

## UÅ¼ywanie tablic

W kodzie, podanym wyÅ¼ej w sekcji [**Motywacja**](#motywacja), mamy bardzo dobrych
kandydatÃ³w, do zrobienia z nich jednej tablicy.

Zmienne

```cpp
std::string playerName1;
std::string playerName2;
std::string playerName3;
```

sÄ… tego samego typu i rÃ³Å¼niÄ… siÄ™ tylko numerkiem.
Zamiast robiÄ‡ trzy osobne, moÅ¼emy stworzyÄ‡ jednÄ…
**tablicÄ™**, ktÃ³ra zawiera trzy elementy:

### Tworzenie zmiennej tablicowej

```cpp
#include <iostream>
#include <string>
// highlight-next-line
#include <vector> // niezbÄ™dne do korzystania z std::vector

int main()
{
	// highlight-next-line
	std::vector< std::string > playerNames(3);
	// ...
}
```

Å»eby uÅ¼yÄ‡ typu `std::vector`, musimy dodaÄ‡ kolejnego `#include`, tym razem:

```cpp
#include <vector>
```

`vector` jest tzw. szablonem, a to oznacza, Å¼e moÅ¼na go uÅ¼yÄ‡ z rÃ³Å¼nymi typami,
ktÃ³re podajemy w **nawiasie ostrym**, zaraz po `std::vector`:

```cpp
std::vector< int >
std::vector< float >
std::vector< char >
std::vector< std::string >
std::vector< /*cokolwiek*/ >
```

Ale co to oznacza "*vector danego typu*"? NaleÅ¼y rozumieÄ‡ przez to tyle,
Å¼e `std::vector< T >` przechowuje elementy typu `T`.

Zapis:
```cpp
std::vector< std::string > playerNames(3);
```

oznacza, Å¼e tworzymy *zmiennÄ… typu tablicowego* o nazwie `playerNames`,
ktÃ³ra przechowuje teksty (`std::string`).

Nawias z trÃ³jkÄ… w Å›rodku na koÅ„cu tego zapisu:

```cpp
playerNames(3)
```

sprawi, Å¼e przy utworzeniu tej tablicy, zostanÄ… utworzone
automatycznie wewnÄ…trz niej `3` zmienne typu `std::string`.

### DostÄ™p do elementÃ³w

MoÅ¼emy w kaÅ¼dej chwili dostaÄ‡ siÄ™ do elementu tablicy, korzystajÄ…c
z jego indeksu:

```cpp
#include <iostream>
#include <string>
#include <vector>

int main()
{
	std::vector< std::string > playerNames(3);

	// Ustawianie nazw graczy:
	playerNames[0] = "HappyBanana";
	playerNames[1] = "AngryCrab";
	playerNames[2] = "SadWolf";

	// WyÅ›wietlenie nazw graczy:
	std::cout << "Gracz 0 ma nick: " << playerNames[0];
}
```

:::important Elementy tablicy
Aby uzyskaÄ‡ dostÄ™p do elementu tablicy, podajemy jego indeks
**w nawiasie kwadratowym**, zaraz po nazwie tablicy:

```cpp
tablica[ indeks ]
```
:::

### Dodawanie elementÃ³w

Na ten moment nasza tablica ma 3 elementy, o indeksach `0`, `1` i `2`:

| Indeks | Nazwa |
| ------ | ---- |
| 0      | HappyBanana |
| 1      | AngryCrab   |
| 2      | SadWolf     |

Aby dodaÄ‡ kolejny element do tablicy, musimy skorzystaÄ‡ z metody `push_back`.
UÅ¼ywamy jej analogicznie jak metod w przypadku `std::string`:

```cpp title="ğŸ”¹ Dodawanie elementu do tablicy"
#include <iostream>
#include <string>
#include <vector>

int main()
{
	std::vector< std::string > playerNames(3);

	// Ustawianie nazw graczy:
	playerNames[0] = "HappyBanana";
	playerNames[1] = "AngryCrab";
	playerNames[2] = "SadWolf";

	// Dodawanie nowego gracza:
	// highlight-next-line
	playerNames.push_back("WickedWitch");

	// WyÅ›wietlenie nazw graczy:
	std::cout << "Gracz 3 ma nick: " << playerNames[3];
}
```

Od momentu wywoÅ‚ania `push_back`, tablica `playerNames` ma juÅ¼ cztery elementy.

:::important Zakres indeksÃ³w
ZwrÃ³Ä‡ uwagÄ™, Å¼e tablica o iloÅ›ci elementÃ³w `N`, zawsze ma indeksy
od `0` do `N-1` wÅ‚Ä…cznie. Czteroelementowa tablica `playerNames`
ma indeksy od `0` do `3` wÅ‚Ä…cznie.
:::

PrÃ³ba zapisania do tablicy o indeksie `4` spowoduje bÅ‚Ä…d:

```cpp title="ğŸ”´ BÅ‚Ä…d wykonania"
// error-next-line
playerNames[4] = "NewPlayer"; // BÅ‚Ä…d!
```

Powodem jest to, Å¼e element o indeksie `4` nie istnieje.
Taki kod zostanie poprawnie skompilowany (byÄ‡ moÅ¼e dostaniemy ostrzeÅ¼enie),
ale uruchomienie tego programu spowoduje bÅ‚Ä…d.

### Odczytywanie rozmiaru

Aktualny rozmiar tablicy moÅ¼emy odczytaÄ‡ uÅ¼ywajÄ…c metody `size()`:

```cpp
// Ustawianie nazw graczy:
playerNames[0] = "HappyBanana";
playerNames[1] = "AngryCrab";
playerNames[2] = "SadWolf";

// highlight-next-line
std::cout << "Tablica posiada " << playerNames.size() << " elementÃ³w\n";

// Dodawanie nowego gracza:
playerNames.push_back("WickedWitch");
std::cout << "Dodano nowego gracza.\n";
// highlight-next-line
std::cout << "Tablica posiada " << playerNames.size() << " elementÃ³w\n";
```

### Usuwanie elementÃ³w

Na tym etapie nauki bÄ™dziesz musiaÅ‚/a mi trochÄ™ zaufaÄ‡.
Nie bÄ™dÄ™ zagÅ‚Ä™biaÅ‚ siÄ™ w szczegÃ³Å‚y, bo to na teraz zbyt skomplikowane.
Aby usunÄ…Ä‡ `n`-ty element z vectora (np. z `playerNames`), uÅ¼ywamy zapisu:

```cpp title="ğŸ”¹ Usuwanie z tablicy"
playerNames.erase( playerNames.begin() + n );
```

W bardzo duÅ¼ym uproszczeniu `erase` usuwa konkretny element, ale sam indeks nie wystarczy.
Musimy uÅ¼yÄ‡ `begin()` i dodaÄ‡ do niego ten indeks.

:::tip ZapamiÄ™taj
MoÅ¼esz zapamiÄ™taÄ‡ to rozrÃ³Å¼niajÄ…c te dwa pojÄ™cia:

- **indeks** (liczba nieujemna)
- **pozycja**

SÄ… to dwie rÃ³Å¼ne, ale tematycznie zbliÅ¼one rzeczy. Do `erase` podajemy *pozycjÄ™*, ktÃ³rÄ… uzyskujemy wÅ‚aÅ›nie
dodajÄ…c *indeks* do *pozycji poczatkowej* (`playerNames.begin()`).
:::

:::danger Uwaga
Zanim usuniesz dany element tablicy, upewnij siÄ™, Å¼e istnieje (czyli jest z zakresu `[0, N)`).

```cpp title="ğŸ”¹ Usuwanie z tablicy (zabezpieczone)"
int index;
std::cin >> index;

if (index >= 0 && index < playerNames.size())
{
	playerNames.erase( playerNames.begin() + index );
}
else
	std::cout << "Indeks " << index << " nie jest prawidÅ‚owy!";
```
:::

### WyÅ›wietlanie elementÃ³w

JeÅ›li chcemy wyÅ›wietliÄ‡ **wszystkie** elementy tablicy, bedziemy musieli uÅ¼yÄ‡ **pÄ™tli**.
O pÄ™tlach powiemy sobie w przyszÅ‚oÅ›ci wiÄ™cej. PÄ™tla pozwala wykonaÄ‡ ten sam fragment
kodu wielokrotnie.

```cpp title="ğŸ”¹ WyÅ›wietlanie elementÃ³w"
for (std::string name : playerNames)
{
	std::cout << "Nick gracza: " << name << '\n';
}
```

Å»eby to zrozumieÄ‡, pokaÅ¼Ä™ Ci jak to "przeczytaÄ‡":

```cpp
for (std::string name : playerNames)
```

> **Dla** <small>(`for`)</small> **kaÅ¼dej nazwy** <small>(`name`)</small> **ktÃ³ra jest typu** `std::string`
> **z tablicy** `playerNames` **wykonuj nastÄ™pujÄ…cy blok kodu...**

WewnÄ…trz tego bloku kodu jest tylko jedna instrukcja:

```cpp
std::cout << "Nick gracza: " << name << '\n';
```

PÄ™tla bÄ™dzie zapisywaÄ‡ kolejno nicki graczÃ³w do zmiennej `name`,
i wykonywaÄ‡ dla kaÅ¼dego z nich instrukcjÄ™ wyÅ›wietlenia.

:::tip Dedukcja typu
**JeÅ›li z kodu Å‚atwo jest wywnioskowaÄ‡** jakiego typu elementy przechowuje tablica,
moÅ¼esz skrÃ³ciÄ‡ zapis:

```cpp
for (std::string name : playerNames)
```

do

```cpp
for (auto name : playerNames)
```

wtedy `auto` spowoduje, Å¼e typ elementu zostanie wykryty automatycznie.
:::

## Potencjalne bÅ‚Ä™dy

### Brak nagÅ‚Ã³wka `<vector>`

Aby mÃ³c korzystaÄ‡ z typu `std::vector`, musimy dodaÄ‡ nagÅ‚Ã³wek `<vector>`:

```cpp
#include <vector>
// ... reszta kodu
```

JeÅ›li zapomnimy dodaÄ‡ ten nagÅ‚Ã³wek:
```cpp
int main() 
{
	std::vector<int> v;
	v.push_back(1);
}
```
moÅ¼emy spotkaÄ‡ siÄ™ z jednym z nastÄ™pujÄ…cych bÅ‚Ä™dÃ³w:

<Tabs groupId="compiler">
<TabItem value="clang" label="CLANG" default>

```plaintext
error: use of undeclared identifier 'std'
error: use of undeclared identifier 'v'
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Ilustracja bÅ‚Ä™du - brak nagÅ‚Ã³wka vector"
		src="/img/tutorials/course/basic/arrays/error-no-vector-header-pl-clang.png"
	/>

</TabItem>
<TabItem value="gcc" label="GCC">

```plaintext
error: â€˜vectorâ€™ is not a member of â€˜stdâ€™
error: â€˜vâ€™ was not declared in this scope
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Ilustracja bÅ‚Ä™du - brak nagÅ‚Ã³wka vector"
		src="/img/tutorials/course/basic/arrays/error-no-vector-header-pl-gcc.png"
	/>

</TabItem>
<TabItem value="msvc" label="MSVC">

```plaintext
error C2039: 'vector': is not a member of 'std'
error C2065: 'vector': undeclared identifier
error C2065: 'v': undeclared identifier
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Ilustracja bÅ‚Ä™du - niepoprawny cudzysÅ‚Ã³w"
		src="/img/tutorials/course/basic/arrays/error-no-vector-header-pl-msvc.png"
	/>

</TabItem>
</Tabs>

:::danger BÅ‚Ä™dy
TreÅ›Ä‡ bÅ‚Ä™dÃ³w moÅ¼e siÄ™ rÃ³Å¼niÄ‡ zaleÅ¼nie od tego, czy doÅ‚Ä…czamy inne nagÅ‚Ã³wki,
w ilu miejscach uÅ¼ywamy naszego vectora, itd.
Jest to logiczne, poniewaÅ¼ jeÅ›li kompilator nie wie czym jest `std::vector`,
to nie wie teÅ¼ czym jest nasza zmienna `v` o typie `std::vector<int>`, dlatego dostaniemy bÅ‚Ä…d wszÄ™dzie przy prÃ³bie uÅ¼ycia jej.

Dodatkowo warto zwrÃ³ciÄ‡ uwagÄ™ na to, Å¼e kod uÅ¼ywajÄ…cy vectora moÅ¼e zadziaÅ‚aÄ‡, nawet bez doÅ‚Ä…czenia nagÅ‚Ã³wka.
Takie zachowanie moÅ¼e wystÄ…piÄ‡, aczkolwiek nie naleÅ¼y na nim polegaÄ‡ i naleÅ¼y doÅ‚Ä…czaÄ‡ nagÅ‚Ã³wki wszystkich rzeczy, ktÃ³rych siÄ™ uÅ¼ywa
(np. jeÅ›li uÅ¼ywamy `std::cout`, czy `std::cin` naleÅ¼y doÅ‚Ä…czyÄ‡ `<iostream>`, dla `std::string` potrzebujemy `<string>`, dla `std::vector` - `<vector>`, etc.)
:::

### Mieszanie typÃ³w

`std::vector` jest szablonem, co oznacza, Å¼e dziaÅ‚a z wieloma rÃ³Å¼nymi typami.

Typ ktÃ³ry podamy pomiÄ™dzy nawiasy trÃ³jkÄ…tne oznacza typ elementÃ³w, jaki nasz vector skÅ‚aduje. `std::vector<int>` to vector przechowujÄ…cy `int`y,
`std::vector<std::string>` to vector przechowujÄ…cy `std::string`i, etc.

Wszystkie metody takiego vectora rÃ³wnieÅ¼ dziaÅ‚ajÄ… tylko na tym konkretnym typie.

Oznacza to, Å¼e np.
```cpp
std::vector<int> ints;
ints.push_back(1);
```
jest okej, ale juÅ¼ np.
```cpp
std::vector<int> ints;
ints.push_back("Hejo");
```
nie, poniewaÅ¼ nasz vector operuje tylko na intach.

BÅ‚Ä…d jaki moÅ¼emy dostaÄ‡ zaleÅ¼y od tego jakiego typu elementy przechowuje nasz vektor
i jakiego typu wartoÅ›ci chcemy do niego dodaÄ‡. W przykÅ‚adzie poniÅ¼ej prÃ³bujemy dodaÄ‡ napis do vectora liczb.

```cpp
std::vector<int> ints;
ints.push_back("Hejo")
```

#### ğŸ”´ TreÅ›Ä‡ bÅ‚Ä™du

<Tabs groupId="compiler">
<TabItem value="clang" label="CLANG" default>

```plaintext
error: no matching member function for call to 'push_back'
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Ilustracja bÅ‚Ä™du - mieszanie typÃ³w w vectorze"
		src="/img/tutorials/course/basic/arrays/error-wrong-push-back-type-pl-clang.png"
	/>

</TabItem>
<TabItem value="gcc" label="GCC">

```plaintext
error: no matching function for call to â€˜push_back(const char [5])â€™
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Ilustracja bÅ‚Ä™du - mieszanie typÃ³w w vectorze"
		src="/img/tutorials/course/basic/arrays/error-wrong-push-back-type-pl-gcc.png"
	/>
</TabItem>
<TabItem value="msvc" label="MSVC">

```plaintext
error C2664: 'void std::vector<int,std::allocator<int>>::push_back(const _Ty &)': cannot convert argument 1 from 'const char [5]' to 'const _Ty &'
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Ilustracja bÅ‚Ä™du - mieszanie typÃ³w w vectorze"
		src="/img/tutorials/course/basic/arrays/error-wrong-push-back-type-pl-msvc.png"
	/>

</TabItem>
</Tabs>


### WyjÅ›cie poza rozmiar tablicy

Jak juÅ¼ wczeÅ›niej ustaliliÅ›my, tablice majÄ… swÃ³j rozmiar, a Å¼eby dostaÄ‡ siÄ™ do ich konkretnych elementÃ³w, uÅ¼ywamy indeksÃ³w i zapisu `tablica[indeks]`.
Napotkamy jednak na problem, jeÅ›li indeks ten wyjdzie poza rozmiar tablicy.

Poprawne indeksy dla tablicy o rozmiarze **N** zaczynajÄ… siÄ™ od **0** a koÅ„czÄ… na **N - 1**, co oznacza, Å¼e jedyne poprawne indeksy dla tablicy
5 elementowej, to `0`, `1`, `2`, `3` i `4`.
WyjÅ›cie poza zakres tablicy nie spowoduje bÅ‚Ä™du kompilacji (choÄ‡ moÅ¼emy dostaÄ‡ ostrzeÅ¼enie od narzÄ™dzi z ktÃ³rych korzystamy, czyli np. kompilatora),
ale spowoduje powaÅ¼ne problemy podczas uruchamiania programu.

Tego typu bÅ‚Ä™dy sÄ… bardzo niebezpieczne, poniewaÅ¼ jeÅ›li kompilator ich nie wykryje (a nie zawsze moÅ¼e), to bÄ™dÄ… one powodowaÄ‡ nieprawidÅ‚owe dziaÅ‚anie programu, ktÃ³re ciÄ™Å¼ko wykryÄ‡.
Na szczÄ™Å›cie system operacyjny czasem wykrywa, Å¼e nasz program zachowuje siÄ™ nieprawidÅ‚owo i zakaÅ„cza nasz program, zgÅ‚aszajÄ…c bÅ‚Ä…d.

RozwaÅ¼my przykÅ‚adowy program:
```cpp
#include <vector>

int main() 
{
	std::vector<int> ints(3); // tablica 3 elementowa, poprawne indeksy to 0, 1, 2
	// hightlight-next-line
	ints[200000] = 3; // Ooops! ParÄ™ zer za duÅ¼o
}
```

ZaleÅ¼nie od tego na jakim jesteÅ›my systemie i w jaki sposÃ³b, jakim kompilatorem kompilowaliÅ›my nasz program, moÅ¼emy zobaczyÄ‡ rÃ³Å¼ne wyniki:

<Tabs groupId="platform">
<TabItem value="linux" label="LINUX & MAC OS" default>

Na linuxie i mac os, to jakÄ… informacjÄ™ dostaniemy zaleÅ¼y od powÅ‚oki jakiej uÅ¼ywamy:

<Tabs groupId="shell">
<TabItem value="bash" label="BASH" default>

```plaintext
Segmentation fault
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Pokazanie segmentation fault - bash"
		src="/img/tutorials/course/basic/arrays/error-out-of-bounds-bash-segfault.png"
	/>
</TabItem>
<TabItem value="zsh" label="ZSH" default>

```plaintext
zsh: segmentation fault: <nazwa programu>
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Pokazanie segmentation fault - zsh"
		src="/img/tutorials/course/basic/arrays/error-out-of-bounds-zsh-segfault.png"
	/>
</TabItem>
<TabItem value="fish" label="FISH" default>

```plaintext
fish: Job 1, '<nazwa programu>' terminated by signal SIGSEGV (Address boundary error)
```

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Pokazanie segmentation fault - fish"
		src="/img/tutorials/course/basic/arrays/error-out-of-bounds-fish-segfault.png"
	/>
</TabItem>
</Tabs>

</TabItem>
<TabItem value="windows" label="WINDOWS">

W przypadku windowsa w cmd nie pojawia siÄ™ nic, program po prostu wisi przez dÅ‚uÅ¼szy czas i nie wyÅ›wietla nic.

#### ğŸ–¼ Ilustracja zachowania:

<Image center
		alt="Pokazanie pustego wyniku programu"
		src="/img/tutorials/course/basic/arrays/error-out-of-bounds-cmd-empty.png"
	/>

MoÅ¼emy jednak zobaczyÄ‡, Å¼e coÅ› poszÅ‚o nie tak, wyÅ›wietlajÄ…c zmiennÄ… Å›rodowiskowÄ… <code>errorlevel</code>, ktÃ³ra zawiera kod zwrÃ³cony przez ostatnio wykonany program:

```plaintext
echo %errorlevel%
```


#### ğŸ–¼ Ilustracja zachowania:

<Image center
		alt="WyÅ›wietlenie errorlevel w konsoli"
		src="/img/tutorials/course/basic/arrays/error-out-of-bounds-cmd-errorlevel.png"
	/>

Jak widzimy na zdjÄ™ciu powyÅ¼ej, kod zwrÃ³cony przez ostatnie wywoÅ‚anie naszego programu to dziwna ujemna liczba, co oznacza, Å¼e program zakoÅ„czyÅ‚ siÄ™ z bÅ‚Ä™dem.
Poprawnym kodem zakoÅ„czenia programu jest 0.

</TabItem>
<TabItem value="windows-vs" label="WINDOWS, VISUAL STUDIO">

JeÅ›li korzystamy na windowsie z programu Visual Studio, to w trybie debug moÅ¼em nam wyskoczyÄ‡ okienko mÃ³wiÄ…ce o bÅ‚Ä™dzie.

#### ğŸ–¼ Ilustracja bÅ‚Ä™du:

<Image center
		alt="Ilustracja bÅ‚Ä™du - mieszanie typÃ³w w vectorze"
		src="/img/tutorials/course/basic/arrays/error-out-of-bounds-vs-assertion.png"
	/>

</TabItem>
</Tabs>

:::danger Niezdefiniowane zachowanie
Problem z bÅ‚Ä™dem tego typu (wyjÅ›cie poza zakres tablicy), jest taki, Å¼e kompilator nie zawsze jest w stanie udowodniÄ‡, Å¼e jest to bÅ‚Ä…d, wiÄ™c nie dostajemy Å¼adnego bÅ‚Ä™du kompilacji
(w jaki sposÃ³b kompilator ma udowodniÄ‡, czy prÃ³ba dostania siÄ™ do tablicy pod indeksem wprowadzonym od uÅ¼ytkownika bÄ™dzie poprawna czy nie?).
WyjÅ›cie poza zakres tablicy powoduje tzw. **niezdefiniowane zachowanie** (*ang. undefined behaviour*), czyli zachowanie, ktÃ³re waha siÄ™ zaleÅ¼nie od kompilatora ktÃ³rego uÅ¼yjemy,
systemu na ktÃ³rym uruchomimy program, czasem nawet kilku innych rzeczy.

Bardzo czÄ™sto moÅ¼emy mieÄ‡ w kodzie **niezdefiniowane zachowanie**, jednak nie bÄ™dzie siÄ™ ono niczym objawiaÄ‡ - program bÄ™dzie dziaÅ‚aÄ‡ poprawnie.
Nie powinno siÄ™ na tym polegaÄ‡, poniewaÅ¼ program moÅ¼e przestaÄ‡ dziaÅ‚aÄ‡ na innym systemie,
po rekompilacji z innym kompilatorem, po rekompilacji z innÄ… wersjÄ… kompilatora lub z uruchomienia na uruchomienie.
:::

BÅ‚Ä…d w ktÃ³rym wychodzimy poza zakres tablicy (*ang. out of bounds error*) jest rÃ³wnieÅ¼ nazywany bÅ‚Ä™dem przepeÅ‚nienia buforu (*ang. buffer overflow error*).
