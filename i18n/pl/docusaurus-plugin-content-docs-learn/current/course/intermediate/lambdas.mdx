---
sidebar_position:	1
sidebar_label:		"1. Lambdy (I)"
title:				"Lambdy (I)"
description:		"Lekcja: lambdy (I) w języku C++"
hide_title:			true
---

import NotFinished from "@site/i18n/pl/presets/NotFinished.mdx";
import Columns			from "@site-comps/Columns";
import CustomCodeBlock	from "@site-comps/CustomCodeBlock";
import Image			from "@site-comps/Image";
import Tabs			from '@theme/Tabs';
import TabItem		from '@theme/TabItem';
import ImproveSection	from "@site/i18n/pl/presets/ImproveSection.mdx";
import SwitchView		from "@site-comps/SwitchView";

import TransformIntroExampleCpp20		from "./lambdas/_codes/transform-example-cpp20.mdx";
import TransformIntroExampleUntilCpp20	from "./lambdas/_codes/transform-example-until-cpp20.mdx";



<NotFinished />

# Lambdy
W tej lekcji dowiesz się czym są i do czego mogą się przydać wyrażenia lambda.

## Motywacja

Lambdy przydają się często do algorytmów z biblioteki standardowej. W drugiej części lekcji o lambdach dowiemy się jak łatwo stworzyć taki algorytm samemu.

## Wyjaśnienie
Głównym celem wyrażeń lambda jest zapisanie kawałka kodu jako obiekt. Taki kod możemy potem wywołać lub wysłać do jakiejś funkcji jako argument.
 
:::important *"Nienazwane funkcje"*
Lambdy często nazywane w ten sposób, lecz nie jest to do końca poprawna nazwa. Lambdy mogą być nazwanym obiektem zdefiniowanym za pomocą słowa kluczowego `auto` lub typu `std::function` (o którym dowiemy się w lekcji drugiej o lambdach).
:::


## Definiowanie lambd




<Image center
		maxheight={470}
		alt="Definiowanie lambdy"
		src="/img/tutorials/course/intermediate/lambdas/Lambdas_pl.jpg"
		desc={<></>}
	/>
<br/>
Możemy taką lambdę przypisać do obiektu:

```cpp
auto lambda = [a, b] (int c, int d) { return a * b + c * d;};
```
Lambda musi posiadać ciało i listę wychwytywania (może być pusta). Często spotyka się też listę argumentów. Reszta rzeczy (jak atrybuty, typ rezultatu itp.) nie jest obowiązkowa, więc porozmawiamy o niej w lekcji drugiej.
Przyjrzyjmy się teraz poszczególnym częściom:

#### 1. Lista wychwytywania (ang. capture list)
Jak wiemy z lekcji o funkcjach, zmienne lokalne (np. z funkcji main) nie są znane w ciele innej funkcji. To samo tyczy się wyrażeń lambda. Aby zmienna lokalna była znana w ciele wyrażnia lambda należy dodać ją na listę wychwytywania.

:::danger Edycja zmiennych
Zmiennych wychwyconych przez listę nie można edytować. Jest sposób na obejście tego ograniczenia, jednak porozmawiamy o tym w lekcji drugiej.
:::

#### 2. Lista argumentów
Działa tak samo jak w przypadku funkcji.

#### 3. Ciało wyrażenia lambda
Tutaj zapisujemy instrukcje, działamy na zmiennych itp. W ciele wyrażenia lambda może się znaleźć instrukcja `return`.





### Proste przykłady

<Columns spacing={40} columns={['7fr', '4fr']}>
<div>

```cpp title="Prosta lambda"
auto five = [] { return 5; };
std::cout << five();
```

</div>

<div>

```plaintext title="Wynik (konsola)"
5
```

</div>
</Columns>
	
<Columns spacing={40} columns={['7fr', '4fr']}>
<div>

```cpp title="Następujący kod zawiera wyrażenie lambda z argumentem:"
auto square = [](int x) { return x*x; };
std::cout << square(5);
```

</div>

<div>

```plaintext title="Wynik (konsola)"
25
```

</div>
</Columns>


Nasz obiekt funkcyjny `square` zwraca sześcian argumentu `x`.


:::danger Najczęstsze błędy

<Columns spacing={40} columns={['7fr', '4fr']}>
<div>

```cpp title="lambdas.cpp"
#include <iostream>

int function();
int main()
{
	int A = 5;
	
	// highlight-start
	// ❌ Zmienna A nie jest tutaj znana ❌
	//auto addToA = [] (int b) { return A + b; };
	// highlight-end

	// highlight-start
	// Poprawna definicja lambdy ✅
	auto addToA = [A] (int b) { return A + b; };
	std::cout << addToA(5) << "\n";
	// highlight-end

	// highlight-start
	// ❌ Zmiennej B też tu nie znamy ❌
	//auto addToB = [B] (int a) { return B + a; };
	// highlight-end
	function();
}

int function()
{
	int B = 7;
	// highlight-start
	// Poprawny zapis ✅
	auto addToB = [B] (int a) { return B + a; };
	std::cout << addToB(9);
	// highlight-end
}
```

</div>

<div>

```plaintext title="Wynik (konsola)"
10
16
```

</div>
</Columns>
:::

## Prosty algorytm

:::caution Wersja C++
Zalecamy korzystanie z wersji **C++20**, ponieważ rozwiązania z niej są prostsze.
Dla osób, które z jakiegoś powodu nie mogą zainstalować kompilatora, który wspiera
najnowszy standard, zamieścimy też przykłady działające na starszej wersji.
:::

### `std::transform()`

Oczywiście, aby użyć tego algorytmu, musimy dołączyć plik `algorithm`.

Algorytm `std::transform()` wykonuje na każdym elemencie wektora jakąś modyfikację, a rezultat pracy wpisuje do wskazanego innego wektora.

<SwitchView content={
		{
			"cpp20":		<TransformIntroExampleCpp20 />,
			"until-cpp20":	<TransformIntroExampleUntilCpp20 />,
		}
	}/>

Więcej algorytmów poznamy w lekcji drugiej.

