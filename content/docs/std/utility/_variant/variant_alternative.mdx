---
title:				std::variant_alternative, std::variant_alternative_t
tags:				[variant, utility, visit]
hide_title:			true
---
import Columns					from "@site-comps/Columns";
import SwitchView				from "@site-comps/SwitchView";
import SymbolTable, { Symbol }	from "@site-comps/SymbolTable";

# std::variant_alternative, std::variant_alternative_t

Defined in header `<variant>`.

``` cpp
// 1)
template <std::size_t I, class T>
struct variant_alternative; /* undefined */                               // (since C++17)
// 2)
template <std::size_t I, class... Types>
struct variant_alternative<I, variant<Types...>>;                         // (since C++17)
// 3)	
template <std::size_t I, class T> class variant_alternative<I, const T>;  // (since C++17)
// 3)	
template <std::size_t I, class T>
class variant_alternative<I, volatile T>;
template <std::size_t I, class T>
class variant_alternative<I, const volatile T>;       // (since C++17, deprecated in C++20)
```

		
Provides compile-time indexed access to the types of the alternatives of the possibly cv-qualified variant, combining cv-qualifications of the variant 
(if any) with the cv-qualifications of the alternative.

Formally,

2) 
meets the TransformationTrait requirements with a member typedef type equal to the type of the alternative with index `I`

3)
meets the TransformationTrait requirements with a member typedef type that names, respectively, <br/>
`std::add_const_t<std::variant_alternative_t<I,T>>`, <br/>
`std::add_volatile_t<std::variant_alternative_t<I,T>>`, and <br/>
`std::add_cv_t<std::variant_alternative_t<I,T>>`


### Member types

|Member type|	Definition|
|::|::|
|type|	the type of `I`th alternative of the variant, where `I` must be in `[0, sizeof...(Types))`, otherwise the program is ill-formed.|

### Helper template alias

```cpp
template <size_t I, class T>
using variant_alternative_t = typename variant_alternative<I, T>::type; // (since C++17)
```


### Example

<Columns spacing = "20px" columns={['6fr', '4fr']}>
<div>

```cpp
#include <variant>
#include <iostream>
 
using my_variant = std::variant<int, float>;
static_assert(std::is_same_v
    <int,   std::variant_alternative_t<0, my_variant>>);
static_assert(std::is_same_v
    <float, std::variant_alternative_t<1, my_variant>>);
// cv-qualification on the variant type propagates to the extracted alternative type.
static_assert(std::is_same_v
    <const int, std::variant_alternative_t<0, const my_variant>>);
 
int main()
{
    std::cout << "All static assertions passed.\n";
}
```

</div>

<div>

```plaintext title="Result"
All static assertions passed.
```

</div>
</Columns>

### Defect reports
The following behavior-changing defect reports were applied retroactively to previously published C++ standards.

|    DR    | Applied to |                Behavior as published               | Correct behavior |
|:--------:|:----------:|:--------------------------------------------------:|:----------------:|
| LWG 2974 | C++17      | out-of-bounds index resulted in undefined behavior | made ill-formed  |