---
sidebar_position:	2
title:				std::map reference
sidebar_label:		map
hide_title:			true
---

import ClassSummary				from "@site-comps/ClassSummary";
import SymbolTable, { Symbol }	from "@site-comps/SymbolTable";
import Columns					from "@site-comps/Columns";
import NotFinished				from "@site/i18n/en/presets/NotFinished.mdx";
import ImproveSection			from "@site/i18n/en/presets/ImproveSection.mdx";
import Tabs						from "@theme/Tabs";
import TabItem					from "@theme/TabItem";

<NotFinished />

# Map class reference

## Overview

<Tabs>
<TabItem value="simplified" label="Simplified" default>

```cpp
template<
    class Key,
    class T,
    /* ... */
> class map;
```

</TabItem>
<TabItem value="detailed" label="Detailed">

```cpp
template<
    class Key,
    class T,
    class Compare = std::less<Key>,
    class Allocator = std::allocator<std::pair<const Key, T> >
> class map;
```

</TabItem>
</Tabs>

The `std::map` is a container that stores key-value pairs with unique keys in some order.
The order can be specified by the programmer. 

### Example usage

The examples in this section are very simple ones. Navigate to [examples section at the bottom](#more-examples) for more.

<ImproveSection />

### Technical details

<details>
<summary>Technical definition of a map</summary>
<div>

`std::map` is a sorted associative container that contains key-value pairs with unique keys.
Keys are sorted by using the comparison function `Compare`. Search, removal,
and insertion operations have logarithmic complexity. Maps are usually implemented as red-black trees.

Everywhere the standard library uses the `Compare` requirements, uniqueness is determined by
using the equivalence relation. In imprecise terms, two objects `a` and `b` are considered equivalent
(not unique) if neither compares less than the other: `!comp(a, b) && !comp(b, a)`. 

</div>
</details>

<ClassSummary name="map" namespaces="std" folder="map" headerName="map">

## Template parameters

<SymbolTable noTraits>
	<Symbol name="Key"		desc="The type of stored keys"/>
	<Symbol name="T" 		desc="The type of stored values"/>
	<Symbol name="Compare" 		desc="It determines the order of keys"/>
	<Symbol name="Allocator" 		desc="Is responsible for allocating and deallocating memory"/>
</SymbolTable>

## Type names

<SymbolTable>
	<Symbol pub name="key_type"				desc="Key"/>
	<Symbol pub name="mapped_type" 				desc="T"/>
	<Symbol pub name="value_type"			desc={<code>std::pair&lt;const Key, T&gt;</code>}/>
	<Symbol pub name="size_type"				desc="Unsigned integer type"/>
	<Symbol pub name="difference_type"			desc="Signed integer type"/>
	<Symbol pub name="key_compare"				desc="Compare"/>
	<Symbol pub name="allocator_type" 				desc="Allocator"/>
	<Symbol pub name="reference"			desc={<code>value_type&</code>}/>
	<Symbol pub name="const_reference"				desc={<code>const value_type&</code>}/>
	<Symbol pub name="pointer"			desc={<code>std::allocator_traits&lt;Allocator&gt;::pointer</code>}/>
	<Symbol pub name="const_pointer"			desc={<code>std::allocator_traits&lt;Allocator&gt;::const_pointer</code>}/>
	<Symbol pub name="iterator"			desc="value_type"/>
	<Symbol pub name="const_iterator"			desc="const value_type"/>
	<Symbol pub name="reverse_iterator"			desc={<code>std::reverse_iterator&lt;iterator&gt;</code>}/>
	<Symbol pub name="const_reverse_iterator"			desc={<code>std::reverse_iterator&lt;const_iterator&gt;</code>}/>
	<Symbol pub name="node_type"			desc="A specialization of node handle representing a container node"/>
</SymbolTable>

## Member classes

<SymbolTable>	
	<Symbol pub autoLink name="value_compare">
		Compare objects of type value_type
	</Symbol>
</SymbolTable>

## Member functions

<SymbolTable>	
	<Symbol pub autoLink linkName="constructor" name="(constructor)">
		Constructs the <code>map</code>
	</Symbol>
	<Symbol pub autoLink linkName="destructor" name="(destructor)">
		Destructs the <code>map</code>
	</Symbol>
	<Symbol pub autoLink linkName="operator=" name="operator=">
		Assigns values to the container
	</Symbol>
	<Symbol pub autoLink linkName="get_allocator" name="get_allocator">
		Returns the associated allocator
	</Symbol>

</SymbolTable>

### Element access

<SymbolTable>	
	<Symbol pub autoLink linkName="at" name="at">
		Access specified element with bounds checking
	</Symbol>
	<Symbol pub autoLink linkName="operator[]" name="operator[]">
		Access or insert specified element
	</Symbol>
</SymbolTable>

### Iterators

<SymbolTable>	
	<Symbol pub autoLink linkName="begin" name={<>begin<br/>cbegin</>}>
		Returns an iterator to the beginning
	</Symbol>
	<Symbol pub autoLink linkName="end" name={<>end<br/>cend</>}>
		Returns an iterator to the end
	</Symbol>
	<Symbol pub autoLink linkName="crbegin" name={<>rbegin<br/>crbegin</>}>
		Returns a reverese iterator to the beginning
	</Symbol>
	<Symbol pub autoLink linkName="crend" name={<>rend<br/>crend</>}>
		Returns a reverse iterator to the end
	</Symbol>
</SymbolTable>

### Capacity

<SymbolTable>
	<Symbol pub autoLink linkName="empty" name="empty">
		Checks whether the container is empty
	</Symbol>
	<Symbol pub autoLink linkName="size" name="size">
		Returns the number of elements
	</Symbol>
	<Symbol pub autoLink linkName="max_size" name="max_size">
		Returns the maximum possible number of elements
	</Symbol>
</SymbolTable>

### Modifiers

<SymbolTable>
	<Symbol pub autoLink linkName="clear" name="clear">
		Clears the contents
	</Symbol>
	<Symbol pub autoLink linkName="insert" name="insert">
		Inserts elements or nodes
	</Symbol>
	<Symbol pub autoLink linkName="insert_or_assign" name="insert_or_assign">
		Inserts an element or assigns to the current element if the key already exists
	</Symbol>
	<Symbol pub autoLink linkName="emplace" name="emplace">
		Constructs element in place
	</Symbol>
	<Symbol pub autoLink linkName="emplace_hint" name="emplace_hint">
		Constructs elements in-place using a hint
	</Symbol>
	<Symbol pub autoLink linkName="try_emplace" name="try_emplace">
		Returns the maximum possible number of elements
	</Symbol>
	<Symbol pub autoLink linkName="erase" name="erase">
		Erases elements
	</Symbol>
	<Symbol pub autoLink linkName="swap" name="swap">
		Swaps the contents
	</Symbol>
	<Symbol pub autoLink linkName="extract" name="extract">
		Extracts nodes from the container
	</Symbol>
	<Symbol pub autoLink linkName="merge" name="merge">
		Splices nodes from another container
	</Symbol>
</SymbolTable>

### Lookup

<SymbolTable>
	<Symbol pub autoLink linkName="count" name="count">
		Returns the number of elements matching specific key
	</Symbol>
	<Symbol pub autoLink linkName="find" name="find">
		Finds element with specific key
	</Symbol>
	<Symbol pub autoLink linkName="contains" name="contains">
		Checks if the container contains element with specific
	</Symbol>
	<Symbol pub autoLink linkName="equal_range" name="equal_range">
		Raturns range of elements matching a specific key
	</Symbol>
	<Symbol pub autoLink linkName="lower_bound" name="lower_bound">
		Returns an iterator to the first element not less than the given key
	</Symbol>
	<Symbol pub autoLink linkName="upper_bound" name="upper_bound">
		Returns an iterator to the first element greater than the given key
	</Symbol>
</SymbolTable>

### Observers

<SymbolTable>
	<Symbol pub autoLink linkName="Key_comp" name="key_comp">
		Returns the function that compares keys
	</Symbol>
	<Symbol pub autoLink linkName="value_comp" name="value_comp">
		Returns the function that compares keys in objects of type value_type
	</Symbol>
</SymbolTable>

## Non-member functions

<SymbolTable noTraits>
	<Symbol name={<>
				operator==<br/>
				operator!=<br/>
				operator&lt;<br/>
				operator&gt;<br/>
				operator&lt;=<br/>
				operator&gt;=<br/>
				operator&lt;=&gt;
			</>}
			desc="Lexicographically compares two strings">
	</Symbol>
	<Symbol pub autoLink linkName="std::swap" name="std::swap">
		Specializes the <code>std::swap</code> algorithm
	</Symbol>
	<Symbol pub autoLink linkName="erase_if" name="erase_if">
		Erases all elements satisfying specific criteria
	</Symbol>
</SymbolTable>

</ClassSummary>


## Deduction guides

<ImproveSection />

## More examples

### Basic manipulation

#### Creating map, inserting pair, changing values and printing it out

<Columns spacing="20px" columns={['8fr', '4fr']}>
<div>

```cpp
#include <iostream>
#include <string>
#include <map>

int main(){
  std::map<std::string, int> player_stats{ {"C1", -10}, {"B2", 25}};

  player_stats.insert(std::make_pair("A3", 200));
  player_stats["A3"] = 90;

  for (auto& [key, value] : player_stats)
    std::cout << key << " " << value << std::endl;

  return 0;
}
```

</div>
<div>

```plaintext title="Result"
A3 90
B2 25
C1 -10
```

</div>
</Columns>