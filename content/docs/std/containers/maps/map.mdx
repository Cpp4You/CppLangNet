---
sidebar_position:	2
title:				std::map reference
sidebar_label:		map
hide_title:			true
description:		Summary of a std::map (usage, methods, etc.) - C++ Language
tags:				[map, container, associative, ordered, key, unique]
---

import ClassSummary				from "@site-comps/ClassSummary";
import CustomCodeBlock				from "@site-comps/CustomCodeBlock";
import SymbolTable, { Symbol }	from "@site-comps/SymbolTable";
import Columns					from "@site-comps/Columns";
import NotFinished				from "@site/i18n/en/presets/NotFinished.mdx";
import ImproveSection			from "@site/i18n/en/presets/ImproveSection.mdx";
import Tabs						from "@theme/Tabs";
import TabItem					from "@theme/TabItem";

<!------------------ Codes ----------------->

<!-- Further Examples -->
import FurtherExampleCreateInsertChangePrint from "./map/_codes/main-page/examples/further/create-insert-change-print.mdx"

<!-- Overview -->
import OverviewSimplifiedRegular from "./map/_codes/main-page/overview/overview-simplified-regular.mdx";
import OverviewDetailedRegular from "./map/_codes/main-page/overview/overview-detailed-regular.mdx";
import OverviewDetailedPmr from "./map/_codes/main-page/overview/overview-detailed-pmr.mdx";

<!-- Deduction Guides -->
import DeductionGuides from "./map/_codes/main-page/deduction-guides.mdx"

<NotFinished />

# Map class reference

## Overview

<Tabs>
<TabItem value="simplified" label="Simplified (since C++98)" default>

	<OverviewSimplifiedRegular />

</TabItem>
<TabItem value="detailed" label="Detailed">
	<Tabs>
		<TabItem value="regular" label="Regular (since C++98)" default>

			<OverviewDetailedRegular/>

		</TabItem>

		<TabItem value="pmr" label="Polymorphic (since C++17)">

			<OverviewDetailedPmr/>

		</TabItem>
	</Tabs>
</TabItem>
</Tabs>

The `std::map` is a container that stores key-value pairs with unique keys in a specified order.

### Technical details

<details>
<summary>Technical definition of a map</summary>
<div>

`std::map` is a sorted associative container that contains key-value pairs with unique keys.
Keys are sorted by using the comparison function `Compare`. Search, removal,
and insertion operations have logarithmic complexity. Maps are usually implemented as red-black trees.

Everywhere the standard library uses the `Compare` requirements, uniqueness is determined by
using the equivalence relation. In imprecise terms, two objects `a` and `b` are considered equivalent
(not unique) if neither compares less than the other: `!comp(a, b) && !comp(b, a)`.

</div>
</details>

<ClassSummary name="map" namespaces="std" folder="map" headerName="map">

## Template parameters

<SymbolTable noTraits>
	<Symbol name="Key"		desc="The type of stored keys."/>
	<Symbol name="Value" 		desc="The type of stored values."/>
	<Symbol
			name="Compare"
			desc={<>
				A comparator type satisfying <a href="/docs/named_req/Compare">Compare</a>.
			</>}
		/>
	<Symbol
			name="Allocator"
			desc={<>
					An allocator type responsible for allocating and deallocating memory.
					Must satisfy <a href="/docs/named_req/Allocator">Allocator</a>.
				</>}
		/>
</SymbolTable>

## Type names

<SymbolTable>
	<Symbol pub name="key_type"				desc={<code>Key</code>} />
	<Symbol pub name="mapped_type" 		desc={<code>Value</code>}/>
	<Symbol pub name="value_type"			desc={<code>std::pair&lt;const Key, Value&gt;</code>}/>
	<Symbol pub name="size_type"			desc={<>Unsigned integer type (usually <code><a href="#">std::size_t</a></code>).</>}/>
	<Symbol pub
			name="difference_type"
			desc={<>
					Signed integer type (usually <code><a href="#">std::ptrdiff_t</a></code>).
			</>}
		/>
	<Symbol pub name="key_compare"				desc={<code>Compare</code>}/>
	<Symbol pub name="allocator_type" 				desc={<code>Allocator</code>}/>
	<Symbol pub name="reference"			desc={<code>value_type&</code>}/>
	<Symbol pub name="const_reference"				desc={<code>const value_type&</code>}/>
	<Symbol pub name="pointer">
		<code>Allocator::pointer</code> <small>(until C++11)</small>
		<br/>
		<code><a href="#">std::allocator_traits</a>&lt;Allocator&gt;::pointer</code> <small>(since C++11)</small>
	</Symbol>
	<Symbol pub name="const_pointer">
		<code>Allocator::const_pointer</code> <small>(until C++11)</small>
		<br/>
		<code><a href="#">std::allocator_traits</a>&lt;Allocator&gt;::const_pointer</code> <small>(since C++11)</small>
	</Symbol>
	<Symbol pub
			name="iterator"
			desc={<>
					<a href="/docs/named_req/LegacyBidirectionalIterator">LegacyBidirectionalIterator</a> to <code>value_type</code>
				</>}
		/>
	<Symbol pub
			name="const_iterator"
			desc={<>
					<a href="/docs/named_req/LegacyBidirectionalIterator">LegacyBidirectionalIterator</a> to const <code>value_type</code>
				</>}
		/>
	<Symbol pub
			name="reverse_iterator"
			desc={<code>std::reverse_iterator&lt;iterator&gt;</code>}
		/>
	<Symbol pub
			name="const_reverse_iterator"
			desc={<code>
					std::reverse_iterator&lt;const_iterator&gt;</code>}
		/>
	<Symbol pub
			name={<>node_type <small>(since c++17)</small></>}
			desc={<>
					A specialization of <a href="">node handle</a> representing a container node.</>}
		/>
<Symbol pub name={<> insert_return_type <small>(since C++17)</small> </>}>
Type describing the result of inserting a `node_type`, a specialization of

```cpp
template < class Iter, class NodeType >
struct /* unspecified */ {
    Iter     position;
    bool     inserted;
    NodeType node;
};
```
instantiated with template arguments `iterator` and `node_type`.
</Symbol>
</SymbolTable>

## Member classes

<SymbolTable>
	<Symbol pub autoLink name="value_compare">
		Compares two objects of type <code>value_type</code>.
	</Symbol>
</SymbolTable>

## Member functions

<SymbolTable>
	<Symbol pub autoLink linkName="constructor" name="(constructor)">
		Constructs a new map.
	</Symbol>
	<Symbol pub autoLink linkName="destructor" name="(destructor)">
		Destructs a map.
	</Symbol>
	<Symbol pub autoLink linkName="operator_assign" name="operator=">
		Assigns one map to another.
	</Symbol>
	<Symbol pub autoLink linkName="get_allocator" name="get_allocator">
		Returns an associated allocator.
	</Symbol>

</SymbolTable>

### Element access

<SymbolTable>
	<Symbol pub autoLink linkName="at" name="at">
		Accesses a specified element with bounds checking.
	</Symbol>
	<Symbol pub autoLink linkName="operator_subscript" name="operator[]">
		Accesses or inserts a specified element.
	</Symbol>
</SymbolTable>

### Iterators

<SymbolTable>
	<Symbol pub autoLink linkName="begin" name={<>begin<br/>cbegin<small>(since C++11)</small></>}>
		Returns an iterator to the beginning.
	</Symbol>
	<Symbol pub autoLink linkName="end" name={<>end<br/>cend<small>(since C++11)</small></>}>
		Returns an iterator to the end.
	</Symbol>
	<Symbol pub autoLink linkName="crbegin" name={<>rbegin<br/>crbegin<small>(since C++11)</small></>}>
		Returns a reverse iterator to the beginning.
	</Symbol>
	<Symbol pub autoLink linkName="crend" name={<>rend<br/>crend<small>(since C++11)</small></>}>
		Returns a reverse iterator to the end.
	</Symbol>
</SymbolTable>

### Capacity

<SymbolTable>
	<Symbol pub autoLink linkName="empty" name="empty">
		Returns <code>true</code> if a map is empty, otherwise <code>false</code>.
	</Symbol>
	<Symbol pub autoLink linkName="size" name="size">
		Returns the number of elements in a map.
	</Symbol>
	<Symbol pub autoLink linkName="max_size" name="max_size">
		Returns the maximum possible number of elements.
	</Symbol>
</SymbolTable>

### Modifiers

<SymbolTable>
	<Symbol pub autoLink linkName="clear" name="clear">
		Clears the contents of a map.
	</Symbol>
	<Symbol pub autoLink linkName="insert" name="insert">
		Inserts elements or nodes (extracted with <code>.extract()</code>) <small>(since C++17)</small>.
	</Symbol>
	<Symbol pub autoLink linkName="insert_or_assign" name={<>insert_or_assign <small>(since C++17)</small></>}>
		Inserts a new element or assigns to an already existing one if it already exists.
	</Symbol>
	<Symbol pub autoLink linkName="emplace" name={<>emplace <small>(since C++11)</small></>}>
		Constructs a new element in place.
	</Symbol>
	<Symbol pub autoLink linkName="emplace_hint" name={<>emplace_hint <small>(since C++11)</small></>}>
		Constructs elements in-place using a hint (iterator).
	</Symbol>
	<Symbol pub autoLink linkName="try_emplace" name="try_emplace">
		Inserts a new element in-place if the key does not exist, does nothing if the key exists.
	</Symbol>
	<Symbol pub autoLink linkName="erase" name="erase">
		Erases elements.
	</Symbol>
	<Symbol pub autoLink linkName="swap" name="swap">
		Swaps two maps.
	</Symbol>
	<Symbol pub autoLink linkName="extract" name={<>extract <small>(since C++17)</small></>}>
		Extracts nodes from a map (can be later inserted somewhere else).
	</Symbol>
	<Symbol pub autoLink linkName="merge" name={<>merge <small>(since C++17)</small></>}>
		Merges two maps together.
	</Symbol>
</SymbolTable>

### Lookup

<SymbolTable>
	<Symbol pub autoLink linkName="count" name="count">
		Returns the number of elements matching a specific key (for a map always `0`/`1`).
	</Symbol>
	<Symbol pub autoLink linkName="find" name="find">
		Searches for an element and returns an iterator to it, or end iterator if not found.
	</Symbol>
	<Symbol pub autoLink linkName="contains" name={<>contains <small>(since C++20)</small></>}>
		Returns <code>true</code> if an element is inside a map, otherwise <code>false</code>.
	</Symbol>
	<Symbol pub autoLink linkName="equal_range" name="equal_range">
		Returns a range of elements matching a specific key. (for a map the range will always contain one element).
	</Symbol>
	<Symbol pub autoLink linkName="lower_bound" name="lower_bound">
		Returns an iterator to the first element <i>not less</i> than the given key.
	</Symbol>
	<Symbol pub autoLink linkName="upper_bound" name="upper_bound">
		Returns an iterator to the first element <i>greater</i> than the given key.
	</Symbol>
</SymbolTable>

### Observers

<SymbolTable>
	<Symbol pub autoLink linkName="Key_comp" name="key_comp">
		Returns an internal function object that compares keys.
	</Symbol>
	<Symbol pub autoLink linkName="value_comp" name="value_comp">
		Returns an internal function object that compares keys in objects of type <code>value_type</code> (<code>std::pair&lt;Key, Value&gt;</code>).
	</Symbol>
</SymbolTable>

## Non-member functions

<SymbolTable noTraits>
	<Symbol name={<>
				operator==<br/>
				operator!= <small>(removed in C++20)</small><br/>
				operator&lt; <small>(removed in C++20)</small><br/>
				operator&gt; <small>(removed in C++20)</small><br/>
				operator&lt;= <small>(removed in C++20)</small><br/>
				operator&gt;= <small>(removed in C++20)</small><br/>
				operator&lt;=&gt; <small>(since C++20) </small>
			</>}
			desc="Lexicographically compares the values in a map."
		/>
	<Symbol name={<>std::swap <small>(std::map)</small></>}
			desc={<>An overload for a <a href="#">std::swap</a> algorithm.</>}
		/>
	<Symbol name={<>
				erase_if <small>(std::map) (since C++20)</small>
			</>}
			desc={<>Overload for a <a href="#">std::erase_if</a> algorithm.</>}
		/>
</SymbolTable>

</ClassSummary>

## Deduction guides (since C++17)
<details>
<summary>Click to expand</summary>
<div>
	<DeductionGuides />
</div>
</details>

## More examples

### Basic manipulation

<Columns spacing="20px" columns={['8fr', '4fr']}>
<div>

<CustomCodeBlock withTitle>
	<FurtherExampleCreateInsertChangePrint />
</CustomCodeBlock>

</div>
<div>

```plaintext title="Result"
A3 90
B2 25
C1 -10
D4 500
```
</div>
</Columns>
