**(1)** Inserts a `value_type` object constructed in-place from `std::piecewise_construct, std::forward_as_tuple(key), std::tuple<>()` if the key does not exist.


Since C++17 this function is equivalent to return `this->try_emplace(key).first->second`.

When the default allocator is used, this results in the key being copy constructed from key and the mapped value being value-initialized.

### Type requirements
 - `value_type` must be [**EmplaceConstructible**](/docs/named_req/EmplaceConstructible) from `std::piecewise_construct`, `std::forward_as_tuple(key)`, `std::tuple<>()`.
    When the default allocator is used, this means that `key_type` must be [**CopyConstructible**](/docs/named_req/CopyConstructible) and `mapped_type` must be [**DefaultConstructible**](/docs/named_req/DefaultConstructible).



**(2)** Inserts a `value_type` object constructed in-place from `std::piecewise_construct`, `std::forward_as_tuple(std::move(key))`, `std::tuple<>()` if the key does not exist.


Since C++17 this function is equivalent to return `this->try_emplace(key).first->second`.

When the default allocator is used, this results in the key being move constructed from key and the mapped value being value-initialized.

### Type requirements
 - `value_type` must be [**EmplaceConstructible**](/docs/named_req/EmplaceConstructible) from `std::piecewise_construct`, `std::forward_as_tuple(std::move(key))`, `std::tuple<>()`.
    When the default allocator is used, this means that `key_type` must be [**MoveConstructible**](/docs/named_req/MoveConstructible) and `mapped_type` must be [**DefaultConstructible**](/docs/named_req/DefaultConstructible).
