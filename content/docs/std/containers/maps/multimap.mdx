---
sidebar_position:	2
title:				std::multimap reference
sidebar_label:		multimap
hide_title:			true
description:		Summary of a std::multimap (usage, methods, etc.) - C++ Language
tags:				[multimap, map, associative, multi]
---

import ClassSummary				from "@site-comps/ClassSummary";
import CustomCodeBlock				from "@site-comps/CustomCodeBlock";
import SymbolTable, { Symbol }	from "@site-comps/SymbolTable";
import Columns					from "@site-comps/Columns";
import NotFinished				from "@site/i18n/en/presets/NotFinished.mdx";
import ImproveSection			from "@site/i18n/en/presets/ImproveSection.mdx";
import Tabs						from "@theme/Tabs";
import TabItem					from "@theme/TabItem";

<!------------------ Codes ----------------->

<!-- Further Examples -->
import FurtherExampleCreateInsertPrint from "./multimap/_codes/main-page/examples/further/create-insert-print.mdx"

<!-- Overview -->
import OverviewSimplifiedRegular from "./multimap/_codes/main-page/overview/overview-simplified-regular.mdx";
import OverviewDetailedRegular from "./multimap/_codes/main-page/overview/overview-detailed-regular.mdx";
import OverviewDetailedPmr from "./multimap/_codes/main-page/overview/overview-detailed-pmr.mdx";

<!-- Deduction Guides -->
import DeductionGuides from "./multimap/_codes/main-page/deduction-guides.mdx"

<NotFinished />

# Multimap class reference

## Overview

<Tabs>
<TabItem value="simplified" label="Simplified" default>

	<OverviewSimplifiedRegular />

</TabItem>
<TabItem value="detailed" label="Detailed">
	<Tabs>
		<TabItem value="regular" label="Regular" default>

			<OverviewDetailedRegular/>

		</TabItem>

		<TabItem value="pmr" label="Polymorphic (since C++17)">

			<OverviewDetailedPmr/>

		</TabItem>
	</Tabs>
</TabItem>
</Tabs>

The `std::multimap` is a container that stores key-value pairs in a specified order. It works almost as
`std::map`, the only difference is that the keys can repeat themselves. If the keys of both elements are the
same, they are ordered by their values.

### Technical details

<details>
<summary>Technical definition of a multimap</summary>
<div>

Multimap is an associative container that contains a sorted list of key-value pairs, while permitting multiple entries with the same key.

Sorting is done according to the comparison function `Compare`, applied to the keys. Search, insertion, and removal operations have logarithmic complexity.

The order of the key-value pairs whose keys compare equivalent is the order of insertion and does not change. <small>(since C++11)</small>

Everywhere the standard library uses the [`Compare`](/docs/named_req/Compare) requirements, equivalence is determined by using the equivalence relation as described on Compare.

In imprecise terms, two objects **a** and **b** are considered equivalent if neither compares less than the other: `!comp(a, b) && !comp(b, a)`.

</div>
</details>

<ClassSummary name="multimap" namespaces="std" folder="multimap" headerName="map">


## Template parameters

<SymbolTable noTraits>
	<Symbol name="Key"		desc="The type of the stored keys."/>
	<Symbol name="Value" 		desc="The type of the stored values."/>
	<Symbol
			name="Compare"
			desc={<>
				A comparator type satisfying <a href="/docs/named_req/Compare">Compare</a>.
			</>}
		/>
	<Symbol
			name="Allocator"
			desc={<>
					An allocator type responsible for allocating and deallocating memory.
					Must satisfy <a href="/docs/named_req/Allocator">Allocator</a>.
				</>}
		/>
</SymbolTable>

## Type names

<SymbolTable>
	<Symbol pub name="key_type"				desc={<code>Key</code>} />
	<Symbol pub name="mapped_type" 		desc={<code>Value</code>}/>
	<Symbol pub name="value_type"			desc={<code>std::pair&lt;const Key, Value&gt;</code>}/>
	<Symbol pub name="size_type"			desc={<>Unsigned integer type (usually <code><a href="#">std::size_t</a></code>).</>}/>
	<Symbol pub
			name="difference_type"
			desc={<>
					Signed integer type (usually <code><a href="#">std::ptrdiff_t</a></code>).
			</>}
		/>
	<Symbol pub name="key_compare"				desc={<code>Compare</code>}/>
	<Symbol pub name="allocator_type" 				desc={<code>Allocator</code>}/>
	<Symbol pub name="reference"			desc={<code>value_type&</code>}/>
	<Symbol pub name="const_reference"				desc={<code>const value_type&</code>}/>
	<Symbol pub name="pointer">
		<code>Allocator::pointer</code> <small>(until C++11)</small>
		<br/>
		<code><a href="#">std::allocator_traits</a>&lt;Allocator&gt;::pointer</code> <small>(since C++11)</small>
	</Symbol>
	<Symbol pub name="const_pointer">
		<code>Allocator::const_pointer</code> <small>(until C++11)</small>
		<br/>
		<code><a href="#">std::allocator_traits</a>&lt;Allocator&gt;::const_pointer</code> <small>(since C++11)</small>
	</Symbol>
	<Symbol pub
			name="iterator"
			desc={<>
					<a href="/docs/named_req/LegacyBidirectionalIterator">LegacyBidirectionalIterator</a> to <code>value_type</code>
				</>}
		/>
	<Symbol pub
			name="const_iterator"
			desc={<>
					<a href="/docs/named_req/LegacyBidirectionalIterator">LegacyBidirectionalIterator</a> to const <code>value_type</code>
				</>}
		/>
	<Symbol pub
			name="reverse_iterator"
			desc={<code><a href="#">std::reverse_iterator</a>&lt;iterator&gt;</code>}
		/>
	<Symbol pub
			name="const_reverse_iterator"
			desc={<code><a href="#">std::reverse_iterator</a>&lt;const_iterator&gt;</code>}
		/>
	<Symbol pub
			name={<>node_type <small>(since C++17)</small></>}
			desc={<>
					A specialization of <a href="">node handle</a> representing a container node.</>}
		/>
</SymbolTable>

## Member classes

<SymbolTable>
	<Symbol pub autoLink name="value_compare">
		Function object that compares two objects of type <code>value_type</code>.
	</Symbol>
</SymbolTable>

## Member functions

<SymbolTable>
	<Symbol pub autoLink linkName="constructor" name="(constructor)">
		Constructs a new <code>std::multimap</code>.
	</Symbol>
	<Symbol pub autoLink linkName="destructor" name="(destructor)">
		Destructs a <code>std::multimap</code>.
	</Symbol>
	<Symbol pub autoLink linkName="operator=" name="operator=">
		Assigns one multimap to another.
	</Symbol>
	<Symbol pub autoLink linkName="get_allocator" name="get_allocator">
		Returns the associated allocator.
	</Symbol>

</SymbolTable>

### Iterators

<SymbolTable>
	<Symbol pub autoLink linkName="begin" name={<>begin<br/>cbegin <small>(since C++11)</small></>}>
		Returns an iterator to the beginning.
	</Symbol>
	<Symbol pub autoLink linkName="end" name={<>end<br/>cend <small>(since C++11)</small></>}>
		Returns an iterator to the end.
	</Symbol>
	<Symbol pub autoLink linkName="crbegin" name={<>rbegin<br/>crbegin <small>(since C++11)</small></>}>
		Returns a reverse iterator to the beginning.
	</Symbol>
	<Symbol pub autoLink linkName="crend" name={<>rend<br/>crend <small>(since C++11)</small></>}>
		Returns a reverse iterator to the end.
	</Symbol>
</SymbolTable>

### Capacity

<SymbolTable>
	<Symbol pub autoLink linkName="empty" name="empty">
		Returns <code>true</code> if the multimap is empty, otherwise <code>false</code>.
	</Symbol>
	<Symbol pub autoLink linkName="size" name="size">
		Returns the number of elements in the multimap.
	</Symbol>
	<Symbol pub autoLink linkName="max_size" name="max_size">
		Returns the maximum possible number of elements.
	</Symbol>
</SymbolTable>

### Modifiers

<SymbolTable>
	<Symbol pub autoLink linkName="clear" name="clear">
		Clears the contents of the multimap.
	</Symbol>
	<Symbol pub autoLink linkName="insert" name="insert">
		Inserts elements or nodes (extracted with <code>.extract()</code>) <small>(since C++17)</small>.
	</Symbol>
	<Symbol pub autoLink linkName={<>emplace <small>(since C++11)</small></>} name="emplace">
		Constructs a new element in place.
	</Symbol>
	<Symbol pub autoLink linkName={<>emplace_hint <small>(since C++11)</small></>} name="emplace_hint">
		Constructs elements in-place using a hint (iterator).
	</Symbol>
	<Symbol pub autoLink linkName="erase" name="erase">
		Erases elements.
	</Symbol>
	<Symbol pub autoLink linkName="swap" name="swap">
		Swaps two multimaps.
	</Symbol>
	<Symbol pub autoLink linkName="extract" name={<>extract <small>(since C++17)</small></>}>
		Extracts nodes from the multimap (can be later inserted somewhere else).
	</Symbol>
	<Symbol pub autoLink linkName="merge" name={<>merge <small>(since C++17)</small></>}>
		Merges two multimaps together.
	</Symbol>
</SymbolTable>

### Lookup

<SymbolTable>
	<Symbol pub autoLink linkName="count" name="count">
		Returns the number of elements matching a specific key.
	</Symbol>
	<Symbol pub autoLink linkName="find" name="find">
		Searches for an element and returns an iterator to it, or end iterator if not found.
	</Symbol>
	<Symbol pub autoLink linkName="contains" name={<>contains <small>(since C++20)</small></>}>
		Returns <code>true</code> if an element is inside the multimap, otherwise <code>false</code>.
	</Symbol>
	<Symbol pub autoLink linkName="equal_range" name="equal_range">
		Returns a range of elements matching a specific key.
	</Symbol>
	<Symbol pub autoLink linkName="lower_bound" name="lower_bound">
		Returns an iterator to the first element <i>not less</i> than the given key.
	</Symbol>
	<Symbol pub autoLink linkName="upper_bound" name="upper_bound">
		Returns an iterator to the first element <i>greater</i> than the given key
	</Symbol>
</SymbolTable>

### Observers

<SymbolTable>
	<Symbol pub autoLink linkName="Key_comp" name="key_comp">
		Returns an internal function object that compares keys.
	</Symbol>
	<Symbol pub autoLink linkName="value_comp" name="value_comp">
		Returns an internal function object that compares keys in objects of type <code>value_type</code> (<code>std::pair&lt;const Key, Value&gt;</code>).
	</Symbol>
</SymbolTable>

## Non-member functions

<SymbolTable noTraits>
	<Symbol name={<>
				operator==<br/>
				operator!= <small>(removed in C++20)</small><br/>
				operator&lt; <small>(removed in C++20)</small><br/>
				operator&gt; <small>(removed in C++20)</small><br/>
				operator&lt;= <small>(removed in C++20)</small><br/>
				operator&gt;= <small>(removed in C++20)</small><br/>
				operator&lt;=&gt;
			</>}
			desc="Lexicographically compares the values in a multimap."
		/>
	<Symbol name={<>std::swap <small>(std::multimap)</small></>}
			desc={<>An overload for a <a href="#">std::swap</a> algorithm.</>}
		/>
	<Symbol name={<>
				std::erase_if <small>(std::multimap)</small>
			</>}
			desc={<>Overloads for <a href="#">std::erase_if</a> algorithms.</>}
		/>
</SymbolTable>

</ClassSummary>

## Deduction guides (since C++17)
<details>
<summary>Click to expand</summary>
<div>
	<DeductionGuides />
</div>
</details>

## More examples

### Basic manipulation

<Columns spacing="20px" columns={['8fr', '4fr']}>
<div>

<CustomCodeBlock withTitle>
	<FurtherExampleCreateInsertPrint />
</CustomCodeBlock>

</div>
<div>

```plaintext title="Result"
health 30
health 200
mana 25
mana 50
speed 10
```
</div>
</Columns>