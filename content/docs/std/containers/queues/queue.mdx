---
sidebar_position:	2
title:				std::queue reference
sidebar_label:		queue
hide_title:			true
description:		Summary of a std::queue (usage, methods, etc.) - C++ Language
tags:				[queue, adapter, fifo]
---

import ClassSummary				from "@site-comps/ClassSummary";
import SymbolTable, { Symbol }	from "@site-comps/SymbolTable";
import Columns					from "@site-comps/Columns";
import NotFinished				from "@site/i18n/en/presets/NotFinished.mdx";
import ImproveSection			from "@site/i18n/en/presets/ImproveSection.mdx";
import Tabs						from "@theme/Tabs";
import TabItem						from "@theme/TabItem";

<!------------------ Codes ----------------->

<!-- Further Examples -->
import FurtherExamplePushPopPrint from "./priority-queue/_codes/main-page/examples/further/push-pop-print.mdx"

<!-- Overview -->
import OverviewSimplifiedRegular from "./queue/_codes/main-page/overview/overview-simplified-regular.mdx";
import OverviewDetailedReguler from "./queue/_codes/main-page/overview/overview-detailed-regular.mdx";

<!-- Deduction Guides -->
import DeductionGuides from "./queue/_codes/main-page/deduction-guides.mdx";

<NotFinished />

# Queue class reference

## Overview

<Tabs>
<TabItem value="simplified" label="Simplified" default>

	<OverviewSimplifiedRegular />

</TabItem>
<TabItem value="detailed" label="Detailed">

	<OverviewDetailedReguler />

</TabItem>
</Tabs>

Queue is a container **adapter** - it adapts a container by providing a new interface to it.

The new interface is a **FIFO** (**F**irst **I**n **F**irst **O**ut) data structure.
This means that the first element to be pushed is the first one to be accessed (like in a shop queue - first person to get in is the first person to be served).

<details>
<summary>Technical definition of a queue</summary>
<div>

The `std::queue` class is a container adapter that gives the programmer the functionality of a queue - specifically, a *FIFO* (first-in, first-out) data structure.

The class template acts as a wrapper to the underlying container - only a specific set of functions is provided.
The queue pushes the elements on the back of the underlying container and pops them from the front.

</div>
</details>

<ClassSummary name="queue" namespaces="std" folder="queue" headerName="queue">

## Template parameters

<SymbolTable noTraits>
	<Symbol
			name="T"
			desc={<>
				The type of the stored elements.
				The behaviour is undefined if <code>T</code> is not <code>Container::value_type</code>.
				</>}
		/>
	<Symbol
			name="Container"
			desc={<>
				The type of the underlying container used to store the elements.
				By default <a href="/docs/containers/arays/vector"><code>std::deque&lt;T&gt;</code></a>.
				The container must satisfy <a href="/docs/named_req/SequenceContainer">SequenceContainer</a>.
				</>}
		/>
</SymbolTable>

## Type names

<SymbolTable>
	<Symbol pub name="container_type"				desc={<code>Container</code>}/>
	<Symbol pub name="value_type" 				desc={<code>Container::value_type</code>}/>
	<Symbol pub name="size_type"			desc={<code>Container::size_type</code>}/>
	<Symbol pub name="reference"				desc={<code>Container::reference</code>}/>
	<Symbol pub name="const_reference"			desc={<code>Container::const_reference</code>}/>
</SymbolTable>

## Member functions

<SymbolTable>
	<Symbol pub autoLink linkName="constructor" name="(constructor)">
		Constructs a <code>queue</code>.
	</Symbol>
	<Symbol pub autoLink linkName="destructors" name="(destructor)">
		Destructs a <code>queue</code>.
	</Symbol>
	<Symbol pub autoLink linkName="operator_assign" name="operator="
			desc="Assigns one queue to another."
		/>
</SymbolTable>

### Element access

<SymbolTable>
	<Symbol pub autoLink name="front"
			desc="Accesses the element at the top (first pushed)."
		/>
	<Symbol pub autoLink name="back"
			desc="Accesses the element at the back (last pushed)."
		/>
</SymbolTable>

### Capacity

<SymbolTable>
	<Symbol pub autoLink name="empty"
			desc={<>Returns <code>true</code> if the queue is empty, otherwise <code>false</code>.</>}
		/>
	<Symbol pub autoLink name="size" desc="Returns the number of elements in the queue." />
</SymbolTable>

### Modifiers

<SymbolTable>
	<Symbol pub autoLink name="push"
			desc="Inserts a new element at the end."
		/>
	<Symbol pub autoLink name={<>emplace <small>(since C++11)</small></>} linkName="emplace"
			desc="Constructs a new element in-place at the end."
		/>
	<Symbol pub autoLink name="pop"
			desc={<>Removes the first pushed element (the one that would've been returned by <code>queue.front()</code>).</>}
		/>
	<Symbol pub autoLink name={<>swap <small>(since C++11)</small></>} linkName="swap"
			desc="Swaps two queues."
		/>
</SymbolTable>

## Member objects

<SymbolTable>
	<Symbol prot name={<><code>Container</code> C</>}
			desc={<>The underlying container. By default <a href="/docs/containers/queues/deque"><code>std::deque&lt;T&gt;</code></a>.</>}
		/>
</SymbolTable>

## Non-member functions

<SymbolTable noTraits>
	<Symbol name={<>
				operator== <br/>
				operator!= <br/>
				operator&lt; <br/>
				operator&gt; <br/>
				operator&lt;= <br/>
				operator&gt;= <br/>
				operator&lt;=&gt; <small>(C++20)</small>
			</>}
			desc="Lexicographically compares values in a queue."
		/>
	<Symbol name={<>std::swap <small>(std::queue)</small></>}
			desc={<>An overload for the <a href="#">std::swap</a> algorithm.</>}
		/>
</SymbolTable>

### Helper classes

<SymbolTable noTraits>
	<Symbol name={<>
			<a href="#">std::uses_allocator</a> <small>(std::queue)</small>
		</>}
			desc={<>Specializes the <code>std::uses_allocator</code> type trait.</>}
		/>
</SymbolTable>

</ClassSummary>


## Deduction guides (since C++17)
<details>
<summary>Click to expand</summary>
<div>
	<DeductionGuides />
</div>
</details>

## Examples

### Basic manipulation

<Columns spacing="20px" columns={['8fr', '4fr']}>
<div>

<CustomCodeBlock withTitle>
	<FurtherExamplePushPopPrint />
</CustomCodeBlock>

</div>
<div>

```plaintext title="Result"
1
2
3
```

</div>
</Columns>
