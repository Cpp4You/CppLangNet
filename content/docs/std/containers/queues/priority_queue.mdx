---
sidebar_position:	2
title:				std::priority_queue reference
sidebar_label:		priority_queue
hide_title:			true
---
<NotFinished />

# Priority_queue class reference

## Overview

import ClassSummary				from "@site-comps/ClassSummary";
import SymbolTable, { Symbol }	from "@site-comps/SymbolTable";
import Columns					from "@site-comps/Columns";
import NotFinished				from "@site/i18n/en/presets/NotFinished.mdx";
import ImproveSection			from "@site/i18n/en/presets/ImproveSection.mdx";
import Tabs						from "@theme/Tabs";
import TabItem						from "@theme/TabItem";

<!-- Deduction Guides -->
import DeductionGuides from "./_codes/priority-queue/main-page/deduction-guides.mdx"

<Tabs>
<TabItem value="simplified" label="Simplified" default>

```cpp
template< class T, /* ... */ >
class priority_queue;
```

</TabItem>
<TabItem value="detailed" label="Detailed">

```cpp
template<
    class T,
    class Container = std::vector<T>,
    class Compare = std::less<typename Container::value_type>
> class priority_queue;
```

</TabItem>
</Tabs>

The priority queue is basically a queue, which stores elements in some order.

Programmer can specify what the order will be.

<details>
<summary>Technical definition of a queue</summary>
<div>

A priority queue is a container adaptor that provides constant time lookup of the largest (by default) element, at the expense of logarithmic insertion and extraction.

A user-provided Compare can be supplied to change the ordering, e.g. using  would cause the smallest element to appear as the top().

Working with a priority_queue is similar to managing a heap in some random access container, with the benefit of not being able to accidentally invalidate the heap. 
</div>
</details>

<ClassSummary name="priority_queue" namespaces="std" folder="queue" headerName="queue">

## Template parameters

<SymbolTable noTraits>
	<Symbol name="T"		desc="The type of stored elements"/>
	<Symbol name="Container" 		desc="The type of underlying container to use to store the elements"/>
	<Symbol name="Compare" 		desc="A compare type providing a strict weak ordering"/>
</SymbolTable>

## Type names

<SymbolTable>
	<Symbol pub name="container_type"				desc={<code>Container</code>}/>
	<Symbol pub name="value_compare" 				desc={<code>Compare</code>}/>
	<Symbol pub name="value_type"			desc={<code>Container::value_type</code>}/>
	<Symbol pub name="size_type"				desc={<code>Container::size_type</code>}/>
	<Symbol pub name="reference"			desc={<code>Container::reference</code>}/>
	<Symbol pub name="const_reference"			desc={<code>Container::const_reference</code>}/>
</SymbolTable>

## Member functions

<SymbolTable>	
	<Symbol pub autoLink linkName="constructor" name="(constructor)">
		Constructs the <code>priority_queue</code>
	</Symbol>
	<Symbol pub autoLink linkName="destructor" name="(destructor)">
		Destructs the <code>priority_queue</code>
	</Symbol>
	<Symbol pub autoLink linkName="operator_assign" name="operator="
			desc="Assigns values to the container adaptor"
		/>
</SymbolTable>

### Element access

<SymbolTable>	
	<Symbol pub autoLink name="top"
			desc={<>Accesses the top element</>}
		/>
</SymbolTable>

### Capacity

<SymbolTable>	
	<Symbol pub autoLink linkName="begin" name={<>empty</>}
			desc={<>Checks whether the underlying container is empty</>}
		/>
	<Symbol pub autoLink linkName="end" name={<>size</>}
			desc={<>Returns the number of elements</>}
		/>
</SymbolTable>

### Modifiers

<SymbolTable>
	<Symbol pub autoLink name="push"
			desc="Inserts element and sorts the underlying container"
		/>
	<Symbol pub autoLink name="emplace"
			desc="Constructs element in-place and sorts the underlying container"
		/>
	<Symbol pub autoLink name="pop"
			desc="Removes the top element"
		/>
	<Symbol pub autoLink name="swap"
			desc="Swaps the contents"
		/>
</SymbolTable>

### Member objects

<SymbolTable>
	<Symbol prot autoLink name="Container C"
			desc="The underlying container"
		/>
	<Symbol prot autoLink name="Compare comp"
			desc="The comparison function object"
		/>
</SymbolTable>

## Non-member functions

<SymbolTable noTraits>
	<Symbol name={<>
				<a href="#">std::swap</a>
			</>}
			desc="specializes the std::swap algorithm "
		/>

</SymbolTable>

## Helper classes

<SymbolTable noTraits>
	<Symbol name={<>
				<a href="#">std::uses_allocator</a>
			</>}
			desc="specializes the std::uses_allocator algorithm "
		/>

</SymbolTable>

</ClassSummary>


## Deduction guides (since C++17)
<details>
<summary>Click to expand</summary>
<div>
	<DeductionGuides/>
</div>
</details>

## Examples

### Basic manipulation

#### Push and pop on queue, printing the values

<Columns spacing="20px" columns={['8fr', '4fr']}>
<div>

```cpp
#include <iostream>
#include <queue>

int main()
{
	std::priority_queue<int> q;

	q.push(1);
	q.push(2);
	q.push(3);

	while (q.empty() == false) {
		std::cout << q.top() << std::endl;
		q.pop();
	}
}
```

</div>
<div>

```plaintext title="Result"
3
2
1
```

</div>
</Columns>