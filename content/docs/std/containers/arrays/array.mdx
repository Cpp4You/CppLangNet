---
sidebar_position:	2
title:				std::array reference
sidebar_label:		array
hide_title:			true
description:		Summary of a std::array (usage, methods, etc.) - C++ Language
---

import ClassSummary				from "@site-comps/ClassSummary";
import SymbolTable, { Symbol }	from "@site-comps/SymbolTable";
import Columns					from "@site-comps/Columns";
import SwitchView				from "@site-comps/SwitchView";
import NotFinished				from "@site/i18n/en/presets/NotFinished.mdx";
import ImproveSection			from "@site/i18n/en/presets/ImproveSection.mdx";
import Tabs						from "@theme/Tabs";
import TabItem					from "@theme/TabItem";

<!------------------ Codes ----------------->

<!-- Top Examples -->
import TopExampleCreateCpp20			from "./_codes/array/main-page/top-example-create-cpp20.mdx";
import TopExampleCreateCpp17			from "./_codes/array/main-page/top-example-create-cpp17.mdx";
import TopExampleCreateUntilCpp17		from "./_codes/array/main-page/top-example-create-until-cpp17.mdx";

import TopExampleSortCpp20				from "./_codes/array/main-page/top-example-sort-cpp20.mdx";
import TopExampleSortUntilCpp20			from "./_codes/array/main-page/top-example-sort-until-cpp20.mdx";

# Array class reference

## Overview

```cpp
template <typename T, size_t N>
class array
```

`std::array` is a container that encapsulates fixed size arrays.  

### Example usage

The examples in this section are very simple ones. Navigate to [examples section at the bottom](#more-examples) for more.

<Tabs>
<TabItem value="create" label="Create" default>
<div style={{ padding: "10px 20px", border: "1px solid gray" }}>
<SwitchView content={
		{
			"cpp20": <TopExampleCreateCpp20 />,
			"cpp17": <TopExampleCreateCpp17 />,
			"until-cpp17": <TopExampleCreateUntilCpp17 />,
			"String literal": <>

Note: this is only recommended if you don't have C++20, otherwise use `std::to_array`.

```cpp
#include <array>

int main() {
	std::array<char, 6> str = { "Hello" };
	// Content: 'H','e','l','l','o', <nul>
}
```

</>
		}
	}/>
</div>
</TabItem>
<TabItem value="fill" label="Fill and print">
<div style={{ padding: "10px 20px", border: "1px solid gray" }}>

```cpp
#include <iostream>
#include <array>

int main()
{
	std::array<int, 4> playerScores{}; // initialize with zeros

	for (int score : playerScores)
		std::cout << score << ", ";

	playerScores.fill(123);
	playerScores.back() = 30;

	std::cout << '\n';
	for (int score : playerScores)
		std::cout << score << ", ";
}
```

</div>
</TabItem>
<TabItem value="sort" label="Sort">
<div style={{ padding: "10px 20px", border: "1px solid gray" }}>

<SwitchView content={
		{
			"cpp20":		<TopExampleSortCpp20 />,
			"until-cpp20":	<TopExampleSortUntilCpp20 />,
		}
	}/>

</div>
</TabItem>
</Tabs>

### Memory

The elements of an array are stored contiguously in memory.

<p align="center">
	<img style={{border: "1px solid gray", maxHeight: 250}} alt="Array elements in memory" src="/img/component-overview/array-elements-in-memory.png" />
</p>

### Technical details

<details>
<summary>Technical definition of an array</summary>
<div>

This container is an aggregate type with the same semantics as a struct holding a C-style array `T[N]`
as its only non-static data member. Unlike a C-style array, it doesn't decay to `T*` automatically.
As an aggregate type, it can be initialized with aggregate-initialization given at most `N` initializers
that are convertible to `T`:

```cpp
std::array<int, 3> a = {1,2,3};
```

The struct combines the performance and accessibility of a C-style array with the benefits of a standard container,
such as knowing its own size, supporting assignment, random access iterators, etc.

An array can also be used as a tuple of `N` elements of the same type.

</div>
</details>

<details>
<summary>Zero-length array (<code>N == 0</code>)</summary>
<div>

There is a special case for a zero-length array (`N == 0`). In that case, `array.begin() == array.end()`,
which is some unique value. The effect of calling `front()` or `back()` on a zero-sized array is **undefined**.

</div>
</details>

<details>
<summary>Named requirements</summary>
<div>

`std::array` satisfies the requirements of:

- `Container`
- `ReversibleContainer`

except that default-constructed array is not empty and that the complexity of swapping is linear.

Satisfies the requirements of:

- `ContiguousContainer` (since C++17)
- `SequenceContainer` (partially)

</div>
</details>




<ClassSummary name="array" namespaces="std" folder="array" headerName="array">

## Template parameters

<SymbolTable noTraits>
	<Symbol name="T"			desc="Type of the elements"/>
	<Symbol name="N" 			desc="Number of elements (a compile-time constant)"/>
</SymbolTable>

## Type names

<SymbolTable>
	<Symbol pub name="value_type" 				desc={<code>T</code>}/>
	<Symbol pub name="size_type"				desc={<code>std::size_t</code>}/>
	<Symbol pub name="difference_type"			desc={<code>std::ptrdiff_t</code>}/>
	<Symbol pub name="reference"				desc={<code>value_type&amp;</code>}/>
	<Symbol pub name="const_reference"			desc={<code>value_type const&amp;</code>}/>
	<Symbol pub name="pointer"					desc={<code>value_type*</code>}/>
	<Symbol pub name="const_pointer"			desc={<code>value_type const*</code>}/>
	<Symbol pub name="iterator"					desc={<><a href="#"><code>LegacyRandomAccessIterator</code></a> to <code>value_type</code></>}/>
	<Symbol pub name="const_iterator"			desc={<><a href="#"><code>LegacyRandomAccessIterator</code></a> to <code>value_type const</code></>}/>
	<Symbol pub name="reverse_iterator"			desc={<><a href="#"><code>std::reverse_iterator&lt;iterator&gt;</code></a></>}/>
	<Symbol pub name="const_reverse_iterator"	desc={<><a href="#"><code>std::reverse_iterator&lt;const_iterator&gt;</code></a></>}/>
</SymbolTable>

## Member functions

<SymbolTable>	
	<Symbol pub autoLink linkName="constructor" name="(constructor)">
		Constructs an <code>array</code> following the rules of aggregate initialization.
	</Symbol>
	<Symbol pub autoLink linkName="destructor" name="(destructor)">
		Destroys every element of the array.
	</Symbol>
	<Symbol pub autoLink linkName="operator_assign" name="operator="
			desc="Overwrites every element of the array with the corresponding element of another array"
		/>
</SymbolTable>

### Element access

<SymbolTable>	
	<Symbol pub autoLink name="at"
			desc={<>Accesses the specified element <b>with bounds checking</b></>}
		/>
	<Symbol pub autoLink linkName="operator_index" name="operator[]"
			desc={<>Accesses the element</>}
		/>
	<Symbol pub autoLink name="front"
			desc="Returns the first element"
		/>
	<Symbol pub autoLink name="back"
			desc="Returns the last element"
		/>
	<Symbol pub autoLink name="data"
			desc="Returns a pointer to the first element of the underlying array"
		/>
</SymbolTable>

### Iterators

<SymbolTable>	
	<Symbol pub autoLink linkName="begin" name={<>begin<br/>cbegin</>}
			desc={<>Returns an <code>iterator/const_iterator</code> to the beginning</>}
		/>
	<Symbol pub autoLink linkName="end" name={<>end<br/>cend</>}
			desc={<>Returns an <code>iterator/const_iterator</code> to the end</>}
		/>
	<Symbol pub autoLink linkName="rbegin" name={<>rbegin<br/>crbegin</>}
			desc={<>Returns an reverse <code>iterator/const_iterator</code> to the beginning</>}
		/>
	<Symbol pub autoLink linkName="rend" name={<>rend<br/>crend</>}
			desc={<>Returns an reverse <code>iterator/const_iterator</code> to the end</>}
		/>
</SymbolTable>

### Capacity

<SymbolTable>	
	<Symbol pub autoLink name="empty">
		Returns <code>true</code> if the container is empty, otherwise <code>false</code>.
	</Symbol>
	<Symbol pub autoLink name="size"
			desc="Returns the number of elements"
		/>
	<Symbol pub autoLink name="max_size"
			desc="Returns the maximum possible number of elements"
		/>
</SymbolTable>

### Operations

<SymbolTable>
	<Symbol pub autoLink name="fill"
			desc="Fills the container with specified value"
		/>
	<Symbol pub autoLink name="swap"
			desc="Swaps the contents"
		/>
</SymbolTable>

## Non-member functions

<SymbolTable noTraits>
	<Symbol name={<>
				operator==<br/>
				operator!=<br/>
				operator&lt;<br/>
				operator&gt;<br/>
				operator&lt;=<br/>
				operator&gt;=<br/>
				operator&lt;=&gt;
			</>}
			desc="Lexicographically compares the values in the array"
		/>
	<Symbol name={<>std::get <small>(std::array)</small></>}
			desc={<>Accesses an element of the array</>}
		/>
	<Symbol name={<>std::swap <small>(std::array)</small></>}
			desc={<>Specializes the <a href="#">std::swap</a> algorithm</>}
		/>
	<Symbol name={<>std::to_array <small>(C++20)</small></>}
			desc={<>creates a std::array object from a built-in array</>}
		/>
</SymbolTable>

## Helper classes

<SymbolTable noTraits>
	<Symbol name={<>
				std::tuple_size<small>&lt;std::array&gt; (C++11)</small><br/>
			</>}
			desc="obtains the size of an array"
		/>
	<Symbol name={<>
				std::tuple_element<small>&lt;std::array&gt; (C++11)</small><br/>
			</>}
			desc="obtains the type of the elements of array"
		/>
</SymbolTable>
</ClassSummary>


## Deduction guides

<ImproveSection />

## More examples

### Using algorithms

#### Find minimal value

<Columns spacing="20px" columns={['8fr', '4fr']}>
<div>

```cpp
#include <iostream>
#include <array>
#include <algorithm>
#include <ranges>

namespace rg = std::ranges;

int main()
{
	auto numbers = std::to_array({ 12, 3, 18, 9}); // C++20
	
	// Find minimal element
	auto minIt = rg::min_element(numbers); // C++20

	// obtain value:
	auto value = *minIt;
	// find position:
	auto index = std::distance(numbers.begin(), minIt);

	
	std::cout	<< "Min: "			<< value
				<< ", at index: "	<< index
				<< std::endl;
}
```

</div>
<div>

```plaintext title="Result"
Min: 3, at index: 1
```

</div>
</Columns>

### Advanced

#### Using array as a temporary buffer

```cpp
#include <fstream>
#include <array>
#include <string>

std::string readFile(std::istream& file)
{
	constexpr size_t BUFFER_SIZE	= 16 * 1024;		// 16 KB
	constexpr size_t RESERVE_SIZE	= 1 * 1024 * 1024;	// 1 MB
	std::string result;
	result.reserve(RESERVE_SIZE); // 1 MB

	std::array<char, BUFFER_SIZE> buf;

	while(file.read(buf.data(), buf.size()))
		result.append(buf.data(), buf.data() + file.gcount());

	result.append(buf.data(), buf.data() + file.gcount());
	return result;
}

// Example usage:
int main()
{
	std::ifstream file("hello.txt");
	if (file.is_open())
	{
		auto fileContents = readFile(file);
		// ...
	}
}
```

#### Concat two arrays

<Columns spacing="20px" columns={['8fr', '4fr']}>
<div>

```cpp
#include <iostream>
#include <array>

template <typename T, size_t N1, size_t N2>
std::array<T, N1 + N2> concat(
		std::array<T, N1> const& lhs,
		std::array<T, N2> const& rhs
	)
{
	std::array<T, N1 + N2> result;
	
	// Copy left array
	for (size_t i = 0; i < lhs.size(); ++i)
		result[i] = lhs[i];

	// Copy right array
	for (size_t i = 0; i < rhs.size(); ++i)
		result[i + lhs.size()] = rhs[i];

	return result;
}

int main()
{
	auto left	= std::to_array({1, 2, 3});
	auto right	= std::to_array({4, 5, 6});
	
	auto both	= concat(left, right);

	for (int elem : both)
		std::cout << elem << ", ";
}
```

</div>
<div>

```plaintext title="Result"
1, 2, 3, 4, 5, 6, 
```

</div>
</Columns>