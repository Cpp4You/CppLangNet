---
sidebar_position:	2
title:				std::set reference
sidebar_label:		set
tags:				[set, associative, container, key]
hide_title:			true
---

import ClassSummary				from "@site-comps/ClassSummary";
import SymbolTable, { Symbol }	from "@site-comps/SymbolTable";
import Columns					from "@site-comps/Columns";
import NotFinished				from "@site/i18n/en/presets/NotFinished.mdx";
import ImproveSection			from "@site/i18n/en/presets/ImproveSection.mdx";
import Tabs						from "@theme/Tabs";
import TabItem					from "@theme/TabItem";

<NotFinished />

# Set class reference

## Overview

<Tabs>
<TabItem value="detailed" label="Detailed" default>

```cpp
template<
    class Key,
    class Compare = std::less<Key>,
    class Allocator = std::allocator<Key>
> class set;
```

</TabItem>
</Tabs>

The `std::set` is a container that stores unique objects, by default ordered ascending.

### Example usage

The examples in this section are very simple ones. Navigate to [examples section at the bottom](#more-examples) for more.

<ImproveSection />

### Technical details

<details>
<summary>Technical definition of a set</summary>
<div>

std::set is an associative container that contains a sorted set of unique objects of type Key. Sorting is done using the key comparison function Compare. Search, removal, and insertion operations have logarithmic complexity. Sets are usually implemented as red-black trees.

Everywhere the standard library uses the Compare requirements, uniqueness is determined by using the equivalence relation. In imprecise terms, two objects a and b are considered equivalent if neither compares less than the other: !comp(a, b) && !comp(b, a).

std::set meets the requirements of Container, AllocatorAwareContainer, AssociativeContainer and ReversibleContainer. 

</div>
</details>

<ClassSummary name="set" namespaces="std" folder="set" headerName="set">

## Template parameters

<SymbolTable noTraits>
	<Symbol name="Key"		desc="The type of stored keys"/>
	<Symbol name="Compare" 		desc="Key comparison function"/>
	<Symbol name="Allocator" 		desc="Is responsible for allocating and deallocating memory"/>
</SymbolTable>

## Type names

<SymbolTable>
	<Symbol pub name="key_type"				desc="Key"/>
	<Symbol pub name="value_type" 				desc="Key"/>
	<Symbol pub name="size_type"			desc="Unsigned integer type"/>
	<Symbol pub name="difference_type"				desc="Signed integer type"/>
	<Symbol pub name="key_compare"			desc="Compare"/>
	<Symbol pub name="value_compare"				desc="Compare"/>
	<Symbol pub name="allocator_type" 				desc="Allocator"/>
	<Symbol pub name="reference"			desc={<code>value_type&</code>}/>
	<Symbol pub name="const_reference"				desc={<code>const value_type&</code>}/>
	<Symbol pub name="pointer"			desc={<code>std::allocator_traits&lt;Allocator&gt;::pointer</code>}/>
	<Symbol pub name="const_pointer"			desc={<code>std::allocator_traits&lt;Allocator&gt;::const_pointer</code>}/>
	<Symbol pub name="iterator"			desc="Constant LegacyBidirectionalIterator to value_type"/>
	<Symbol pub name="const_iterator"			desc="LegacyBidirectionalIterator to const value_type"/>
	<Symbol pub name="reverse_iterator"			desc={<code>std::reverse_iterator&lt;iterator&gt;</code>}/>
	<Symbol pub name="const_reverse_iterator"			desc={<code>std::reverse_iterator&lt;const_iterator&gt;</code>}/>
	<Symbol pub name="node_type"			desc="A specialization of node handle representing a container node"/>
<Symbol pub name="insert_return_type">
Type describing the result of inserting a node_type, a specialization of

```cpp
template <class Iter, class NodeType> struct /*unspecified*/ {
    Iter     position;
    bool     inserted;
    NodeType node;
};
```
instantiated with template arguments iterator and node_type.
</Symbol>
</SymbolTable>

## Member functions

<SymbolTable>	
	<Symbol pub autoLink linkName="constructor" name="(constructor)">
		Constructs the <code>map</code>
	</Symbol>
	<Symbol pub autoLink linkName="destructor" name="(destructor)">
		Destructs the <code>map</code>
	</Symbol>
	<Symbol pub autoLink linkName="operator=" name="operator=">
		Assigns values to the container
	</Symbol>
	<Symbol pub autoLink linkName="get_allocator" name="get_allocator">
		Returns the associated allocator
	</Symbol>

</SymbolTable>

### Iterators

<SymbolTable>	
	<Symbol pub autoLink linkName="begin" name={<>begin<br/>cbegin</>}>
		Returns an iterator to the beginning
	</Symbol>
	<Symbol pub autoLink linkName="end" name={<>end<br/>cend</>}>
		Returns an iterator to the end
	</Symbol>
	<Symbol pub autoLink linkName="crbegin" name={<>rbegin<br/>crbegin</>}>
		Returns a reverese iterator to the beginning
	</Symbol>
	<Symbol pub autoLink linkName="crend" name={<>rend<br/>crend</>}>
		Returns a reverse iterator to the end
	</Symbol>
</SymbolTable>

### Capacity

<SymbolTable>
	<Symbol pub autoLink linkName="empty" name="empty">
		Checks whether the container is empty
	</Symbol>
	<Symbol pub autoLink linkName="size" name="size">
		Returns the number of elements
	</Symbol>
	<Symbol pub autoLink linkName="max_size" name="max_size">
		Returns the maximum possible number of elements
	</Symbol>
</SymbolTable>

### Modifiers

<SymbolTable>
	<Symbol pub autoLink linkName="clear" name="clear">
		Clears the contents
	</Symbol>
	<Symbol pub autoLink linkName="insert" name="insert">
		Inserts elements or nodes
	</Symbol>
	<Symbol pub autoLink linkName="emplace" name="emplace">
		Constructs element in place
	</Symbol>
	<Symbol pub autoLink linkName="emplace_hint" name="emplace_hint">
		Constructs elements in-place using a hint
	</Symbol>
	<Symbol pub autoLink linkName="erase" name="erase">
		Erases elements
	</Symbol>
	<Symbol pub autoLink linkName="swap" name="swap">
		Swaps the contents
	</Symbol>
	<Symbol pub autoLink linkName="extract" name="extract">
		Extracts nodes from the container
	</Symbol>
	<Symbol pub autoLink linkName="merge" name="merge">
		Splices nodes from another container
	</Symbol>
</SymbolTable>

### Lookup

<SymbolTable>
	<Symbol pub autoLink linkName="count" name="count">
		Returns the number of elements matching specific key
	</Symbol>
	<Symbol pub autoLink linkName="find" name="find">
		Finds element with specific key
	</Symbol>
	<Symbol pub autoLink linkName="contains" name="contains">
		Checks if the container contains element with specific
	</Symbol>
	<Symbol pub autoLink linkName="equal_range" name="equal_range">
		Raturns range of elements matching a specific key
	</Symbol>
	<Symbol pub autoLink linkName="lower_bound" name="lower_bound">
		Returns an iterator to the first element not less than the given key
	</Symbol>
	<Symbol pub autoLink linkName="upper_bound" name="upper_bound">
		Returns an iterator to the first element greater than the given key
	</Symbol>
</SymbolTable>

### Observers

<SymbolTable>
	<Symbol pub autoLink linkName="Key_comp" name="key_comp">
		Returns the function that compares keys
	</Symbol>
	<Symbol pub autoLink linkName="value_comp" name="value_comp">
		Returns the function that compares keys in objects of type value_type
	</Symbol>
</SymbolTable>

## Non-member functions

<SymbolTable noTraits>
	<Symbol name={<>
				operator==<br/>
				operator!=<br/>
				operator&lt;<br/>
				operator&gt;<br/>
				operator&lt;=<br/>
				operator&gt;=<br/>
				operator&lt;=&gt;
			</>}
			desc="Lexicographically compares the values in the set">
	</Symbol>
	<Symbol pub autoLink linkName="std::swap" name="std::swap">
		Specializes the <code>std::swap</code> algorithm
	</Symbol>
	<Symbol pub autoLink linkName="erase_if" name="erase_if">
		Erases all elements satisfying specific criteria
	</Symbol>
</SymbolTable>

</ClassSummary>


## Deduction guides

<ImproveSection />

## More examples

### Basic manipulation

#### Creating set, inserting values and printing them out

<Columns spacing="20px" columns={['8fr', '4fr']}>
<div>

```cpp
#include <iostream>
#include <string>
#include <set>

int main() {
  std::set<int> unique_item_id = { 3, 3, 1};

  unique_item_id.insert(12);
  unique_item_id.insert(12);

  std::cout << "Unique items id's:" << std::endl;
  for (auto& i : unique_item_id)
    std::cout << i << std::endl;

  return 0;
}
```

</div>
<div>

```plaintext title="Result"
Unique items id's:
1
3
12
```
</div>

</Columns>

#### Deleting values from a set

<Columns spacing="20px" columns={['8fr', '4fr']}>
<div>

```cpp
#include <iostream>
#include <set>

int main() {
  std::set<int> numbers = { 1, 2, 3, 4, 5, 6, 7, 8, 9};
  
  for (auto i = numbers.begin(); i != numbers.end();) {
    if (*i % 2 == 0)
      i = numbers.erase(i);
    else
      ++i;
  }

  for (auto& i : numbers)
    std::cout << i << std::endl;

  return 0;
}
```

</div>
<div>

```plaintext title="Result"
1
3
5
7
9
```
</div>

</Columns>

#### Merging two sets

<Columns spacing="20px" columns={['8fr', '4fr']}>
<div>

```cpp
#include <iostream>
#include <set>

int main() {
  std::set<char> letters = { 'A', 'C', 'B'};
  std::set<char> letters2 = { 'E', 'D', 'C'};

  letters.merge(letters2);

  for (auto& i : letters)
    std::cout << i << " ";

  std::cout << std::endl;

  for (auto& i : letters2)
    std::cout << i << " ";

  return 0;
}
```

</div>
<div>

```plaintext title="Result"
A B C D E
C
```
</div>

</Columns>